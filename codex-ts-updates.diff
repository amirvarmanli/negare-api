diff --git a/apps/api/src/app.controller.spec.ts b/apps/api/src/app.controller.spec.ts
index 624dfbe..a3c4d27 100644
--- a/apps/api/src/app.controller.spec.ts
+++ b/apps/api/src/app.controller.spec.ts
@@ -1,6 +1,6 @@
 import { Test, TestingModule } from '@nestjs/testing';
-import { AppController } from './app.controller';
-import { AppService } from './app.service';
+import { AppController } from '@app/app.controller';
+import { AppService } from '@app/app.service';
 
 describe('AppController', () => {
   let appController: AppController;
diff --git a/apps/api/src/app.controller.ts b/apps/api/src/app.controller.ts
index cce879e..ba99f1b 100644
--- a/apps/api/src/app.controller.ts
+++ b/apps/api/src/app.controller.ts
@@ -1,5 +1,5 @@
 import { Controller, Get } from '@nestjs/common';
-import { AppService } from './app.service';
+import { AppService } from '@app/app.service';
 
 @Controller()
 export class AppController {
diff --git a/apps/api/src/app.module.ts b/apps/api/src/app.module.ts
index d32c7f1..8308155 100644
--- a/apps/api/src/app.module.ts
+++ b/apps/api/src/app.module.ts
@@ -1,10 +1,10 @@
 import { Module } from '@nestjs/common';
-import { CoreModule } from './core/core.module';
-import { HealthModule } from './health/health.module';
-import { NotificationsModule } from './notifications/notifications.module';
-import { CatalogModule } from './catalog/catalog.module';
-import { AppConfigModule } from './config/config.module';
-import { PrismaModule } from './prisma/prisma.module';
+import { CoreModule } from '@app/core/core.module';
+import { HealthModule } from '@app/health/health.module';
+import { NotificationsModule } from '@app/notifications/notifications.module';
+import { CatalogModule } from '@app/catalog/catalog.module';
+import { AppConfigModule } from '@app/config/config.module';
+import { PrismaModule } from '@app/prisma/prisma.module';
 
 @Module({
   imports: [
diff --git a/apps/api/src/app.service.ts b/apps/api/src/app.service.ts
index d671e91..c8762f0 100644
--- a/apps/api/src/app.service.ts
+++ b/apps/api/src/app.service.ts
@@ -1,8 +1,8 @@
-import { Injectable } from '@nestjs/common';
-
-@Injectable()
-export class AppService {
-  getHello(): string {
-    return 'Hello';
-  }
-}
+import { Injectable } from '@nestjs/common';
+
+@Injectable()
+export class AppService {
+  getHello(): string {
+    return 'Hello';
+  }
+}
diff --git a/apps/api/src/catalog/bookmarks/bookmarks.controller.ts b/apps/api/src/catalog/bookmarks/bookmarks.controller.ts
index 828551e..3fe0282 100644
--- a/apps/api/src/catalog/bookmarks/bookmarks.controller.ts
+++ b/apps/api/src/catalog/bookmarks/bookmarks.controller.ts
@@ -4,9 +4,6 @@ import {
   Delete,
   Get,
   Param,
-  Query,
-  Req,
-  UseGuards,
   HttpCode,
   HttpStatus,
 } from '@nestjs/common';
@@ -17,20 +14,15 @@ import {
   ApiOperation,
   ApiTags,
 } from '@nestjs/swagger';
-import { BookmarksService } from './bookmarks.service';
-import { BookmarkListQueryDto } from './dtos/bookmark-query.dto';
-import { UserBookmarksResultDto } from './dtos/bookmark-response.dto';
-
-// جایگزین با گارد واقعی پروژه‌ات: AuthGuard('jwt')
-class AuthGuardRequired {}
-
-function currentUserId(req: any): string {
-  return req?.user?.sub ?? req?.user?.id;
-}
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { requireUserId } from '@app/catalog/utils/current-user.util';
+import { BookmarksService } from '@app/catalog/bookmarks/bookmarks.service';
 
 @ApiTags('Catalog / Bookmarks')
 @ApiBearerAuth()
-@UseGuards(AuthGuardRequired as any)
 @Controller('catalog/bookmarks')
 export class BookmarksController {
   constructor(private readonly service: BookmarksService) {}
@@ -40,8 +32,11 @@ export class BookmarksController {
   @ApiOkResponse({
     schema: { properties: { bookmarked: { type: 'boolean' } } },
   })
-  async toggle(@Param('productId') productId: string, @Req() req: any) {
-    const userId = currentUserId(req);
+  async toggle(
+    @Param('productId') productId: string,
+    @CurrentUser() user: CurrentUserPayload | undefined,
+  ) {
+    const userId = requireUserId(user);
     return this.service.toggle(userId, productId);
   }
 
@@ -51,9 +46,9 @@ export class BookmarksController {
   @ApiNoContentResponse()
   async remove(
     @Param('productId') productId: string,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<void> {
-    const userId = currentUserId(req);
+    const userId = requireUserId(user);
     await this.service.remove(userId, productId);
   }
 
@@ -62,8 +57,11 @@ export class BookmarksController {
   @ApiOkResponse({
     schema: { properties: { bookmarked: { type: 'boolean' } } },
   })
-  async check(@Param('productId') productId: string, @Req() req: any) {
-    const userId = currentUserId(req);
+  async check(
+    @Param('productId') productId: string,
+    @CurrentUser() user: CurrentUserPayload | undefined,
+  ) {
+    const userId = requireUserId(user);
     return this.service.isBookmarked(userId, productId);
   }
 }
diff --git a/apps/api/src/catalog/bookmarks/bookmarks.service.ts b/apps/api/src/catalog/bookmarks/bookmarks.service.ts
index 3d1add5..8137cde 100644
--- a/apps/api/src/catalog/bookmarks/bookmarks.service.ts
+++ b/apps/api/src/catalog/bookmarks/bookmarks.service.ts
@@ -1,17 +1,17 @@
 import { Injectable, BadRequestException } from '@nestjs/common';
 import { Prisma } from '@prisma/client';
 import { Buffer } from 'buffer';
-import { PrismaService } from '../../prisma/prisma.service';
-import { BookmarkListQueryDto } from './dtos/bookmark-query.dto';
+import { PrismaService } from '@app/prisma/prisma.service';
+import { BookmarkListQueryDto } from '@app/catalog/bookmarks/dtos/bookmark-query.dto';
 import {
   UserBookmarkItemDto,
   UserBookmarksResultDto,
-} from './dtos/bookmark-response.dto';
+} from '@app/catalog/bookmarks/dtos/bookmark-response.dto';
 import {
   ProductMapper,
   productInclude,
   type ProductWithRelations,
-} from '../product/product.mapper';
+} from '@app/catalog/product/product.mapper';
 
 function toBigIntNullable(id?: string): bigint | null {
   if (!id || !/^\d+$/.test(id)) return null;
diff --git a/apps/api/src/catalog/bookmarks/dtos/bookmark-query.dto.ts b/apps/api/src/catalog/bookmarks/dtos/bookmark-query.dto.ts
index ff74846..66c61d5 100644
--- a/apps/api/src/catalog/bookmarks/dtos/bookmark-query.dto.ts
+++ b/apps/api/src/catalog/bookmarks/dtos/bookmark-query.dto.ts
@@ -1,16 +1,16 @@
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import { IsInt, IsOptional, IsString, Max, Min } from 'class-validator';
-
-export class BookmarkListQueryDto {
-  @ApiPropertyOptional({ minimum: 1, maximum: 60, example: 24 })
-  @IsOptional()
-  @IsInt()
-  @Min(1)
-  @Max(60)
-  limit?: number;
-
-  @ApiPropertyOptional({ description: 'cursor opaque (base64)' })
-  @IsOptional()
-  @IsString()
-  cursor?: string;
-}
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import { IsInt, IsOptional, IsString, Max, Min } from 'class-validator';
+
+export class BookmarkListQueryDto {
+  @ApiPropertyOptional({ minimum: 1, maximum: 60, example: 24 })
+  @IsOptional()
+  @IsInt()
+  @Min(1)
+  @Max(60)
+  limit?: number;
+
+  @ApiPropertyOptional({ description: 'cursor opaque (base64)' })
+  @IsOptional()
+  @IsString()
+  cursor?: string;
+}
diff --git a/apps/api/src/catalog/bookmarks/dtos/bookmark-response.dto.ts b/apps/api/src/catalog/bookmarks/dtos/bookmark-response.dto.ts
index ea1326b..e804fb5 100644
--- a/apps/api/src/catalog/bookmarks/dtos/bookmark-response.dto.ts
+++ b/apps/api/src/catalog/bookmarks/dtos/bookmark-response.dto.ts
@@ -1,5 +1,5 @@
 import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import { ProductBriefDto } from '../../product/dtos/product-response.dto';
+import { ProductBriefDto } from '@app/catalog/product/dtos/product-response.dto';
 
 export class UserBookmarkItemDto {
   @ApiProperty() product!: ProductBriefDto;
diff --git a/apps/api/src/catalog/bookmarks/profile-bookmarks.controller.ts b/apps/api/src/catalog/bookmarks/profile-bookmarks.controller.ts
index 889d63a..47e7b55 100644
--- a/apps/api/src/catalog/bookmarks/profile-bookmarks.controller.ts
+++ b/apps/api/src/catalog/bookmarks/profile-bookmarks.controller.ts
@@ -1,24 +1,21 @@
-import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
+import { Controller, Get, Query } from '@nestjs/common';
 import {
   ApiBearerAuth,
   ApiOkResponse,
   ApiOperation,
   ApiTags,
 } from '@nestjs/swagger';
-import { BookmarksService } from './bookmarks.service';
-import { BookmarkListQueryDto } from './dtos/bookmark-query.dto';
-import { UserBookmarksResultDto } from './dtos/bookmark-response.dto';
-
-// جایگزین با گارد واقعی پروژه‌ات: AuthGuard('jwt')
-class AuthGuardRequired {}
-
-function currentUserId(req: any): string {
-  return req?.user?.sub ?? req?.user?.id;
-}
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { requireUserId } from '@app/catalog/utils/current-user.util';
+import { BookmarksService } from '@app/catalog/bookmarks/bookmarks.service';
+import { BookmarkListQueryDto } from '@app/catalog/bookmarks/dtos/bookmark-query.dto';
+import { UserBookmarksResultDto } from '@app/catalog/bookmarks/dtos/bookmark-response.dto';
 
 @ApiTags('Profile / Bookmarks')
 @ApiBearerAuth()
-@UseGuards(AuthGuardRequired as any)
 @Controller('catalog/profile/bookmarks')
 export class ProfileBookmarksController {
   constructor(private readonly service: BookmarksService) {}
@@ -28,9 +25,9 @@ export class ProfileBookmarksController {
   @ApiOkResponse({ type: UserBookmarksResultDto })
   async listMine(
     @Query() q: BookmarkListQueryDto,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<UserBookmarksResultDto> {
-    const userId = currentUserId(req);
+    const userId = requireUserId(user);
     return this.service.listForUser(userId, q);
   }
 }
diff --git a/apps/api/src/catalog/catalog.module.ts b/apps/api/src/catalog/catalog.module.ts
index 5bce110..804a534 100644
--- a/apps/api/src/catalog/catalog.module.ts
+++ b/apps/api/src/catalog/catalog.module.ts
@@ -2,42 +2,45 @@
 import { Module } from '@nestjs/common';
 
 // Product
-import { ProductController } from './product/products.controller';
-import { ProductService } from './product/product.service';
+import { ProductController } from '@app/catalog/product/products.controller';
+import { ProductService } from '@app/catalog/product/product.service';
 
 // Categories
-import { CategoriesController } from './categories/categories.controller';
-import { CategoriesService } from './categories/categories.service';
+import { CategoriesController } from '@app/catalog/categories/categories.controller';
+import { CategoriesService } from '@app/catalog/categories/categories.service';
 
-// Tags
-import { TagsController } from './tags/tags.controller';
-import { TagsService } from './tags/tags.service';
+// Tags & Topics
+import { TagsController } from '@app/catalog/tags/tags.controller';
+import { TagsService } from '@app/catalog/tags/tags.service';
+import { TopicsController } from '@app/catalog/topics/topics.controller';
+import { TopicsService } from '@app/catalog/topics/topics.service';
 
 // Likes
-import { LikesController } from './likes/likes.controller';
-import { ProfileLikesController } from './likes/profile-likes.controller';
-import { LikesService } from './likes/likes.service';
+import { LikesController } from '@app/catalog/likes/likes.controller';
+import { ProfileLikesController } from '@app/catalog/likes/profile-likes.controller';
+import { LikesService } from '@app/catalog/likes/likes.service';
 
 // Bookmarks
-import { BookmarksController } from './bookmarks/bookmarks.controller';
-import { ProfileBookmarksController } from './bookmarks/profile-bookmarks.controller';
-import { BookmarksService } from './bookmarks/bookmarks.service';
+import { BookmarksController } from '@app/catalog/bookmarks/bookmarks.controller';
+import { ProfileBookmarksController } from '@app/catalog/bookmarks/profile-bookmarks.controller';
+import { BookmarksService } from '@app/catalog/bookmarks/bookmarks.service';
 
 // Downloads
-import { DownloadsController } from './downloads/downloads.controller';
-import { ProfileDownloadsController } from './downloads/profile-downloads.controller';
-import { DownloadsService } from './downloads/downloads.service';
+import { DownloadsController } from '@app/catalog/downloads/downloads.controller';
+import { ProfileDownloadsController } from '@app/catalog/downloads/profile-downloads.controller';
+import { DownloadsService } from '@app/catalog/downloads/downloads.service';
 
 // Guards / Counters
-import { SupplierOwnershipGuard } from './guards/supplier-ownership.guard';
-import { CountersService } from './counters/counters.service';
+import { SupplierOwnershipGuard } from '@app/catalog/guards/supplier-ownership.guard';
+import { CountersService } from '@app/catalog/counters/counters.service';
 
 // Storage (فعلاً داخل همین ماژول؛ اگر به core بردی، StorageModule رو import کن)
-import { StorageService } from './storage/storage.service';
-import { LocalStorageService } from './storage/local-storage.service';
+import { StorageService } from '@app/catalog/storage/storage.service';
+import { LocalStorageService } from '@app/catalog/storage/local-storage.service';
 
-// Prisma
-import { PrismaService } from '../prisma/prisma.service'; // مسیر را با ساختار پروژه‌ات هماهنگ کن
+// Comments
+import { CommentsController } from '@app/catalog/comments/comments.controller';
+import { CommentsService } from '@app/catalog/comments/comments.service';
 
 @Module({
   imports: [
@@ -50,23 +53,26 @@ import { PrismaService } from '../prisma/prisma.service'; // مسیر را با
     ProductController,
     CategoriesController,
     TagsController,
+    TopicsController,
     LikesController,
     ProfileLikesController,
     BookmarksController,
     ProfileBookmarksController,
     DownloadsController,
     ProfileDownloadsController,
+    CommentsController,
   ],
   providers: [
-    PrismaService, // اگر PrismaModule نداری، اینجا لازم است
     ProductService,
     CategoriesService,
     TagsService,
+    TopicsService,
     LikesService,
     BookmarksService,
     DownloadsService,
     SupplierOwnershipGuard,
     CountersService,
+    CommentsService,
     // اگر Storage به core نرفته:
     { provide: StorageService, useClass: LocalStorageService },
   ],
@@ -75,9 +81,11 @@ import { PrismaService } from '../prisma/prisma.service'; // مسیر را با
     ProductService,
     CategoriesService,
     TagsService,
+    TopicsService,
     LikesService,
     BookmarksService,
     DownloadsService,
+    CommentsService,
     CountersService,
     StorageService, // اگر اینجا بایند کردی
   ],
diff --git a/apps/api/src/catalog/categories/categories.controller.ts b/apps/api/src/catalog/categories/categories.controller.ts
index 957dc01..2aaf680 100644
--- a/apps/api/src/catalog/categories/categories.controller.ts
+++ b/apps/api/src/catalog/categories/categories.controller.ts
@@ -9,6 +9,7 @@ import {
   Query,
   HttpCode,
   HttpStatus,
+  Res,
 } from '@nestjs/common';
 import {
   ApiTags,
@@ -16,18 +17,28 @@ import {
   ApiOkResponse,
   ApiCreatedResponse,
   ApiNoContentResponse,
+  ApiBearerAuth,
+  ApiParam,
+  ApiResponse,
 } from '@nestjs/swagger';
+import { Response } from 'express';
+import { RoleName } from '@prisma/client';
+import { Roles } from '@app/common/decorators/roles.decorator';
+import {
+  normalizeFaText,
+  safeDecodeSlug,
+} from '@shared-slug/slug/fa-slug.util';
 
-import { CategoriesService } from './categories.service';
-import { CreateCategoryDto } from './dtos/category-create.dto';
-import { UpdateCategoryDto } from './dtos/category-update.dto';
-import { CategoryFindQueryDto } from './dtos/category-query.dto';
+import { CategoriesService } from '@app/catalog/categories/categories.service';
+import { CreateCategoryDto } from '@app/catalog/categories/dtos/category-create.dto';
+import { UpdateCategoryDto } from '@app/catalog/categories/dtos/category-update.dto';
+import { CategoryFindQueryDto } from '@app/catalog/categories/dtos/category-query.dto';
 import {
   CategoryDto,
   CategoryListResultDto,
   CategoryTreeNodeDto,
   CategoryBreadcrumbDto,
-} from './dtos/category-response.dto';
+} from '@app/catalog/categories/dtos/category-response.dto';
 
 @ApiTags('Catalog / Categories')
 @Controller('catalog/categories')
@@ -35,6 +46,8 @@ export class CategoriesController {
   constructor(private readonly service: CategoriesService) {}
 
   @Post()
+  @ApiBearerAuth()
+  @Roles(RoleName.admin)
   @ApiOperation({ summary: 'Create a category' })
   @ApiCreatedResponse({ type: CategoryDto })
   async create(@Body() dto: CreateCategoryDto): Promise<CategoryDto> {
@@ -42,6 +55,8 @@ export class CategoriesController {
   }
 
   @Patch(':id')
+  @ApiBearerAuth()
+  @Roles(RoleName.admin)
   @ApiOperation({ summary: 'Update a category' })
   @ApiOkResponse({ type: CategoryDto })
   async update(
@@ -51,11 +66,12 @@ export class CategoriesController {
     return this.service.update(id, dto);
   }
 
-  @Get(':idOrSlug')
-  @ApiOperation({ summary: 'Find category by id or slug' })
+  @Get('id/:id')
+  @ApiOperation({ summary: 'Find category by numeric id' })
   @ApiOkResponse({ type: CategoryDto })
-  async findOne(@Param('idOrSlug') idOrSlug: string): Promise<CategoryDto> {
-    return this.service.findOne(idOrSlug);
+  @ApiParam({ name: 'id', example: '42', description: 'Category id' })
+  async findById(@Param('id') id: string): Promise<CategoryDto> {
+    return this.service.findById(id);
   }
 
   @Get()
@@ -88,7 +104,41 @@ export class CategoriesController {
     return this.service.breadcrumbs(id);
   }
 
+  @Get(':slug')
+  @ApiOperation({
+    summary: 'Find category by slug (supports Persian characters)',
+    description:
+      'Automatically decodes/normalizes the slug and issues a 301 redirect when the slug has changed.',
+  })
+  @ApiOkResponse({ type: CategoryDto })
+  @ApiResponse({
+    status: 301,
+    description: 'Redirect to the canonical slug when obsolete slug is used',
+  })
+  @ApiParam({
+    name: 'slug',
+    example: 'نقاشی-و-تصویرسازی',
+    description: 'Canonical Persian slug',
+  })
+  async findBySlug(
+    @Param('slug') slugParam: string,
+    @Res({ passthrough: true }) res: Response,
+  ): Promise<CategoryDto | undefined> {
+    const normalizedSlug = normalizeFaText(safeDecodeSlug(slugParam));
+    const result = await this.service.findBySlug(normalizedSlug);
+    if (result.redirectTo) {
+      res.redirect(
+        HttpStatus.MOVED_PERMANENTLY,
+        `/catalog/categories/${encodeURIComponent(result.redirectTo)}`,
+      );
+      return undefined;
+    }
+    return result.category;
+  }
+
   @Delete(':id')
+  @ApiBearerAuth()
+  @Roles(RoleName.admin)
   @ApiOperation({ summary: 'Delete a category (relink children to parent)' })
   @HttpCode(HttpStatus.NO_CONTENT)
   @ApiNoContentResponse()
diff --git a/apps/api/src/catalog/categories/categories.service.ts b/apps/api/src/catalog/categories/categories.service.ts
index ca3d7bc..72278cd 100644
--- a/apps/api/src/catalog/categories/categories.service.ts
+++ b/apps/api/src/catalog/categories/categories.service.ts
@@ -4,23 +4,31 @@ import {
   NotFoundException,
 } from '@nestjs/common';
 import { Prisma } from '@prisma/client';
-import { PrismaService } from '../../prisma/prisma.service';
-import { CreateCategoryDto } from './dtos/category-create.dto';
-import { UpdateCategoryDto } from './dtos/category-update.dto';
-import { CategoryFindQueryDto } from './dtos/category-query.dto';
+import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
+import { PrismaService } from '@app/prisma/prisma.service';
+import {
+  clampFaSlug,
+  makeFaSlug,
+  normalizeFaText,
+} from '@shared-slug/slug/fa-slug.util';
+import { CreateCategoryDto } from '@app/catalog/categories/dtos/category-create.dto';
+import { UpdateCategoryDto } from '@app/catalog/categories/dtos/category-update.dto';
+import { CategoryFindQueryDto } from '@app/catalog/categories/dtos/category-query.dto';
 import {
   CategoryBreadcrumbDto,
   CategoryDto,
   CategoryListResultDto,
   CategoryTreeNodeDto,
-} from './dtos/category-response.dto';
-import { CategoryEntity, CategoryMapper } from './category.mapper';
+} from '@app/catalog/categories/dtos/category-response.dto';
+import { CategoryEntity, CategoryMapper } from '@app/catalog/categories/category.mapper';
 
 function toBigIntNullable(id?: string): bigint | null {
   if (!id || !/^\d+$/.test(id)) return null;
   return BigInt(id);
 }
 
+const CATEGORY_ENTITY_TYPE = 'category' as const;
+
 @Injectable()
 export class CategoriesService {
   constructor(private readonly prisma: PrismaService) {}
@@ -28,11 +36,14 @@ export class CategoriesService {
   /* ---------------- Create ---------------- */
   async create(dto: CreateCategoryDto): Promise<CategoryDto> {
     const parentId = toBigIntNullable(dto.parentId);
+    const name = normalizeFaText(dto.name);
+    const slug = await this.ensureUniqueSlug(dto.slug ?? dto.name);
     const created = await this.prisma.category.create({
       data: {
-        name: dto.name,
-        slug: dto.slug,
+        name,
+        slug,
         parentId: parentId ?? null,
+        coverUrl: dto.coverUrl ?? null,
       },
     });
     return CategoryMapper.toDto(created);
@@ -43,10 +54,28 @@ export class CategoriesService {
     const id = toBigIntNullable(idStr);
     if (!id) throw new BadRequestException('Invalid category id');
 
+    const existing = await this.prisma.category.findUnique({
+      where: { id },
+    });
+    if (!existing) throw new NotFoundException('Category not found');
+
+    const nextName =
+      dto.name !== undefined ? normalizeFaText(dto.name) : undefined;
+    const slugSource =
+      dto.slug !== undefined
+        ? dto.slug
+        : dto.name !== undefined
+          ? dto.name
+          : undefined;
+    const nextSlug = slugSource
+      ? await this.ensureUniqueSlug(slugSource, id)
+      : undefined;
+
     // parentId رفتار: undefined = دست نزن | '' یا null = detach | مقدار = connect
     const data: Prisma.CategoryUpdateInput = {
-      name: dto.name ?? undefined,
-      slug: dto.slug ?? undefined,
+      name: nextName ?? undefined,
+      slug: nextSlug ?? undefined,
+      coverUrl: dto.coverUrl ?? undefined,
       ...(dto.parentId === undefined
         ? {}
         : dto.parentId && /^\d+$/.test(dto.parentId)
@@ -54,21 +83,47 @@ export class CategoriesService {
           : { parent: { disconnect: true } }),
     };
 
-    const updated = await this.prisma.category.update({
-      where: { id },
-      data,
+    const updated = await this.prisma.$transaction(async (trx) => {
+      const result = await trx.category.update({
+        where: { id },
+        data,
+      });
+      if (nextSlug && nextSlug !== existing.slug) {
+        await this.createSlugRedirect(trx, id, existing.slug, nextSlug);
+      }
+      return result;
     });
     return CategoryMapper.toDto(updated);
   }
 
   /* ---------------- Find One ---------------- */
-  async findOne(idOrSlug: string): Promise<CategoryDto> {
-    const where = /^\d+$/.test(idOrSlug)
-      ? { id: BigInt(idOrSlug) }
-      : { slug: idOrSlug };
-    const c = await this.prisma.category.findFirst({ where });
-    if (!c) throw new NotFoundException('Category not found');
-    return CategoryMapper.toDto(c);
+  async findById(idStr: string): Promise<CategoryDto> {
+    const id = toBigIntNullable(idStr);
+    if (!id) {
+      throw new BadRequestException('Invalid category id');
+    }
+    const category = await this.prisma.category.findUnique({ where: { id } });
+    if (!category) throw new NotFoundException('Category not found');
+    return CategoryMapper.toDto(category);
+  }
+
+  async findBySlug(
+    slug: string,
+  ): Promise<{ category?: CategoryDto; redirectTo?: string }> {
+    const direct = await this.prisma.category.findUnique({
+      where: { slug },
+    });
+    if (direct) {
+      return { category: CategoryMapper.toDto(direct) };
+    }
+    const redirect = await this.prisma.slugRedirect.findUnique({
+      where: { fromSlug: slug },
+      select: { entityType: true, toSlug: true },
+    });
+    if (redirect?.entityType === CATEGORY_ENTITY_TYPE) {
+      return { redirectTo: redirect.toSlug };
+    }
+    throw new NotFoundException('Category not found');
   }
 
   /* ---------------- List (flat) ---------------- */
@@ -77,7 +132,7 @@ export class CategoriesService {
     const ands: Prisma.CategoryWhereInput[] = [];
 
     if (q.q?.trim()) {
-      const term = q.q.trim();
+      const term = normalizeFaText(q.q.trim());
       ands.push({
         OR: [
           { name: { contains: term, mode: 'insensitive' } },
@@ -168,8 +223,67 @@ export class CategoriesService {
 
       // لینک‌های محصول را حذف کن (در صورت نیاز می‌تونی به دسته‌ی والد منتقل کنی)
       await trx.productCategory.deleteMany({ where: { categoryId: id } });
+      await trx.slugRedirect.deleteMany({
+        where: {
+          entityType: CATEGORY_ENTITY_TYPE,
+          entityId: id.toString(),
+        },
+      });
 
       await trx.category.delete({ where: { id } });
     });
   }
+
+  private async ensureUniqueSlug(
+    source: string,
+    ignoreId?: bigint,
+  ): Promise<string> {
+    const base = makeFaSlug(source);
+    if (!base) {
+      throw new BadRequestException('Slug cannot be resolved from name.');
+    }
+    for (let attempt = 0; attempt < 20; attempt += 1) {
+      const candidate =
+        attempt === 0 ? base : clampFaSlug(`${base}-${attempt + 1}`);
+      const existing = await this.prisma.category.findUnique({
+        where: { slug: candidate },
+        select: { id: true },
+      });
+      if (!existing || (ignoreId && existing.id === ignoreId)) {
+        return candidate;
+      }
+    }
+    return clampFaSlug(`${base}-${Date.now()}`);
+  }
+
+  private async createSlugRedirect(
+    trx: Prisma.TransactionClient,
+    entityId: bigint,
+    fromSlug: string,
+    toSlug: string,
+  ): Promise<void> {
+    if (fromSlug === toSlug) {
+      return;
+    }
+    try {
+      await trx.slugRedirect.create({
+        data: {
+          entityType: CATEGORY_ENTITY_TYPE,
+          entityId: entityId.toString(),
+          fromSlug,
+          toSlug,
+        },
+      });
+    } catch (error) {
+      if (
+        error instanceof PrismaClientKnownRequestError &&
+        error.code === 'P2002'
+      ) {
+        throw new BadRequestException(
+          `A redirect already exists for slug "${fromSlug}"`,
+        );
+      }
+      throw error;
+    }
+  }
 }
diff --git a/apps/api/src/catalog/categories/category.mapper.ts b/apps/api/src/catalog/categories/category.mapper.ts
index b02d494..c22c2b1 100644
--- a/apps/api/src/catalog/categories/category.mapper.ts
+++ b/apps/api/src/catalog/categories/category.mapper.ts
@@ -1,5 +1,5 @@
 import { Prisma } from '@prisma/client';
-import { CategoryDto, CategoryTreeNodeDto } from './dtos/category-response.dto';
+import { CategoryDto, CategoryTreeNodeDto } from '@app/catalog/categories/dtos/category-response.dto';
 
 export type CategoryEntity = Prisma.CategoryGetPayload<{}>;
 
@@ -10,6 +10,7 @@ export class CategoryMapper {
       name: c.name,
       slug: c.slug,
       parentId: c.parentId ? String(c.parentId) : null,
+      coverUrl: c.coverUrl ?? undefined,
     };
   }
 
diff --git a/apps/api/src/catalog/categories/dtos/category-create.dto.ts b/apps/api/src/catalog/categories/dtos/category-create.dto.ts
index df9e01c..de6a18b 100644
--- a/apps/api/src/catalog/categories/dtos/category-create.dto.ts
+++ b/apps/api/src/catalog/categories/dtos/category-create.dto.ts
@@ -1,22 +1,43 @@
 import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import { IsOptional, IsString, Length } from 'class-validator';
+import { Transform } from 'class-transformer';
+import {
+  IsOptional,
+  IsString,
+  IsUrl,
+  Length,
+  Matches,
+  MaxLength,
+} from 'class-validator';
+import { toTrimmedString } from '@app/catalog/product/dtos/transformers';
+import { FA_SLUG_REGEX } from '@shared-slug/slug/fa-slug.util';
 
 export class CreateCategoryDto {
   @ApiProperty({ example: 'وکتور' })
   @IsString()
   @Length(2, 255)
+  @Transform(toTrimmedString)
   name!: string;
 
-  @ApiProperty({ example: 'vector' })
+  @ApiPropertyOptional({ example: 'نقاشی-و-تصویرسازی' })
+  @IsOptional()
   @IsString()
-  @Length(2, 255)
-  slug!: string;
+  @MaxLength(200)
+  @Matches(FA_SLUG_REGEX, { message: 'Invalid slug format' })
+  @Transform(toTrimmedString)
+  slug?: string;
 
   @ApiPropertyOptional({
-    description: 'Parent ID (BigInt as string)',
-    example: '123',
+    example: 'https://cdn.negare.test/categories/vector.png',
   })
   @IsOptional()
-  @IsString()
-  parentId?: string; // BigInt string
-}
+  @IsUrl()
+  coverUrl?: string;
+
+  @ApiPropertyOptional({
+    description: 'Parent ID (BigInt as string)',
+    example: '123',
+  })
+  @IsOptional()
+  @IsString()
+  parentId?: string; // BigInt string
+}
diff --git a/apps/api/src/catalog/categories/dtos/category-query.dto.ts b/apps/api/src/catalog/categories/dtos/category-query.dto.ts
index fcf7c19..2981be5 100644
--- a/apps/api/src/catalog/categories/dtos/category-query.dto.ts
+++ b/apps/api/src/catalog/categories/dtos/category-query.dto.ts
@@ -1,22 +1,22 @@
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import { IsInt, IsOptional, IsString, Length, Max, Min } from 'class-validator';
-
-export class CategoryFindQueryDto {
-  @ApiPropertyOptional({ example: 'vector' })
-  @IsOptional()
-  @IsString()
-  @Length(1, 255)
-  q?: string;
-
-  @ApiPropertyOptional({ example: '0' })
-  @IsOptional()
-  @IsString()
-  parentId?: string; // BigInt string
-
-  @ApiPropertyOptional({ minimum: 1, maximum: 200, example: 100 })
-  @IsOptional()
-  @IsInt()
-  @Min(1)
-  @Max(200)
-  limit?: number;
-}
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import { IsInt, IsOptional, IsString, Length, Max, Min } from 'class-validator';
+
+export class CategoryFindQueryDto {
+  @ApiPropertyOptional({ example: 'vector' })
+  @IsOptional()
+  @IsString()
+  @Length(1, 255)
+  q?: string;
+
+  @ApiPropertyOptional({ example: '0' })
+  @IsOptional()
+  @IsString()
+  parentId?: string; // BigInt string
+
+  @ApiPropertyOptional({ minimum: 1, maximum: 200, example: 100 })
+  @IsOptional()
+  @IsInt()
+  @Min(1)
+  @Max(200)
+  limit?: number;
+}
diff --git a/apps/api/src/catalog/categories/dtos/category-response.dto.ts b/apps/api/src/catalog/categories/dtos/category-response.dto.ts
index 9e96b94..9ce72c8 100644
--- a/apps/api/src/catalog/categories/dtos/category-response.dto.ts
+++ b/apps/api/src/catalog/categories/dtos/category-response.dto.ts
@@ -1,21 +1,22 @@
-import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-
+import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
+
 export class CategoryDto {
   @ApiProperty() id!: string; // BigInt → string
   @ApiProperty() name!: string;
   @ApiProperty() slug!: string;
   @ApiPropertyOptional() parentId?: string | null;
+  @ApiPropertyOptional() coverUrl?: string | null;
 }
-
-export class CategoryTreeNodeDto extends CategoryDto {
-  @ApiProperty({ type: () => [CategoryTreeNodeDto] })
-  children!: CategoryTreeNodeDto[];
-}
-
-export class CategoryListResultDto {
-  @ApiProperty({ type: [CategoryDto] }) items!: CategoryDto[];
-}
-
-export class CategoryBreadcrumbDto {
-  @ApiProperty({ type: [CategoryDto] }) path!: CategoryDto[]; // root..self
-}
+
+export class CategoryTreeNodeDto extends CategoryDto {
+  @ApiProperty({ type: () => [CategoryTreeNodeDto] })
+  children!: CategoryTreeNodeDto[];
+}
+
+export class CategoryListResultDto {
+  @ApiProperty({ type: [CategoryDto] }) items!: CategoryDto[];
+}
+
+export class CategoryBreadcrumbDto {
+  @ApiProperty({ type: [CategoryDto] }) path!: CategoryDto[]; // root..self
+}
diff --git a/apps/api/src/catalog/categories/dtos/category-update.dto.ts b/apps/api/src/catalog/categories/dtos/category-update.dto.ts
index 914abb5..3ec244f 100644
--- a/apps/api/src/catalog/categories/dtos/category-update.dto.ts
+++ b/apps/api/src/catalog/categories/dtos/category-update.dto.ts
@@ -1,23 +1,41 @@
 import { ApiPropertyOptional } from '@nestjs/swagger';
-import { IsOptional, IsString, Length } from 'class-validator';
+import { Transform } from 'class-transformer';
+import {
+  IsOptional,
+  IsString,
+  IsUrl,
+  Length,
+  Matches,
+  MaxLength,
+} from 'class-validator';
+import { toTrimmedString } from '@app/catalog/product/dtos/transformers';
+import { FA_SLUG_REGEX } from '@shared-slug/slug/fa-slug.util';
 
 export class UpdateCategoryDto {
   @ApiPropertyOptional()
   @IsOptional()
   @IsString()
   @Length(2, 255)
+  @Transform(toTrimmedString)
   name?: string;
 
   @ApiPropertyOptional()
   @IsOptional()
   @IsString()
-  @Length(2, 255)
+  @MaxLength(200)
+  @Matches(FA_SLUG_REGEX, { message: 'Invalid slug format' })
+  @Transform(toTrimmedString)
   slug?: string;
-
+
   @ApiPropertyOptional({
     description: 'Parent ID (BigInt as string) or empty to detach',
   })
   @IsOptional()
   @IsString()
   parentId?: string;
+
+  @ApiPropertyOptional({ description: 'Cover image URL' })
+  @IsOptional()
+  @IsUrl()
+  coverUrl?: string;
 }
diff --git a/apps/api/src/catalog/counters/counters.service.ts b/apps/api/src/catalog/counters/counters.service.ts
index cfa6aa0..40bb7bf 100644
--- a/apps/api/src/catalog/counters/counters.service.ts
+++ b/apps/api/src/catalog/counters/counters.service.ts
@@ -2,7 +2,7 @@
 import { Injectable, Logger } from '@nestjs/common';
 import type { Prisma } from '@prisma/client';
 import IORedis, { Redis } from 'ioredis';
-import { PrismaService } from '../../prisma/prisma.service';
+import { PrismaService } from '@app/prisma/prisma.service';
 
 type CounterKind = 'views' | 'downloads' | 'likes';
 
diff --git a/apps/api/src/catalog/downloads/downloads.controller.ts b/apps/api/src/catalog/downloads/downloads.controller.ts
index 6cc4c9e..4e4f351 100644
--- a/apps/api/src/catalog/downloads/downloads.controller.ts
+++ b/apps/api/src/catalog/downloads/downloads.controller.ts
@@ -1,23 +1,21 @@
-import { Controller, Post, Param, Body, Req, UseGuards } from '@nestjs/common';
+import { Body, Controller, Param, Post } from '@nestjs/common';
 import {
   ApiBearerAuth,
   ApiOkResponse,
   ApiOperation,
   ApiTags,
 } from '@nestjs/swagger';
-import { DownloadsService } from './downloads.service';
-import { DownloadStartDto } from './dtos/download-start.dto';
-import { DownloadCreatedDto } from './dtos/download-response.dto';
-
-// جایگزین با گارد واقعی‌ات: AuthGuard('jwt')
-class AuthGuardRequired {}
-function currentUserId(req: any): string {
-  return req?.user?.sub ?? req?.user?.id;
-}
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { requireUserId } from '@app/catalog/utils/current-user.util';
+import { DownloadsService } from '@app/catalog/downloads/downloads.service';
+import { DownloadStartDto } from '@app/catalog/downloads/dtos/download-start.dto';
+import { DownloadCreatedDto } from '@app/catalog/downloads/dtos/download-response.dto';
 
 @ApiTags('Catalog / Downloads')
 @ApiBearerAuth()
-@UseGuards(AuthGuardRequired as any)
 @Controller('catalog/downloads')
 export class DownloadsController {
   constructor(private readonly service: DownloadsService) {}
@@ -30,9 +28,9 @@ export class DownloadsController {
   async start(
     @Param('productId') productId: string,
     @Body() dto: DownloadStartDto,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<DownloadCreatedDto> {
-    const userId = currentUserId(req);
+    const userId = requireUserId(user);
     return this.service.start(userId, productId, dto);
   }
 }
diff --git a/apps/api/src/catalog/downloads/downloads.service.ts b/apps/api/src/catalog/downloads/downloads.service.ts
index ad74fb2..41a9ebf 100644
--- a/apps/api/src/catalog/downloads/downloads.service.ts
+++ b/apps/api/src/catalog/downloads/downloads.service.ts
@@ -5,20 +5,20 @@ import {
 } from '@nestjs/common';
 import { Prisma } from '@prisma/client';
 import { Buffer } from 'buffer';
-import { PrismaService } from '../../prisma/prisma.service';
-import { CountersService } from '../counters/counters.service';
-import { DownloadStartDto } from './dtos/download-start.dto';
+import { PrismaService } from '@app/prisma/prisma.service';
+import { CountersService } from '@app/catalog/counters/counters.service';
+import { DownloadStartDto } from '@app/catalog/downloads/dtos/download-start.dto';
 import {
   DownloadCreatedDto,
   UserDownloadItemDto,
   UserDownloadsResultDto,
-} from './dtos/download-response.dto';
+} from '@app/catalog/downloads/dtos/download-response.dto';
 import {
   ProductMapper,
   productInclude,
   type ProductWithRelations,
-} from '../product/product.mapper';
-import { StorageService } from '../storage/storage.service';
+} from '@app/catalog/product/product.mapper';
+import { StorageService } from '@app/catalog/storage/storage.service';
 
 function encodeCursor(obj: Record<string, string | number>) {
   return Buffer.from(JSON.stringify(obj), 'utf8').toString('base64url');
diff --git a/apps/api/src/catalog/downloads/dtos/download-response.dto.ts b/apps/api/src/catalog/downloads/dtos/download-response.dto.ts
index 6263547..b6ed9e8 100644
--- a/apps/api/src/catalog/downloads/dtos/download-response.dto.ts
+++ b/apps/api/src/catalog/downloads/dtos/download-response.dto.ts
@@ -1,5 +1,5 @@
 import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import { ProductBriefDto } from '../../product/dtos/product-response.dto';
+import { ProductBriefDto } from '@app/catalog/product/dtos/product-response.dto';
 
 export class DownloadCreatedDto {
   @ApiPropertyOptional({
diff --git a/apps/api/src/catalog/downloads/dtos/download-start.dto.ts b/apps/api/src/catalog/downloads/dtos/download-start.dto.ts
index 28b5e15..7a209d7 100644
--- a/apps/api/src/catalog/downloads/dtos/download-start.dto.ts
+++ b/apps/api/src/catalog/downloads/dtos/download-start.dto.ts
@@ -1,20 +1,20 @@
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import { IsNumber, IsOptional } from 'class-validator';
-
-export class DownloadStartDto {
-  @ApiPropertyOptional({
-    description: 'File size in bytes (optional)',
-    example: 123456,
-  })
-  @IsOptional()
-  @IsNumber()
-  bytes?: number;
-
-  @ApiPropertyOptional({
-    description: 'Amount paid for this download (if any)',
-    example: 0,
-  })
-  @IsOptional()
-  @IsNumber()
-  pricePaid?: number;
-}
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import { IsNumber, IsOptional } from 'class-validator';
+
+export class DownloadStartDto {
+  @ApiPropertyOptional({
+    description: 'File size in bytes (optional)',
+    example: 123456,
+  })
+  @IsOptional()
+  @IsNumber()
+  bytes?: number;
+
+  @ApiPropertyOptional({
+    description: 'Amount paid for this download (if any)',
+    example: 0,
+  })
+  @IsOptional()
+  @IsNumber()
+  pricePaid?: number;
+}
diff --git a/apps/api/src/catalog/downloads/profile-downloads.controller.ts b/apps/api/src/catalog/downloads/profile-downloads.controller.ts
index 399a04e..11ae907 100644
--- a/apps/api/src/catalog/downloads/profile-downloads.controller.ts
+++ b/apps/api/src/catalog/downloads/profile-downloads.controller.ts
@@ -1,22 +1,20 @@
-import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
+import { Controller, Get, Query } from '@nestjs/common';
 import {
   ApiBearerAuth,
   ApiOkResponse,
   ApiOperation,
   ApiTags,
 } from '@nestjs/swagger';
-import { DownloadsService } from './downloads.service';
-import { UserDownloadsResultDto } from './dtos/download-response.dto';
-
-// جایگزین با گارد واقعی‌ات: AuthGuard('jwt')
-class AuthGuardRequired {}
-function currentUserId(req: any): string {
-  return req?.user?.sub ?? req?.user?.id;
-}
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { requireUserId } from '@app/catalog/utils/current-user.util';
+import { DownloadsService } from '@app/catalog/downloads/downloads.service';
+import { UserDownloadsResultDto } from '@app/catalog/downloads/dtos/download-response.dto';
 
 @ApiTags('Profile / Downloads')
 @ApiBearerAuth()
-@UseGuards(AuthGuardRequired as any)
 @Controller('catalog/profile/downloads')
 export class ProfileDownloadsController {
   constructor(private readonly service: DownloadsService) {}
@@ -25,11 +23,11 @@ export class ProfileDownloadsController {
   @ApiOperation({ summary: 'List current user downloads (Load more)' })
   @ApiOkResponse({ type: UserDownloadsResultDto })
   async listMine(
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
     @Query('limit') limit = '24',
     @Query('cursor') cursor?: string,
   ): Promise<UserDownloadsResultDto> {
-    const userId = currentUserId(req);
+    const userId = requireUserId(user);
     return this.service.listForUser(userId, Number(limit), cursor);
   }
 }
diff --git a/apps/api/src/catalog/guards/supplier-ownership.guard.ts b/apps/api/src/catalog/guards/supplier-ownership.guard.ts
index 6a8c447..f9ee90e 100644
--- a/apps/api/src/catalog/guards/supplier-ownership.guard.ts
+++ b/apps/api/src/catalog/guards/supplier-ownership.guard.ts
@@ -8,7 +8,7 @@ import {
 import { Request } from 'express';
 import { PrismaService } from '@app/prisma/prisma.service';
 import { CurrentUserPayload } from '@app/common/decorators/current-user.decorator';
-import { isAdmin, isSupplier } from '../policies/catalog.policies';
+import { isAdmin, isSupplier } from '@app/catalog/policies/catalog.policies';
 
 @Injectable()
 export class SupplierOwnershipGuard implements CanActivate {
diff --git a/apps/api/src/catalog/likes/dtos/like-toggle.dto.ts b/apps/api/src/catalog/likes/dtos/like-toggle.dto.ts
index 10abab7..3304367 100644
--- a/apps/api/src/catalog/likes/dtos/like-toggle.dto.ts
+++ b/apps/api/src/catalog/likes/dtos/like-toggle.dto.ts
@@ -1,6 +1,6 @@
-import { ApiProperty } from '@nestjs/swagger';
-
-export class LikeToggleResponseDto {
-  @ApiProperty({ example: true })
-  liked!: boolean;
-}
+import { ApiProperty } from '@nestjs/swagger';
+
+export class LikeToggleResponseDto {
+  @ApiProperty({ example: true })
+  liked!: boolean;
+}
diff --git a/apps/api/src/catalog/likes/dtos/likes-response.dto.ts b/apps/api/src/catalog/likes/dtos/likes-response.dto.ts
index ebf5533..03220d2 100644
--- a/apps/api/src/catalog/likes/dtos/likes-response.dto.ts
+++ b/apps/api/src/catalog/likes/dtos/likes-response.dto.ts
@@ -1,5 +1,5 @@
 import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import { ProductBriefDto } from '../../product/dtos/product-response.dto';
+import { ProductBriefDto } from '@app/catalog/product/dtos/product-response.dto';
 
 export class UserLikeItemDto {
   @ApiProperty() product!: ProductBriefDto;
diff --git a/apps/api/src/catalog/likes/likes.controller.ts b/apps/api/src/catalog/likes/likes.controller.ts
index cb1b01a..c143fc3 100644
--- a/apps/api/src/catalog/likes/likes.controller.ts
+++ b/apps/api/src/catalog/likes/likes.controller.ts
@@ -1,22 +1,20 @@
-import { Controller, Post, Param, Req, UseGuards } from '@nestjs/common';
+import { Controller, Post, Param } from '@nestjs/common';
 import {
   ApiBearerAuth,
   ApiOkResponse,
   ApiOperation,
   ApiTags,
 } from '@nestjs/swagger';
-import { LikesService } from './likes.service';
-import { LikeToggleResponseDto } from './dtos/like-toggle.dto';
-
-// جایگزین با گارد واقعی‌ات مثلاً AuthGuard('jwt')
-class AuthGuardRequired {}
-function currentUserId(req: any): string {
-  return req?.user?.sub ?? req?.user?.id;
-}
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { requireUserId } from '@app/catalog/utils/current-user.util';
+import { LikesService } from '@app/catalog/likes/likes.service';
+import { LikeToggleResponseDto } from '@app/catalog/likes/dtos/like-toggle.dto';
 
 @ApiTags('Catalog / Likes')
 @ApiBearerAuth()
-@UseGuards(AuthGuardRequired as any)
 @Controller('catalog/likes')
 export class LikesController {
   constructor(private readonly service: LikesService) {}
@@ -26,9 +24,9 @@ export class LikesController {
   @ApiOkResponse({ type: LikeToggleResponseDto })
   async toggle(
     @Param('productId') productId: string,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<LikeToggleResponseDto> {
-    const userId = currentUserId(req);
+    const userId = requireUserId(user);
     return this.service.toggle(userId, productId);
   }
 }
diff --git a/apps/api/src/catalog/likes/likes.service.ts b/apps/api/src/catalog/likes/likes.service.ts
index 5aecaf8..1887eff 100644
--- a/apps/api/src/catalog/likes/likes.service.ts
+++ b/apps/api/src/catalog/likes/likes.service.ts
@@ -1,15 +1,15 @@
 // apps/api/src/core/catalog/likes/likes.service.ts
 import { Injectable, BadRequestException } from '@nestjs/common';
-import { PrismaService } from '../../prisma/prisma.service';
+import { PrismaService } from '@app/prisma/prisma.service';
 import {
   ProductMapper,
   productInclude,
   type ProductWithRelations,
-} from '../product/product.mapper';
+} from '@app/catalog/product/product.mapper';
 import { Prisma } from '@prisma/client';
 import { Buffer } from 'buffer';
-import { LikeToggleResponseDto } from './dtos/like-toggle.dto';
-import { UserLikeItemDto, UserLikesResultDto } from './dtos/likes-response.dto';
+import { LikeToggleResponseDto } from '@app/catalog/likes/dtos/like-toggle.dto';
+import { UserLikeItemDto, UserLikesResultDto } from '@app/catalog/likes/dtos/likes-response.dto';
 
 /* ---------------- Helpers ---------------- */
 function encodeCursor(obj: Record<string, string | number>) {
diff --git a/apps/api/src/catalog/likes/profile-likes.controller.ts b/apps/api/src/catalog/likes/profile-likes.controller.ts
index d6109c8..00357c0 100644
--- a/apps/api/src/catalog/likes/profile-likes.controller.ts
+++ b/apps/api/src/catalog/likes/profile-likes.controller.ts
@@ -1,22 +1,20 @@
-import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
+import { Controller, Get, Query } from '@nestjs/common';
 import {
   ApiBearerAuth,
   ApiOkResponse,
   ApiOperation,
   ApiTags,
 } from '@nestjs/swagger';
-import { LikesService } from './likes.service';
-import { UserLikesResultDto } from './dtos/likes-response.dto';
-
-// جایگزین با گارد واقعی‌ات مثلاً AuthGuard('jwt')
-class AuthGuardRequired {}
-function currentUserId(req: any): string {
-  return req?.user?.sub ?? req?.user?.id;
-}
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { requireUserId } from '@app/catalog/utils/current-user.util';
+import { LikesService } from '@app/catalog/likes/likes.service';
+import { UserLikesResultDto } from '@app/catalog/likes/dtos/likes-response.dto';
 
 @ApiTags('Profile / Likes')
 @ApiBearerAuth()
-@UseGuards(AuthGuardRequired as any)
 @Controller('catalog/profile/likes')
 export class ProfileLikesController {
   constructor(private readonly service: LikesService) {}
@@ -25,11 +23,11 @@ export class ProfileLikesController {
   @ApiOperation({ summary: 'List current user liked products' })
   @ApiOkResponse({ type: UserLikesResultDto })
   async listMine(
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
     @Query('limit') limit = '24',
     @Query('cursor') cursor?: string,
   ): Promise<UserLikesResultDto> {
-    const userId = currentUserId(req);
+    const userId = requireUserId(user);
     return this.service.listForUser(userId, Number(limit), cursor);
   }
 }
diff --git a/apps/api/src/catalog/policies/catalog.policies.ts b/apps/api/src/catalog/policies/catalog.policies.ts
index 5971ff2..cbc2215 100644
--- a/apps/api/src/catalog/policies/catalog.policies.ts
+++ b/apps/api/src/catalog/policies/catalog.policies.ts
@@ -1,23 +1,23 @@
-import { CurrentUserPayload } from '@app/common/decorators/current-user.decorator';
-import { RoleName } from '@prisma/client';
-
-export function hasRole(
-  user: CurrentUserPayload | undefined,
-  role: RoleName,
-): boolean {
-  return Boolean(user?.roles?.includes(role));
-}
-
-export function isAdmin(user: CurrentUserPayload | undefined): boolean {
-  return hasRole(user, RoleName.admin);
-}
-
-export function isSupplier(user: CurrentUserPayload | undefined): boolean {
-  return hasRole(user, RoleName.supplier);
-}
-
-export function canManageProduct(
-  user: CurrentUserPayload | undefined,
-): boolean {
-  return isAdmin(user) || isSupplier(user);
-}
+import { CurrentUserPayload } from '@app/common/decorators/current-user.decorator';
+import { RoleName } from '@prisma/client';
+
+export function hasRole(
+  user: CurrentUserPayload | undefined,
+  role: RoleName,
+): boolean {
+  return Boolean(user?.roles?.includes(role));
+}
+
+export function isAdmin(user: CurrentUserPayload | undefined): boolean {
+  return hasRole(user, RoleName.admin);
+}
+
+export function isSupplier(user: CurrentUserPayload | undefined): boolean {
+  return hasRole(user, RoleName.supplier);
+}
+
+export function canManageProduct(
+  user: CurrentUserPayload | undefined,
+): boolean {
+  return isAdmin(user) || isSupplier(user);
+}
diff --git a/apps/api/src/catalog/product/dtos/product-create.dto.ts b/apps/api/src/catalog/product/dtos/product-create.dto.ts
index 5e9ec8d..0720db5 100644
--- a/apps/api/src/catalog/product/dtos/product-create.dto.ts
+++ b/apps/api/src/catalog/product/dtos/product-create.dto.ts
@@ -1,36 +1,46 @@
-// apps/api/src/core/catalog/product/dto/product-create.dto.ts
 import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
 import {
-  IsArray,
   ArrayMaxSize,
+  ArrayNotEmpty,
   ArrayUnique,
+  IsArray,
   IsEnum,
-  IsIn,
   IsInt,
   IsOptional,
   IsString,
   IsUrl,
   Length,
+  Matches,
+  MaxLength,
   Max,
   Min,
-  ValidateIf,
-  IsNotEmpty,
+  ValidateNested,
 } from 'class-validator';
-import { Transform } from 'class-transformer';
+import { Transform, Type } from 'class-transformer';
 import { PricingType, ProductStatus, GraphicFormat } from '@prisma/client';
+import {
+  ProductAssetInputDto,
+  ProductFileInputDto,
+  ProductTopicLinkDto,
+} from '@app/catalog/product/dtos/product-shared.dto';
 import {
   toBigIntString,
   toBigIntStringArray,
+  toColorArray,
   toStringArray,
   toTrimmedString,
-} from './transformers';
+  toUppercaseStringArray,
+} from '@app/catalog/product/dtos/transformers';
+import { FA_SLUG_REGEX } from '@shared-slug/slug/fa-slug.util';
 
 export class CreateProductDto {
-  @ApiProperty({ example: 'ghalam-siah-vector' })
+  @ApiPropertyOptional({ example: 'نقاشی-و-تصویرسازی' })
+  @IsOptional()
   @IsString()
-  @Length(3, 255)
+  @MaxLength(200)
+  @Matches(FA_SLUG_REGEX, { message: 'Invalid slug format' })
   @Transform(toTrimmedString)
-  slug!: string;
+  slug?: string;
 
   @ApiProperty({ example: 'قلم سیاه – وکتور خوشنویسی' })
   @IsString()
@@ -45,14 +55,24 @@ export class CreateProductDto {
   @Transform(toTrimmedString)
   description?: string;
 
-  // Media
   @ApiPropertyOptional({ example: 'https://cdn.example.com/cover/abc.jpg' })
   @IsOptional()
   @IsUrl()
   coverUrl?: string;
 
   @ApiPropertyOptional({
-    description: 'ID فایل اصلی (BigInt به صورت رشته)',
+    example: 'p/ghalam-siah',
+    description: 'اختیاری؛ برای ساخت لینک کوتاه یکتا',
+  })
+  @IsOptional()
+  @IsString()
+  @Length(2, 80)
+  @Transform(toTrimmedString)
+  shortLink?: string;
+
+  @ApiPropertyOptional({
+    description:
+      'ID فایل اصلی (BigInt به صورت رشته). در صورت موجود نبودن فایل، از فیلد file برای ساخت رکورد جدید استفاده کنید.',
     example: '1234567890123',
   })
   @IsOptional()
@@ -60,19 +80,39 @@ export class CreateProductDto {
   @IsString()
   fileId?: string;
 
-  // Catalog
-  @ApiPropertyOptional({ example: 'خوشنویسی' })
+  @ApiPropertyOptional({
+    type: () => ProductFileInputDto,
+    description:
+      'برای ساخت ProductFile جدید. این فیلد و fileId نباید همزمان ارسال شوند.',
+  })
   @IsOptional()
-  @IsString()
-  @Length(1, 120)
-  @Transform(toTrimmedString)
-  topic?: string;
+  @ValidateNested()
+  @Type(() => ProductFileInputDto)
+  file?: ProductFileInputDto;
+
+  @ApiProperty({
+    enum: GraphicFormat,
+    isArray: true,
+    example: [GraphicFormat.SVG, GraphicFormat.EPS],
+  })
+  @IsArray()
+  @ArrayNotEmpty()
+  @ArrayUnique()
+  @Transform(toUppercaseStringArray)
+  @IsEnum(GraphicFormat, { each: true })
+  graphicFormats!: GraphicFormat[];
 
-  @ApiProperty({ enum: GraphicFormat, example: GraphicFormat.SVG })
-  @IsEnum(GraphicFormat)
-  graphicFormat!: GraphicFormat;
+  @ApiPropertyOptional({
+    type: [String],
+    description: 'کدهای رنگ HEX به صورت #RRGGBB',
+    example: ['#101010', '#FFD000'],
+  })
+  @IsOptional()
+  @IsArray()
+  @ArrayUnique()
+  @Transform(toColorArray)
+  colors?: string[];
 
-  // SEO
   @ApiPropertyOptional({ example: 'دانلود وکتور خوشنویسی قلم سیاه' })
   @IsOptional()
   @IsString()
@@ -97,8 +137,10 @@ export class CreateProductDto {
   @Transform(toStringArray)
   seoKeywords?: string[];
 
-  // Pricing/Publish
-  @ApiProperty({ enum: PricingType, example: PricingType.PAID_OR_SUBSCRIPTION })
+  @ApiProperty({
+    enum: PricingType,
+    example: PricingType.PAID_OR_SUBSCRIPTION,
+  })
   @IsEnum(PricingType)
   pricingType!: PricingType;
 
@@ -124,7 +166,46 @@ export class CreateProductDto {
   @IsString()
   publishedAt?: string;
 
-  // Relations
+  @ApiPropertyOptional({
+    description: 'حجم فایل بر حسب مگابایت (برای فیلترهای کلاینت)',
+    example: 120,
+  })
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt()
+  @Min(0)
+  @Max(10000)
+  fileSizeMB?: number;
+
+  @ApiPropertyOptional({
+    description: 'اندازه فایل به بایت (BigInt به صورت رشته)',
+    example: '123456789',
+  })
+  @IsOptional()
+  @Transform(toBigIntString)
+  @IsString()
+  fileBytes?: string;
+
+  @ApiPropertyOptional({
+    type: [ProductAssetInputDto],
+    description: 'لیست دارایی‌های نمایشی محصول',
+  })
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductAssetInputDto)
+  assets?: ProductAssetInputDto[];
+
+  @ApiPropertyOptional({
+    type: [ProductTopicLinkDto],
+    description: 'تاپیک‌های مرتبط با محصول',
+  })
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductTopicLinkDto)
+  topics?: ProductTopicLinkDto[];
+
   @ApiPropertyOptional({
     type: [String],
     description: 'آیدی‌های دسته‌بندی (BigInt به صورت رشته)',
diff --git a/apps/api/src/catalog/product/dtos/product-id.dto.ts b/apps/api/src/catalog/product/dtos/product-id.dto.ts
index 6bbddf7..87814f0 100644
--- a/apps/api/src/catalog/product/dtos/product-id.dto.ts
+++ b/apps/api/src/catalog/product/dtos/product-id.dto.ts
@@ -1,17 +1,17 @@
-// apps/api/src/core/catalog/product/dto/product-id.dto.ts
-import { ApiProperty } from '@nestjs/swagger';
-import { IsString, Length } from 'class-validator';
-
-export class ProductIdParamDto {
-  @ApiProperty({ description: 'ID (BigInt به صورت رشته) یا slug' })
-  @IsString()
-  @Length(1, 255)
-  idOrSlug!: string;
-}
-
-export class ProductIdBodyDto {
-  @ApiProperty({ description: 'ID (BigInt به صورت رشته)' })
-  @IsString()
-  @Length(1, 50)
-  productId!: string;
-}
+// apps/api/src/core/catalog/product/dto/product-id.dto.ts
+import { ApiProperty } from '@nestjs/swagger';
+import { IsString, Length } from 'class-validator';
+
+export class ProductIdParamDto {
+  @ApiProperty({ description: 'ID (BigInt به صورت رشته) یا slug' })
+  @IsString()
+  @Length(1, 255)
+  idOrSlug!: string;
+}
+
+export class ProductIdBodyDto {
+  @ApiProperty({ description: 'ID (BigInt به صورت رشته)' })
+  @IsString()
+  @Length(1, 50)
+  productId!: string;
+}
diff --git a/apps/api/src/catalog/product/dtos/product-query.dto.ts b/apps/api/src/catalog/product/dtos/product-query.dto.ts
index 14c192b..3a7c25d 100644
--- a/apps/api/src/catalog/product/dtos/product-query.dto.ts
+++ b/apps/api/src/catalog/product/dtos/product-query.dto.ts
@@ -1,17 +1,19 @@
 // apps/api/src/core/catalog/product/dto/product-query.dto.ts
 import { ApiPropertyOptional } from '@nestjs/swagger';
 import {
+  IsBooleanString,
   IsEnum,
   IsInt,
   IsOptional,
   IsString,
   Length,
+  Matches,
   Max,
   Min,
 } from 'class-validator';
 import { Transform } from 'class-transformer';
 import { PricingType, ProductStatus, GraphicFormat } from '@prisma/client';
-import { toBigIntString, toTrimmedString } from './transformers';
+import { toBigIntString, toTrimmedString } from '@app/catalog/product/dtos/transformers';
 
 export type ProductSort = 'latest' | 'popular' | 'viewed' | 'liked';
 
@@ -37,11 +39,43 @@ export class ProductFindQueryDto {
   @IsString()
   tagId?: string;
 
+  @ApiPropertyOptional({ description: 'آیدی تاپیک (BigInt به صورت رشته)' })
+  @IsOptional()
+  @Transform(toBigIntString)
+  @IsString()
+  topicId?: string;
+
   @ApiPropertyOptional({ description: 'UUID نویسنده' })
   @IsOptional()
   @IsString()
   authorId?: string;
 
+  @ApiPropertyOptional({
+    description: 'فیلتر بر اساس رنگ HEX (#RRGGBB)',
+    example: '#101010',
+  })
+  @IsOptional()
+  @Matches(/^#[0-9A-Fa-f]{6}$/u, {
+    message: 'Color must be HEX in the form #RRGGBB',
+  })
+  color?: string;
+
+  @ApiPropertyOptional({
+    description: 'تنها محصولاتی که فایل متصل دارند',
+    example: 'true',
+  })
+  @IsOptional()
+  @IsBooleanString()
+  hasFile?: string;
+
+  @ApiPropertyOptional({
+    description: 'تنها محصولاتی که حداقل یک دارایی دارند',
+    example: 'true',
+  })
+  @IsOptional()
+  @IsBooleanString()
+  hasAssets?: string;
+
   @ApiPropertyOptional({ enum: PricingType })
   @IsOptional()
   @IsEnum(PricingType)
diff --git a/apps/api/src/catalog/product/dtos/product-response.dto.ts b/apps/api/src/catalog/product/dtos/product-response.dto.ts
index d69798d..f6c583b 100644
--- a/apps/api/src/catalog/product/dtos/product-response.dto.ts
+++ b/apps/api/src/catalog/product/dtos/product-response.dto.ts
@@ -1,23 +1,24 @@
-// apps/api/src/core/catalog/product/dto/product-response.dto.ts
+// apps/api/src/core/catalog/product/dto/product-response.dto.ts
 import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
 import { PricingType, ProductStatus, GraphicFormat } from '@prisma/client';
-
-export class ProductAuthorDto {
-  @ApiProperty() userId!: string;
-  @ApiPropertyOptional() role?: string | null;
-}
-
-export class ProductTagDto {
-  @ApiProperty() id!: string; // BigInt → string
-  @ApiProperty() name!: string;
-  @ApiProperty() slug!: string;
-}
-
+
+export class ProductAuthorDto {
+  @ApiProperty() userId!: string;
+  @ApiPropertyOptional() role?: string | null;
+}
+
+export class ProductTagDto {
+  @ApiProperty() id!: string; // BigInt → string
+  @ApiProperty() name!: string;
+  @ApiProperty() slug!: string;
+}
+
 export class ProductCategoryDto {
   @ApiProperty() id!: string; // BigInt → string
   @ApiProperty() name!: string;
   @ApiProperty() slug!: string;
   @ApiPropertyOptional() parentId?: string | null; // BigInt → string
+  @ApiPropertyOptional() coverUrl?: string | null;
 }
 
 export class ProductAssetDto {
@@ -27,29 +28,62 @@ export class ProductAssetDto {
   @ApiProperty() order!: number;
 }
 
+export class ProductTopicDto {
+  @ApiProperty() id!: string;
+  @ApiProperty() name!: string;
+  @ApiProperty() slug!: string;
+  @ApiPropertyOptional() coverUrl?: string | null;
+  @ApiProperty() order!: number;
+}
+
+export class ProductFileDto {
+  @ApiProperty() id!: string;
+  @ApiProperty() storageKey!: string;
+  @ApiPropertyOptional() originalName?: string | null;
+  @ApiPropertyOptional({
+    description: 'Size stored for the source file in bytes (stringified BigInt)',
+  })
+  size?: string;
+  @ApiPropertyOptional() mimeType?: string | null;
+  @ApiPropertyOptional({ description: 'Arbitrary metadata saved with the file' })
+  meta?: Record<string, unknown> | null;
+}
+
 export class ProductBriefDto {
   @ApiProperty() id!: string; // BigInt → string
   @ApiProperty() slug!: string;
   @ApiProperty() title!: string;
   @ApiPropertyOptional() coverUrl?: string | null;
 
-  @ApiProperty({ enum: GraphicFormat }) graphicFormat!: GraphicFormat;
+  @ApiProperty({ enum: GraphicFormat, isArray: true })
+  graphicFormats!: GraphicFormat[];
+  @ApiProperty({ type: [String], description: 'Array of HEX colors (#RRGGBB)' })
+  colors!: string[];
   @ApiProperty({ enum: PricingType }) pricingType!: PricingType;
   @ApiPropertyOptional() price?: number | null;
 
   @ApiProperty({ enum: ProductStatus }) status!: ProductStatus;
 
-  @ApiProperty() viewsCount!: number;
-  @ApiProperty() downloadsCount!: number;
-  @ApiProperty() likesCount!: number;
-
+  @ApiProperty() viewsCount!: number;
+  @ApiProperty() downloadsCount!: number;
+  @ApiProperty() likesCount!: number;
+
   @ApiPropertyOptional() shortLink?: string | null;
-  @ApiPropertyOptional() topic?: string | null;
 
   @ApiPropertyOptional({ type: [String] }) seoKeywords?: string[];
   @ApiPropertyOptional() seoTitle?: string | null;
   @ApiPropertyOptional() seoDescription?: string | null;
 
+  @ApiProperty({
+    description: 'Convenience size selector exposed to clients',
+    example: 24,
+  })
+  fileSizeMB!: number;
+  @ApiPropertyOptional({
+    description: 'File size in bytes represented as a string',
+  })
+  fileBytes?: string;
+
   @ApiPropertyOptional() createdAt?: string;
   @ApiPropertyOptional() updatedAt?: string;
 }
@@ -57,7 +91,6 @@ export class ProductBriefDto {
 export class ProductDetailDto extends ProductBriefDto {
   @ApiPropertyOptional() description?: string | null;
   @ApiPropertyOptional() fileId?: string | null; // BigInt → string
-  @ApiPropertyOptional() fileBytes?: string | null; // اگر می‌فرستی
 
   @ApiPropertyOptional({ type: [ProductAssetDto] }) assets?: ProductAssetDto[];
   @ApiPropertyOptional({ type: [ProductCategoryDto] })
@@ -65,10 +98,12 @@ export class ProductDetailDto extends ProductBriefDto {
   @ApiPropertyOptional({ type: [ProductTagDto] }) tags?: ProductTagDto[];
   @ApiPropertyOptional({ type: [ProductAuthorDto] })
   authors?: ProductAuthorDto[];
+  @ApiPropertyOptional({ type: [ProductTopicDto] }) topics?: ProductTopicDto[];
+  @ApiPropertyOptional({ type: ProductFileDto }) file?: ProductFileDto;
 }
-
-export class ProductListResultDto {
-  @ApiProperty({ type: [ProductBriefDto] }) items!: ProductBriefDto[];
-  @ApiPropertyOptional({ description: 'cursor opaque (base64)' })
-  nextCursor?: string;
-}
+
+export class ProductListResultDto {
+  @ApiProperty({ type: [ProductBriefDto] }) items!: ProductBriefDto[];
+  @ApiPropertyOptional({ description: 'cursor opaque (base64)' })
+  nextCursor?: string;
+}
diff --git a/apps/api/src/catalog/product/dtos/product-update.dto.ts b/apps/api/src/catalog/product/dtos/product-update.dto.ts
index da2c88a..4be0f9f 100644
--- a/apps/api/src/catalog/product/dtos/product-update.dto.ts
+++ b/apps/api/src/catalog/product/dtos/product-update.dto.ts
@@ -1,31 +1,42 @@
-// apps/api/src/core/catalog/product/dto/product-update.dto.ts
 import { ApiPropertyOptional } from '@nestjs/swagger';
 import {
-  IsArray,
   ArrayMaxSize,
   ArrayUnique,
+  IsArray,
   IsEnum,
   IsInt,
   IsOptional,
   IsString,
   IsUrl,
   Length,
+  Matches,
+  MaxLength,
   Min,
+  ValidateNested,
 } from 'class-validator';
-import { Transform } from 'class-transformer';
-import { PricingType, ProductStatus, GraphicFormat } from '@prisma/client';
+import { Transform, Type } from 'class-transformer';
+import { GraphicFormat, PricingType, ProductStatus } from '@prisma/client';
+import {
+  ProductAssetInputDto,
+  ProductFileInputDto,
+  ProductTopicLinkDto,
+} from '@app/catalog/product/dtos/product-shared.dto';
 import {
   toBigIntString,
   toBigIntStringArray,
+  toColorArray,
   toStringArray,
   toTrimmedString,
-} from './transformers';
+  toUppercaseStringArray,
+} from '@app/catalog/product/dtos/transformers';
+import { FA_SLUG_REGEX } from '@shared-slug/slug/fa-slug.util';
 
 export class UpdateProductDto {
-  @ApiPropertyOptional({ example: 'ghalam-siah-vector' })
+  @ApiPropertyOptional({ example: 'نقاشی-و-تصویرسازی' })
   @IsOptional()
   @IsString()
-  @Length(3, 255)
+  @MaxLength(200)
+  @Matches(FA_SLUG_REGEX, { message: 'Invalid slug format' })
   @Transform(toTrimmedString)
   slug?: string;
 
@@ -43,32 +54,59 @@ export class UpdateProductDto {
   @Transform(toTrimmedString)
   description?: string;
 
-  // Media
   @ApiPropertyOptional()
   @IsOptional()
   @IsUrl()
   coverUrl?: string;
 
-  @ApiPropertyOptional({ description: 'ID فایل اصلی (BigInt به صورت رشته)' })
+  @ApiPropertyOptional()
   @IsOptional()
-  @Transform(toBigIntString)
   @IsString()
-  fileId?: string;
+  @Length(2, 80)
+  @Transform(toTrimmedString)
+  shortLink?: string;
 
-  // Catalog
-  @ApiPropertyOptional()
+  @ApiPropertyOptional({
+    description:
+      'ID فایل اصلی (BigInt به صورت رشته). برای حذف فایل، مقدار null ارسال کنید.',
+  })
   @IsOptional()
+  @Transform(toBigIntString)
   @IsString()
-  @Length(1, 120)
-  @Transform(toTrimmedString)
-  topic?: string;
+  fileId?: string | null;
+
+  @ApiPropertyOptional({
+    type: () => ProductFileInputDto,
+    description:
+      'برای ساخت ProductFile جدید هنگام ویرایش. با fileId (به جز null) قابل جمع نیست.',
+  })
+  @IsOptional()
+  @ValidateNested()
+  @Type(() => ProductFileInputDto)
+  file?: ProductFileInputDto;
+
+  @ApiPropertyOptional({
+    enum: GraphicFormat,
+    isArray: true,
+    example: [GraphicFormat.SVG, GraphicFormat.PNG],
+  })
+  @IsOptional()
+  @IsArray()
+  @ArrayUnique()
+  @Transform(toUppercaseStringArray)
+  @IsEnum(GraphicFormat, { each: true })
+  graphicFormats?: GraphicFormat[];
 
-  @ApiPropertyOptional({ enum: GraphicFormat })
+  @ApiPropertyOptional({
+    type: [String],
+    description: 'HEX colors (#RRGGBB)',
+  })
   @IsOptional()
-  @IsEnum(GraphicFormat)
-  graphicFormat?: GraphicFormat;
+  @IsArray()
+  @ArrayUnique()
+  @Transform(toColorArray)
+  colors?: string[];
 
-  // SEO
   @ApiPropertyOptional()
   @IsOptional()
   @IsString()
@@ -88,7 +126,6 @@ export class UpdateProductDto {
   @Transform(toStringArray)
   seoKeywords?: string[];
 
-  // Pricing/Publish
   @ApiPropertyOptional({ enum: PricingType })
   @IsOptional()
   @IsEnum(PricingType)
@@ -98,7 +135,7 @@ export class UpdateProductDto {
   @IsOptional()
   @IsInt()
   @Min(0)
-  price?: number;
+  price?: number | null;
 
   @ApiPropertyOptional({ enum: ProductStatus })
   @IsOptional()
@@ -108,9 +145,46 @@ export class UpdateProductDto {
   @ApiPropertyOptional({ example: '2025-11-08T12:00:00.000Z' })
   @IsOptional()
   @IsString()
-  publishedAt?: string;
+  publishedAt?: string | null;
+
+  @ApiPropertyOptional({
+    description: 'حجم فایل بر حسب مگابایت (برای فیلترهای کلاینت)',
+  })
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt()
+  @Min(0)
+  fileSizeMB?: number;
+
+  @ApiPropertyOptional({
+    description: 'اندازه فایل به بایت (BigInt به صورت رشته)',
+  })
+  @IsOptional()
+  @Transform(toBigIntString)
+  @IsString()
+  fileBytes?: string | null;
+
+  @ApiPropertyOptional({
+    type: [ProductAssetInputDto],
+    description: 'در صورت ارسال، تمام دارایی‌ها با این لیست جایگزین می‌شوند',
+  })
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductAssetInputDto)
+  assets?: ProductAssetInputDto[];
+
+  @ApiPropertyOptional({
+    type: [ProductTopicLinkDto],
+    description:
+      'در صورت ارسال، ارتباط موضوعی محصول دقیقاً مطابق این لیست به‌روز می‌شود',
+  })
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ProductTopicLinkDto)
+  topics?: ProductTopicLinkDto[];
 
-  // Relations (sync کامل در سرویس انجام می‌شود)
   @ApiPropertyOptional({
     type: [String],
     description: 'آیدی‌های دسته‌بندی (BigInt به صورت رشته)',
diff --git a/apps/api/src/catalog/product/dtos/transformers.ts b/apps/api/src/catalog/product/dtos/transformers.ts
index 56f17d3..05f606c 100644
--- a/apps/api/src/catalog/product/dtos/transformers.ts
+++ b/apps/api/src/catalog/product/dtos/transformers.ts
@@ -1,42 +1,64 @@
-// apps/api/src/core/catalog/product/dto/transformers.ts
-import { TransformFnParams } from 'class-transformer';
-
-export function toTrimmedString({
-  value,
-}: TransformFnParams): string | undefined {
-  if (value === undefined || value === null) return undefined;
-  const s = String(value).trim();
-  return s.length ? s : undefined;
-}
-
+// apps/api/src/core/catalog/product/dto/transformers.ts
+import { TransformFnParams } from 'class-transformer';
+
+export function toTrimmedString({
+  value,
+}: TransformFnParams): string | undefined {
+  if (value === undefined || value === null) return undefined;
+  const s = String(value).trim();
+  return s.length ? s : undefined;
+}
+
 export function toStringArray({
   value,
 }: TransformFnParams): string[] | undefined {
   if (value === undefined || value === null) return undefined;
   if (Array.isArray(value)) return value.map((v) => String(v));
-  // اجازه‌ی ورودی comma-separated
-  return String(value)
-    .split(',')
-    .map((x) => x.trim())
-    .filter(Boolean);
+  // اجازه‌ی ورودی comma-separated
+  return String(value)
+    .split(',')
+    .map((x) => x.trim())
+    .filter(Boolean);
+}
+
+/** اطمینان از اینکه مقدار ورودی، رشته‌ی عددیِ BigInt است */
+export function toBigIntString({
+  value,
+}: TransformFnParams): string | undefined {
+  if (value === undefined || value === null || value === '') return undefined;
+  const s = String(value).trim();
+  if (!/^\d+$/.test(s)) return undefined;
+  return s;
+}
+
+/** آرایه‌ای از رشته‌های BigInt (مثلاً categoryIds) */
+export function toBigIntStringArray({
+  value,
+}: TransformFnParams): string[] | undefined {
+  const arr = toStringArray({ value } as TransformFnParams);
+  if (!arr) return undefined;
+  const out = arr.filter((s) => /^\d+$/.test(s));
+  return out.length ? out : [];
 }
 
-/** اطمینان از اینکه مقدار ورودی، رشته‌ی عددیِ BigInt است */
-export function toBigIntString({
+/** Normalises an array of HEX color strings (#RRGGBB) while filtering out invalid inputs. */
+export function toColorArray({
   value,
-}: TransformFnParams): string | undefined {
-  if (value === undefined || value === null || value === '') return undefined;
-  const s = String(value).trim();
-  if (!/^\d+$/.test(s)) return undefined;
-  return s;
+}: TransformFnParams): string[] | undefined {
+  const arr = toStringArray({ value } as TransformFnParams);
+  if (!arr) return undefined;
+  const normalized = arr
+    .map((s) => s.trim().replace(/^#/u, '').toUpperCase())
+    .filter((s) => /^[0-9A-F]{6}$/u.test(s))
+    .map((s) => `#${s}`);
+  return normalized.length ? Array.from(new Set(normalized)) : [];
 }
 
-/** آرایه‌ای از رشته‌های BigInt (مثلاً categoryIds) */
-export function toBigIntStringArray({
+/** Uppercases each string entry (useful for enum arrays). */
+export function toUppercaseStringArray({
   value,
 }: TransformFnParams): string[] | undefined {
   const arr = toStringArray({ value } as TransformFnParams);
   if (!arr) return undefined;
-  const out = arr.filter((s) => /^\d+$/.test(s));
-  return out.length ? out : [];
+  return arr.map((s) => s.toUpperCase());
 }
diff --git a/apps/api/src/catalog/product/product.mapper.ts b/apps/api/src/catalog/product/product.mapper.ts
index d96984c..dad945d 100644
--- a/apps/api/src/catalog/product/product.mapper.ts
+++ b/apps/api/src/catalog/product/product.mapper.ts
@@ -1,30 +1,51 @@
-import {
-  Prisma,
-  GraphicFormat,
-  PricingType,
-  ProductStatus,
-} from '@prisma/client';
+import { Prisma, PricingType, ProductStatus } from '@prisma/client';
 import {
   ProductAssetDto,
   ProductAuthorDto,
   ProductBriefDto,
   ProductCategoryDto,
   ProductDetailDto,
+  ProductFileDto,
   ProductTagDto,
-} from './dtos/product-response.dto';
+  ProductTopicDto,
+} from '@app/catalog/product/dtos/product-response.dto';
 
 /** include استاندارد که سرویس هم باید ازش استفاده کند تا تایپ‌ها درست Resolve شوند */
 export const productInclude = {
-  assets: true,
+  assets: { orderBy: { sortOrder: 'asc' } },
   categoryLinks: { include: { category: true } },
   tagLinks: { include: { tag: true } },
-  supplierLinks: { include: { user: true } },
+  supplierLinks: true,
+  topics: { include: { topic: true }, orderBy: { order: 'asc' } },
+  file: true,
 } as const;
 
 export type ProductWithRelations = Prisma.ProductGetPayload<{
   include: typeof productInclude;
 }>;
 
+/* ============================================================
+ * Helpers (type-safe, بدون any)
+ * ========================================================== */
+
+/** فقط زمانی مقدار را نگه می‌داریم که یک آبجکت plain باشد؛ در غیر این صورت null */
+function toRecordOrNull(
+  v: Prisma.JsonValue | null | undefined,
+): Record<string, unknown> | null {
+  if (v && typeof v === 'object' && !Array.isArray(v)) {
+    return v as Record<string, unknown>;
+  }
+  return null;
+}
+
+/** اندازه فایل را به string | undefined نرمال می‌کند */
+function toStringOrUndefined(v: unknown): string | undefined {
+  if (typeof v === 'string') return v;
+  if (typeof v === 'number') return v.toString();
+  if (typeof v === 'bigint') return v.toString();
+  return undefined;
+}
+
 export class ProductMapper {
   /** تبدیل مدل کامل به خروجی خلاصه برای لیست‌ها */
   static toBrief(p: ProductWithRelations): ProductBriefDto {
@@ -34,8 +55,10 @@ export class ProductMapper {
       title: p.title,
       coverUrl: p.coverUrl ?? undefined,
 
-      graphicFormat: p.graphicFormat as GraphicFormat,
+      graphicFormats: [...(p.graphicFormats ?? [])],
+      colors: [...(p.colors ?? [])],
       pricingType: p.pricingType as PricingType,
+
       // اگر 0 هم معتبر است، از چک صریح استفاده کن
       price:
         p.price !== null && p.price !== undefined ? Number(p.price) : undefined,
@@ -47,12 +70,14 @@ export class ProductMapper {
       likesCount: p.likesCount,
 
       shortLink: p.shortLink ?? undefined,
-      topic: p.topic ?? undefined,
 
       seoKeywords: p.seoKeywords ?? undefined,
       seoTitle: p.seoTitle ?? undefined,
       seoDescription: p.seoDescription ?? undefined,
 
+      fileSizeMB: p.fileSizeMB,
+      fileBytes: p.fileBytes ? p.fileBytes.toString() : undefined,
+
       createdAt: p.createdAt.toISOString(),
       updatedAt: p.updatedAt.toISOString(),
     };
@@ -77,6 +102,7 @@ export class ProductMapper {
         parentId: pc.category.parentId
           ? String(pc.category.parentId)
           : undefined,
+        coverUrl: pc.category.coverUrl ?? undefined,
       }),
     );
 
@@ -91,6 +117,30 @@ export class ProductMapper {
       role: null,
     }));
 
+    const topics: ProductTopicDto[] = (p.topics ?? []).map((link) => ({
+      id: String(link.topic.id),
+      name: link.topic.name,
+      slug: link.topic.slug,
+      coverUrl: link.topic.coverUrl ?? undefined,
+      order: link.order,
+    }));
+
+    const file: ProductFileDto | undefined = p.file
+      ? {
+          id: String(p.file.id),
+          storageKey: p.file.storageKey,
+          originalName: p.file.originalName ?? undefined,
+          // ✅ اینجا string می‌خواهیم
+          size: toStringOrUndefined(p.file.size),
+          mimeType: p.file.mimeType ?? undefined,
+          // ✅ به Record<string, unknown> | null نرمال شود تا با DTO سازگار باشد
+          meta:
+            p.file.meta === undefined
+              ? undefined
+              : toRecordOrNull(p.file.meta),
+        }
+      : undefined;
+
     return {
       ...brief,
       description: p.description ?? undefined,
@@ -99,6 +149,8 @@ export class ProductMapper {
       categories,
       tags,
       authors,
+      topics,
+      file,
     };
   }
 }
diff --git a/apps/api/src/catalog/product/product.module.ts b/apps/api/src/catalog/product/product.module.ts
index 8e39441..8136c44 100644
--- a/apps/api/src/catalog/product/product.module.ts
+++ b/apps/api/src/catalog/product/product.module.ts
@@ -1,7 +1,7 @@
 import { Module } from '@nestjs/common';
-import { ProductService } from './product.service';
-import { PrismaService } from '../../prisma/prisma.service';
-import { ProductController } from './products.controller';
+import { ProductService } from '@app/catalog/product/product.service';
+import { PrismaService } from '@app/prisma/prisma.service';
+import { ProductController } from '@app/catalog/product/products.controller';
 
 @Module({
   controllers: [ProductController],
diff --git a/apps/api/src/catalog/product/product.service.ts b/apps/api/src/catalog/product/product.service.ts
index fa510a4..8722f35 100644
--- a/apps/api/src/catalog/product/product.service.ts
+++ b/apps/api/src/catalog/product/product.service.ts
@@ -1,4 +1,3 @@
-// apps/api/src/core/catalog/product/product.service.ts
 import {
   Injectable,
   BadRequestException,
@@ -11,32 +10,36 @@ import {
   ProductStatus,
   GraphicFormat,
 } from '@prisma/client';
-import { PrismaService } from '../../prisma/prisma.service';
+import { PrismaClientKnownRequestError, Decimal } from '@prisma/client/runtime/library';
+import { PrismaService } from '@app/prisma/prisma.service';
 import { Buffer } from 'buffer';
 
-import { CreateProductDto } from './dtos/product-create.dto';
-import { UpdateProductDto } from './dtos/product-update.dto';
-import { ProductFindQueryDto, ProductSort } from './dtos/product-query.dto';
+import { CreateProductDto } from '@app/catalog/product/dtos/product-create.dto';
+import { UpdateProductDto } from '@app/catalog/product/dtos/product-update.dto';
+import { ProductFindQueryDto, ProductSort } from '@app/catalog/product/dtos/product-query.dto';
 import {
   ProductBriefDto,
   ProductDetailDto,
   ProductListResultDto,
-} from './dtos/product-response.dto';
+} from '@app/catalog/product/dtos/product-response.dto';
+import { ProductFileInputDto } from '@app/catalog/product/dtos/product-shared.dto';
 
 import {
   ProductMapper,
   productInclude,
   type ProductWithRelations,
-} from './product.mapper';
+} from '@app/catalog/product/product.mapper';
+import {
+  clampFaSlug,
+  makeFaSlug,
+  normalizeFaText,
+} from '@shared-slug/slug/fa-slug.util';
 
-/* ============================================================
- * انواع کمکی (بدون any)
- * ========================================================== */
 export type Actor = { id: string; isAdmin: boolean };
 
-/* ============================================================
- * ابزارهای کمکی: cursor, تبدیل‌ها، و …
- * ========================================================== */
+const MAX_AUTHORS = 3;
+const PRODUCT_ENTITY_TYPE = 'product' as const;
+
 function encodeCursor(obj: Record<string, string | number>): string {
   return Buffer.from(JSON.stringify(obj), 'utf8').toString('base64url');
 }
@@ -55,85 +58,105 @@ function uniq<T>(arr: T[] | null | undefined): T[] {
 }
 function toBigIntNullable(id?: string): bigint | null {
   if (!id) return null;
-  if (!/^\d+$/.test(id)) return null;
+  if (!/^\d+$/u.test(id)) return null;
   return BigInt(id);
 }
+function parseBooleanFlag(value?: string): boolean | undefined {
+  if (value === undefined) return undefined;
+  return value === 'true';
+}
+function normalizeColorFilter(value?: string): string | undefined {
+  if (!value) return undefined;
+  const trimmed = value.trim().toUpperCase();
+  if (!/^#[0-9A-F]{6}$/u.test(trimmed)) {
+    return undefined;
+  }
+  return trimmed;
+}
 
-/** جستجوی ساده روی title/description/topic/slug */
 function makeTextWhere(q?: string): Prisma.ProductWhereInput | undefined {
   if (!q) return undefined;
-  const term = q.trim();
+  const term = normalizeFaText(q.trim());
   if (!term) return undefined;
   return {
     OR: [
       { title: { contains: term, mode: 'insensitive' } },
       { description: { contains: term, mode: 'insensitive' } },
-      { topic: { contains: term, mode: 'insensitive' } },
       { slug: { contains: term, mode: 'insensitive' } },
+      { seoTitle: { contains: term, mode: 'insensitive' } },
+      { seoDescription: { contains: term, mode: 'insensitive' } },
+      { shortLink: { contains: term, mode: 'insensitive' } },
     ],
   };
 }
 
-/* ============================================================
- * Service
- * ========================================================== */
 @Injectable()
 export class ProductService {
   constructor(private readonly prisma: PrismaService) {}
 
-  /* ------------------------------
-   * Create
-   * ---------------------------- */
   async create(dto: CreateProductDto, actor: Actor): Promise<ProductDetailDto> {
-    const authorIds = uniq(dto.authorIds ?? []);
-    if (authorIds.length === 0) authorIds.push(actor.id);
-    if (authorIds.length > 3) {
-      throw new BadRequestException('A product can have at most 3 authors.');
-    }
+    const title = normalizeFaText(dto.title);
+    const slug = await this.ensureUniqueSlug(dto.slug ?? dto.title);
+    const authors = this.resolveAuthors(dto.authorIds, actor);
+    const categoryIds = uniq(dto.categoryIds ?? []).map((cid) => BigInt(cid));
+    const tagIds = uniq(dto.tagIds ?? []).map((tid) => BigInt(tid));
+    const topics = this.buildTopicLinks(dto.topics);
+    const assetPayloads = this.buildAssetCreateInput(dto.assets);
+    const fileRelation = await this.buildFileRelationForCreate(dto);
 
     const created = await this.prisma.product.create({
       data: {
-        slug: dto.slug,
-        title: dto.title,
+        slug,
+        title,
         description: dto.description ?? null,
-
         coverUrl: dto.coverUrl ?? null,
-        // ✅ nested relation برای فایل
-        ...(dto.fileId
-          ? { file: { connect: { id: BigInt(dto.fileId) } } }
-          : {}),
-
-        topic: dto.topic ?? null,
-        graphicFormat: dto.graphicFormat as GraphicFormat,
-
-        // SEO
+        shortLink: dto.shortLink ?? null,
+        graphicFormats: dto.graphicFormats ?? [],
+        colors: dto.colors ?? [],
         seoTitle: dto.seoTitle ?? null,
         seoDescription: dto.seoDescription ?? null,
         seoKeywords: dto.seoKeywords ?? [],
-
-        // قیمت/انتشار
         pricingType: dto.pricingType as PricingType,
-        price:
-          dto.price !== undefined && dto.price !== null
-            ? new Prisma.Decimal(dto.price)
-            : null,
+        price: this.toDecimal(dto.price),
         status: (dto.status ?? ProductStatus.DRAFT) as ProductStatus,
         publishedAt: dto.publishedAt ? new Date(dto.publishedAt) : null,
+        fileSizeMB: dto.fileSizeMB ?? 0,
+        fileBytes:
+          dto.fileBytes !== undefined && dto.fileBytes !== null
+            ? BigInt(dto.fileBytes)
+            : null,
+        ...(fileRelation ? { file: fileRelation } : {}),
 
-        // روابط
         supplierLinks: {
-          create: authorIds.map((userId) => ({ userId })),
-        },
-        categoryLinks: {
-          create: uniq(dto.categoryIds ?? []).map((cid) => ({
-            categoryId: BigInt(cid),
-          })),
-        },
-        tagLinks: {
-          create: uniq(dto.tagIds ?? []).map((tid) => ({
-            tagId: BigInt(tid),
-          })),
+          create: authors.map((userId) => ({ userId })),
         },
+        categoryLinks: categoryIds.length
+          ? {
+              create: categoryIds.map((categoryId) => ({
+                categoryId,
+              })),
+            }
+          : undefined,
+        tagLinks: tagIds.length
+          ? {
+              create: tagIds.map((tagId) => ({
+                tagId,
+              })),
+            }
+          : undefined,
+        topics: topics.length
+          ? {
+              create: topics.map((topic) => ({
+                topicId: topic.topicId,
+                order: topic.order,
+              })),
+            }
+          : undefined,
+        assets: assetPayloads.length
+          ? {
+              create: assetPayloads,
+            }
+          : undefined,
       },
       include: productInclude,
     });
@@ -141,9 +164,6 @@ export class ProductService {
     return ProductMapper.toDetail(created as ProductWithRelations);
   }
 
-  /* ------------------------------
-   * Update
-   * ---------------------------- */
   async update(
     idOrSlug: string,
     dto: UpdateProductDto,
@@ -154,16 +174,32 @@ export class ProductService {
     if (!(await this.canEdit(product.id, actor))) {
       throw new ForbiddenException('You are not allowed to edit this product.');
     }
-    if (dto.authorIds && uniq(dto.authorIds).length > 3) {
-      throw new BadRequestException('A product can have at most 3 authors.');
+    if (dto.authorIds && uniq(dto.authorIds).length > MAX_AUTHORS) {
+      throw new BadRequestException(
+        `A product can have at most ${MAX_AUTHORS} authors.`,
+      );
     }
 
+    const nextTitle =
+      dto.title !== undefined ? normalizeFaText(dto.title) : undefined;
+    const slugSource =
+      dto.slug !== undefined
+        ? dto.slug
+        : dto.title !== undefined
+          ? dto.title
+          : undefined;
+    const nextSlug = slugSource
+      ? await this.ensureUniqueSlug(slugSource, product.id)
+      : undefined;
+
+    const fileRelation = await this.buildFileRelationForUpdate(dto);
+
     const data: Prisma.ProductUpdateInput = {
-      slug: dto.slug ?? undefined,
-      title: dto.title ?? undefined,
+      slug: nextSlug ?? undefined,
+      title: nextTitle ?? undefined,
       description: dto.description ?? undefined,
       coverUrl: dto.coverUrl ?? undefined,
-      topic: dto.topic ?? undefined,
+      shortLink: dto.shortLink ?? undefined,
       seoTitle: dto.seoTitle ?? undefined,
       seoDescription: dto.seoDescription ?? undefined,
       seoKeywords: dto.seoKeywords ? { set: dto.seoKeywords } : undefined,
@@ -172,18 +208,29 @@ export class ProductService {
         dto.price !== undefined
           ? dto.price === null
             ? null
-            : new Prisma.Decimal(dto.price)
+            : this.toDecimal(dto.price)
           : undefined,
       status: dto.status ?? undefined,
-      publishedAt: dto.publishedAt ? new Date(dto.publishedAt) : undefined,
-      graphicFormat: dto.graphicFormat ?? undefined,
-
-      // ✅ مدیریت رابطه فایل
-      ...(dto.fileId === undefined
-        ? {}
-        : dto.fileId
-          ? { file: { connect: { id: BigInt(dto.fileId) } } }
-          : { file: { disconnect: true } }),
+      publishedAt:
+        dto.publishedAt !== undefined
+          ? dto.publishedAt
+            ? new Date(dto.publishedAt)
+            : null
+          : undefined,
+      graphicFormats:
+        dto.graphicFormats !== undefined
+          ? { set: dto.graphicFormats }
+          : undefined,
+      colors: dto.colors !== undefined ? { set: dto.colors ?? [] } : undefined,
+      fileSizeMB:
+        dto.fileSizeMB !== undefined ? (dto.fileSizeMB ?? 0) : undefined,
+      fileBytes:
+        dto.fileBytes !== undefined
+          ? dto.fileBytes === null
+            ? null
+            : BigInt(dto.fileBytes)
+          : undefined,
+      ...(fileRelation ? { file: fileRelation } : {}),
     };
 
     const updated = await this.prisma.$transaction(async (trx) => {
@@ -244,22 +291,53 @@ export class ProductService {
         }
       }
 
-      return trx.product.update({
+      if (dto.topics) {
+        await trx.productTopic.deleteMany({ where: { productId: product.id } });
+        const nextTopics = this.buildTopicLinks(dto.topics);
+        if (nextTopics.length > 0) {
+          await trx.productTopic.createMany({
+            data: nextTopics.map((topic) => ({
+              productId: product.id,
+              topicId: topic.topicId,
+              order: topic.order,
+            })),
+            skipDuplicates: true,
+          });
+        }
+      }
+
+      if (dto.assets) {
+        await trx.productAsset.deleteMany({ where: { productId: product.id } });
+        const nextAssets = this.buildAssetCreateInput(dto.assets);
+        if (nextAssets.length > 0) {
+          await trx.productAsset.createMany({
+            data: nextAssets.map((asset) => ({
+              productId: product.id,
+              url: asset.url,
+              alt: asset.alt,
+              sortOrder: asset.sortOrder,
+            })),
+          });
+        }
+      }
+
+      const result = await trx.product.update({
         where: { id: product.id },
         data,
         include: productInclude,
       });
+      if (nextSlug && nextSlug !== product.slug) {
+        await this.createSlugRedirect(trx, product.id, product.slug, nextSlug);
+      }
+      return result;
     });
 
     return ProductMapper.toDetail(updated as ProductWithRelations);
   }
 
-  /* ------------------------------
-   * FindOne
-   * ---------------------------- */
-  async findOne(
+  async findByIdOrSlug(
     idOrSlug: string,
-    viewerId?: string,
+    _viewerId?: string,
   ): Promise<ProductDetailDto> {
     const prod = await this.prisma.product.findFirst({
       where: this.idOrSlugWhere(idOrSlug),
@@ -269,9 +347,29 @@ export class ProductService {
     return ProductMapper.toDetail(prod as ProductWithRelations);
   }
 
-  /* ------------------------------
-   * FindAll — Load More with cursor
-   * ---------------------------- */
+  async findBySlug(
+    slug: string,
+    viewerId?: string,
+  ): Promise<{ product?: ProductDetailDto; redirectTo?: string }> {
+    const product = await this.prisma.product.findUnique({
+      where: { slug },
+      include: productInclude,
+    });
+    if (product) {
+      return {
+        product: ProductMapper.toDetail(product as ProductWithRelations),
+      };
+    }
+    const redirect = await this.prisma.slugRedirect.findUnique({
+      where: { fromSlug: slug },
+      select: { entityType: true, toSlug: true },
+    });
+    if (redirect?.entityType === PRODUCT_ENTITY_TYPE) {
+      return { redirectTo: redirect.toSlug };
+    }
+    throw new NotFoundException('Product not found');
+  }
+
   async findAll(query: ProductFindQueryDto): Promise<ProductListResultDto> {
     const limit = Math.min(Math.max(query.limit ?? 24, 1), 60);
     const sort: ProductSort = (query.sort ?? 'latest') as ProductSort;
@@ -282,10 +380,20 @@ export class ProductService {
 
     if (query.pricingType)
       ands.push({ pricingType: query.pricingType as PricingType });
-    if (query.graphicFormat)
-      ands.push({ graphicFormat: query.graphicFormat as GraphicFormat });
+    if (query.graphicFormat) {
+      ands.push({
+        graphicFormats: {
+          has: query.graphicFormat as GraphicFormat,
+        },
+      });
+    }
     if (query.status) ands.push({ status: query.status as ProductStatus });
 
+    const colorFilter = normalizeColorFilter(query.color);
+    if (colorFilter) {
+      ands.push({ colors: { has: colorFilter } });
+    }
+
     if (query.categoryId) {
       const cid = toBigIntNullable(query.categoryId);
       if (cid) ands.push({ categoryLinks: { some: { categoryId: cid } } });
@@ -294,8 +402,27 @@ export class ProductService {
       const tid = toBigIntNullable(query.tagId);
       if (tid) ands.push({ tagLinks: { some: { tagId: tid } } });
     }
-    if (query.authorId)
+    if (query.topicId) {
+      const topicId = toBigIntNullable(query.topicId);
+      if (topicId) ands.push({ topics: { some: { topicId } } });
+    }
+    if (query.authorId) {
       ands.push({ supplierLinks: { some: { userId: query.authorId } } });
+    }
+
+    const hasFile = parseBooleanFlag(query.hasFile);
+    if (hasFile !== undefined) {
+      ands.push(
+        hasFile ? { fileId: { not: null } } : { fileId: { equals: null } },
+      );
+    }
+
+    const hasAssets = parseBooleanFlag(query.hasAssets);
+    if (hasAssets !== undefined) {
+      ands.push(
+        hasAssets ? { assets: { some: {} } } : { assets: { none: {} } },
+      );
+    }
 
     const baseWhere: Prisma.ProductWhereInput = ands.length
       ? { AND: ands }
@@ -316,7 +443,7 @@ export class ProductService {
         cursorWhere = {
           OR: [
             { createdAt: { lt: createdAt } },
-            { AND: [{ createdAt: createdAt }, { id: { lt: id } }] },
+            { AND: [{ createdAt }, { id: { lt: id } }] },
           ],
         };
       }
@@ -409,9 +536,6 @@ export class ProductService {
     return { items, nextCursor };
   }
 
-  /* ------------------------------
-   * Remove (Archive)
-   * ---------------------------- */
   async remove(idOrSlug: string, actor: Actor): Promise<ProductDetailDto> {
     const product = await this.getByIdOrSlugStrict(idOrSlug);
     if (!(await this.canEdit(product.id, actor))) {
@@ -427,9 +551,6 @@ export class ProductService {
     return ProductMapper.toDetail(updated as ProductWithRelations);
   }
 
-  /* ------------------------------
-   * Toggle Like
-   * ---------------------------- */
   async toggleLike(
     productIdStr: string,
     userId: string,
@@ -464,9 +585,6 @@ export class ProductService {
     return { liked: true };
   }
 
-  /* ------------------------------
-   * Toggle Bookmark
-   * ---------------------------- */
   async toggleBookmark(
     productIdStr: string,
     userId: string,
@@ -489,9 +607,6 @@ export class ProductService {
     return { bookmarked: true };
   }
 
-  /* ------------------------------
-   * Increment View (analytics-lite)
-   * ---------------------------- */
   async incrementView(
     productId: bigint,
     viewerId?: string,
@@ -514,9 +629,6 @@ export class ProductService {
     ]);
   }
 
-  /* ------------------------------
-   * Register Download (and count)
-   * ---------------------------- */
   async registerDownload(
     productIdStr: string,
     userId: string,
@@ -544,10 +656,6 @@ export class ProductService {
     ]);
   }
 
-  /* ============================================================
-   * Helpers
-   * ========================================================== */
-
   private async canEdit(productId: bigint, actor: Actor): Promise<boolean> {
     if (actor.isAdmin) return true;
     const link = await this.prisma.productSupplier.findFirst({
@@ -568,9 +676,189 @@ export class ProductService {
   }
 
   private idOrSlugWhere(idOrSlug: string): Prisma.ProductWhereInput {
-    if (/^\d+$/.test(idOrSlug)) {
+    if (/^\d+$/u.test(idOrSlug)) {
       return { id: BigInt(idOrSlug) };
     }
-    return { slug: idOrSlug };
+    return { slug: normalizeFaText(idOrSlug) };
+  }
+
+  private async buildFileRelationForCreate(
+    dto: CreateProductDto,
+  ): Promise<Prisma.ProductFileCreateNestedOneWithoutProductInput | undefined> {
+    if (!dto.file && !dto.fileId) {
+      return undefined;
+    }
+    if (dto.file && dto.fileId) {
+      throw new BadRequestException('Provide either fileId or file, not both.');
+    }
+    if (dto.file) {
+      return { create: this.mapFileCreateInput(dto.file) };
+    }
+    if (!dto.fileId) {
+      return undefined;
+    }
+    const fileId = this.parseFileIdOrThrow(dto.fileId);
+    await this.ensureProductFileExists(fileId);
+    return { connect: { id: fileId } };
+  }
+
+  private async buildFileRelationForUpdate(
+    dto: UpdateProductDto,
+  ): Promise<Prisma.ProductFileUpdateOneWithoutProductNestedInput | undefined> {
+    if (dto.file && dto.fileId !== undefined && dto.fileId !== null) {
+      throw new BadRequestException('Provide either fileId or file, not both.');
+    }
+    if (dto.file) {
+      return { create: this.mapFileCreateInput(dto.file) };
+    }
+    if (dto.fileId === null) {
+      return { disconnect: true };
+    }
+    if (!dto.fileId) {
+      return undefined;
+    }
+    const fileId = this.parseFileIdOrThrow(dto.fileId);
+    await this.ensureProductFileExists(fileId);
+    return { connect: { id: fileId } };
+  }
+
+  private mapFileCreateInput(
+    file: ProductFileInputDto,
+  ): Prisma.ProductFileCreateWithoutProductInput {
+    return {
+      storageKey: file.storageKey,
+      originalName: file.originalName ?? null,
+      size:
+        file.size !== undefined && file.size !== null
+          ? BigInt(file.size)
+          : null,
+      mimeType: file.mimeType ?? null,
+      meta: Prisma.NullTypes.JsonNull,
+    };
+  }
+
+  private parseFileIdOrThrow(fileId: string): bigint {
+    const parsed = toBigIntNullable(fileId);
+    if (parsed === null) {
+      throw new BadRequestException('Invalid fileId: expected numeric string');
+    }
+    return parsed;
+  }
+
+  private async ensureProductFileExists(fileId: bigint): Promise<void> {
+    const exists = await this.prisma.productFile.findUnique({
+      where: { id: fileId },
+      select: { id: true },
+    });
+    if (!exists) {
+      throw new BadRequestException('Invalid fileId: ProductFile not found');
+    }
+  }
+
+  private resolveAuthors(
+    authorIds: string[] | undefined,
+    actor: Actor,
+  ): string[] {
+    const authors = uniq(authorIds ?? []);
+    if (authors.length === 0) {
+      authors.push(actor.id);
+    }
+    if (authors.length > MAX_AUTHORS) {
+      throw new BadRequestException(
+        `A product can have at most ${MAX_AUTHORS} authors.`,
+      );
+    }
+    return authors;
+  }
+
+  private buildAssetCreateInput(
+    assets: CreateProductDto['assets'] | UpdateProductDto['assets'],
+  ): Array<{ url: string; alt: string | null; sortOrder: number }> {
+    if (!assets) return [];
+    return assets.map((asset, index) => ({
+      url: asset.url,
+      alt: asset.alt ?? null,
+      sortOrder:
+        asset.order !== undefined && asset.order !== null ? asset.order : index,
+    }));
+  }
+
+  private buildTopicLinks(
+    topics: CreateProductDto['topics'] | UpdateProductDto['topics'],
+  ): Array<{ topicId: bigint; order: number }> {
+    if (!topics) return [];
+    const seen = new Set<string>();
+    const out: Array<{ topicId: bigint; order: number }> = [];
+    topics.forEach((topic, index) => {
+      if (!topic.topicId) return;
+      if (seen.has(topic.topicId)) return;
+      seen.add(topic.topicId);
+      out.push({
+        topicId: BigInt(topic.topicId),
+        order:
+          topic.order !== undefined && topic.order !== null
+            ? topic.order
+            : index,
+      });
+    });
+    return out;
+  }
+
+  private async ensureUniqueSlug(
+    source: string,
+    ignoreId?: bigint,
+  ): Promise<string> {
+    const base = makeFaSlug(source);
+    if (!base) {
+      throw new BadRequestException('Slug cannot be resolved from title.');
+    }
+    for (let attempt = 0; attempt < 20; attempt += 1) {
+      const candidate =
+        attempt === 0 ? base : clampFaSlug(`${base}-${attempt + 1}`);
+      const existing = await this.prisma.product.findUnique({
+        where: { slug: candidate },
+        select: { id: true },
+      });
+      if (!existing || (ignoreId && existing.id === ignoreId)) {
+        return candidate;
+      }
+    }
+    return clampFaSlug(`${base}-${Date.now()}`);
+  }
+
+  private async createSlugRedirect(
+    trx: Prisma.TransactionClient,
+    entityId: bigint,
+    fromSlug: string,
+    toSlug: string,
+  ): Promise<void> {
+    if (fromSlug === toSlug) {
+      return;
+    }
+    try {
+      await trx.slugRedirect.create({
+        data: {
+          entityType: PRODUCT_ENTITY_TYPE,
+          entityId: entityId.toString(),
+          fromSlug,
+          toSlug,
+        },
+      });
+    } catch (error) {
+      if (
+        error instanceof PrismaClientKnownRequestError &&
+        error.code === 'P2002'
+      ) {
+        throw new BadRequestException(
+          `A redirect already exists for slug "${fromSlug}"`,
+        );
+      }
+      throw error;
+    }
+  }
+
+  private toDecimal(value?: number | null): Decimal | null {
+    if (value === undefined || value === null) return null;
+    return new Decimal(value);
   }
 }
diff --git a/apps/api/src/catalog/product/products.controller.ts b/apps/api/src/catalog/product/products.controller.ts
index 453d865..df47e3c 100644
--- a/apps/api/src/catalog/product/products.controller.ts
+++ b/apps/api/src/catalog/product/products.controller.ts
@@ -1,50 +1,59 @@
 import {
+  Body,
   Controller,
-  Get,
-  Post,
-  Patch,
   Delete,
-  Body,
-  Param,
-  Query,
-  Req,
-  Ip,
+  Get,
   Headers,
-  UseGuards,
   HttpCode,
   HttpStatus,
+  Ip,
+  Param,
+  Patch,
+  Post,
+  Query,
+  ForbiddenException,
+  Res,
 } from '@nestjs/common';
 import {
-  ApiTags,
-  ApiOperation,
   ApiBearerAuth,
-  ApiOkResponse,
   ApiCreatedResponse,
   ApiNoContentResponse,
+  ApiOkResponse,
+  ApiOperation,
+  ApiTags,
+  ApiParam,
+  ApiResponse,
 } from '@nestjs/swagger';
+import { Response } from 'express';
+import { RoleName } from '@prisma/client';
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { Public } from '@app/common/decorators/public.decorator';
 
-import { ProductService, Actor } from './product.service';
-import { CreateProductDto } from './dtos/product-create.dto';
-import { UpdateProductDto } from './dtos/product-update.dto';
-import { ProductFindQueryDto } from './dtos/product-query.dto';
+import { ProductService, Actor } from '@app/catalog/product/product.service';
+import { CreateProductDto } from '@app/catalog/product/dtos/product-create.dto';
+import { UpdateProductDto } from '@app/catalog/product/dtos/product-update.dto';
+import { ProductFindQueryDto } from '@app/catalog/product/dtos/product-query.dto';
 import {
   ProductBriefDto,
   ProductDetailDto,
   ProductListResultDto,
-} from './dtos/product-response.dto';
-import { ProductIdBodyDto, ProductIdParamDto } from './dtos/product-id.dto';
-
-// اگر گارد احراز هویت داری، اینجا ایمپورت و استفاده کن.
-// این نمونه‌ی خنثی است؛ در پروژه‌ی واقعی‌ات از AuthGuard('jwt') استفاده کن.
-class OptionalAuthGuard {}
-class AuthGuardRequired {} // جایگزین با AuthGuard('jwt')
+} from '@app/catalog/product/dtos/product-response.dto';
+import { ProductIdParamDto } from '@app/catalog/product/dtos/product-id.dto';
+import {
+  normalizeFaText,
+  safeDecodeSlug,
+} from '@shared-slug/slug/fa-slug.util';
 
-function buildActor(req: any): Actor {
-  // سازگار با استراتژی‌های JWT سفارشی شما
-  const user = req?.user;
+function requireActor(user: CurrentUserPayload | undefined): Actor {
+  if (!user) {
+    throw new ForbiddenException('Authentication required.');
+  }
   return {
-    id: user?.sub ?? user?.id ?? 'anonymous',
-    isAdmin: Boolean(user?.roles?.includes?.('admin') || user?.isAdmin),
+    id: user.id,
+    isAdmin: Boolean(user.roles?.includes(RoleName.admin)),
   };
 }
 
@@ -53,63 +62,92 @@ function buildActor(req: any): Actor {
 export class ProductController {
   constructor(private readonly service: ProductService) {}
 
-  // -----------------------------------------------------------
-  // Create
-  // -----------------------------------------------------------
   @Post()
   @ApiBearerAuth()
-  @UseGuards(AuthGuardRequired as any)
-  @ApiOperation({ summary: 'Create a product' })
+  @ApiOperation({
+    summary: 'Create a product',
+    description:
+      'Either connect an existing ProductFile using fileId or provide file payload to create one inline.',
+  })
   @ApiCreatedResponse({ type: ProductDetailDto })
   async create(
     @Body() dto: CreateProductDto,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<ProductDetailDto> {
-    const actor = buildActor(req);
+    const actor = requireActor(user);
     return this.service.create(dto, actor);
   }
 
-  // -----------------------------------------------------------
-  // Update
-  // -----------------------------------------------------------
   @Patch(':idOrSlug')
   @ApiBearerAuth()
-  @UseGuards(AuthGuardRequired as any)
-  @ApiOperation({ summary: 'Update a product (partial)' })
+  @ApiOperation({
+    summary: 'Update a product (partial)',
+    description:
+      'Supports switching ProductFile via fileId, creating a new file inline, or disconnecting the current file (fileId: null).',
+  })
   @ApiOkResponse({ type: ProductDetailDto })
   async update(
     @Param() params: ProductIdParamDto,
     @Body() dto: UpdateProductDto,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<ProductDetailDto> {
-    const actor = buildActor(req);
+    const actor = requireActor(user);
     return this.service.update(params.idOrSlug, dto, actor);
   }
 
-  // -----------------------------------------------------------
-  // Find One
-  // -----------------------------------------------------------
-  @Get(':idOrSlug')
-  @UseGuards(OptionalAuthGuard as any)
-  @ApiOperation({ summary: 'Get a product by id or slug' })
+  @Get('id/:id')
+  @Public()
+  @ApiOperation({ summary: 'Get a product by numeric id' })
   @ApiOkResponse({ type: ProductDetailDto })
-  async findOne(
-    @Param() params: ProductIdParamDto,
-    @Req() req: any,
+  @ApiParam({ name: 'id', example: '1001', description: 'Product id' })
+  async findById(
+    @Param('id') id: string,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<ProductDetailDto> {
-    const viewerId: string | undefined = req?.user?.sub ?? req?.user?.id;
-    return this.service.findOne(params.idOrSlug, viewerId);
+    const viewerId = user?.id;
+    return this.service.findByIdOrSlug(id, viewerId);
+  }
+
+  @Get(':slug')
+  @Public()
+  @ApiOperation({
+    summary: 'Get a product by slug (Persian-safe)',
+    description:
+      'Decodes and normalizes the slug, returning a 301 redirect when the slug changed.',
+  })
+  @ApiOkResponse({ type: ProductDetailDto })
+  @ApiResponse({
+    status: 301,
+    description: 'Redirect to the canonical slug when an old slug is used',
+  })
+  @ApiParam({
+    name: 'slug',
+    example: 'نقاشی-و-تصویرسازی',
+    description: 'Product slug',
+  })
+  async findBySlug(
+    @Param('slug') slugParam: string,
+    @Res({ passthrough: true }) res: Response,
+    @CurrentUser() user: CurrentUserPayload | undefined,
+  ): Promise<ProductDetailDto | undefined> {
+    const normalized = normalizeFaText(safeDecodeSlug(slugParam));
+    const result = await this.service.findBySlug(normalized, user?.id);
+    if (result.redirectTo) {
+      res.redirect(
+        HttpStatus.MOVED_PERMANENTLY,
+        `/catalog/products/${encodeURIComponent(result.redirectTo)}`,
+      );
+      return undefined;
+    }
+    return result.product;
   }
 
-  // -----------------------------------------------------------
-  // Find All (Load More)
-  // -----------------------------------------------------------
   @Get()
-  @UseGuards(OptionalAuthGuard as any)
+  @Public()
   @ApiOperation({
     summary: 'List products (cursor-based "Load more")',
     description:
-      'Supports filters (q, categoryId, tagId, authorId, pricingType, graphicFormat, status) and sort (latest|popular|viewed|liked).',
+      'Supports filters (q, categoryId, tagId, topicId, authorId, pricingType, graphicFormat, status, color, hasFile, hasAssets) and sort (latest|popular|viewed|liked).',
   })
   @ApiOkResponse({ type: ProductListResultDto })
   async findAll(
@@ -118,85 +156,70 @@ export class ProductController {
     return this.service.findAll(q);
   }
 
-  // -----------------------------------------------------------
-  // Remove (Archive)
-  // -----------------------------------------------------------
   @Delete(':idOrSlug')
   @ApiBearerAuth()
-  @UseGuards(AuthGuardRequired as any)
   @ApiOperation({ summary: 'Archive a product (soft remove)' })
   @ApiOkResponse({ type: ProductDetailDto })
   async remove(
     @Param() params: ProductIdParamDto,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
   ): Promise<ProductDetailDto> {
-    const actor = buildActor(req);
+    const actor = requireActor(user);
     return this.service.remove(params.idOrSlug, actor);
   }
 
-  // -----------------------------------------------------------
-  // Toggle Like
-  // -----------------------------------------------------------
   @Post(':id/like')
   @ApiBearerAuth()
-  @UseGuards(AuthGuardRequired as any)
   @ApiOperation({ summary: 'Toggle like for current user' })
   @ApiOkResponse({ schema: { properties: { liked: { type: 'boolean' } } } })
-  async toggleLike(@Param('id') id: string, @Req() req: any) {
-    const userId: string = req?.user?.sub ?? req?.user?.id;
-    return this.service.toggleLike(id, userId);
+  async toggleLike(
+    @Param('id') id: string,
+    @CurrentUser() user: CurrentUserPayload | undefined,
+  ) {
+    const actor = requireActor(user);
+    return this.service.toggleLike(id, actor.id);
   }
 
-  // -----------------------------------------------------------
-  // Toggle Bookmark
-  // -----------------------------------------------------------
   @Post(':id/bookmark')
   @ApiBearerAuth()
-  @UseGuards(AuthGuardRequired as any)
   @ApiOperation({ summary: 'Toggle bookmark for current user' })
   @ApiOkResponse({
     schema: { properties: { bookmarked: { type: 'boolean' } } },
   })
-  async toggleBookmark(@Param('id') id: string, @Req() req: any) {
-    const userId: string = req?.user?.sub ?? req?.user?.id;
-    return this.service.toggleBookmark(id, userId);
+  async toggleBookmark(
+    @Param('id') id: string,
+    @CurrentUser() user: CurrentUserPayload | undefined,
+  ) {
+    const actor = requireActor(user);
+    return this.service.toggleBookmark(id, actor.id);
   }
 
-  // -----------------------------------------------------------
-  // Register Download
-  // -----------------------------------------------------------
   @Post(':id/download')
   @ApiBearerAuth()
-  @UseGuards(AuthGuardRequired as any)
   @ApiOperation({ summary: 'Register a download and increment counts' })
   @HttpCode(HttpStatus.NO_CONTENT)
   @ApiNoContentResponse()
   async registerDownload(
     @Param('id') id: string,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
     @Ip() ip: string,
-    @Headers('user-agent') ua: string,
   ): Promise<void> {
-    const userId: string = req?.user?.sub ?? req?.user?.id;
-    // اگر اندازه‌ی فایل یا مبلغ پرداختی را داری، در بدنه بگیر؛ اینجا ساده نگه داشتیم.
-    await this.service.registerDownload(id, userId, undefined, undefined, ip);
+    const actor = requireActor(user);
+    await this.service.registerDownload(id, actor.id, undefined, undefined, ip);
   }
 
-  // -----------------------------------------------------------
-  // Increment View (public)
-  // -----------------------------------------------------------
   @Post(':id/view')
-  @UseGuards(OptionalAuthGuard as any)
+  @Public()
   @ApiOperation({ summary: 'Increment a view (public endpoint)' })
   @HttpCode(HttpStatus.NO_CONTENT)
   @ApiNoContentResponse()
   async incrementViewPublic(
     @Param('id') id: string,
-    @Req() req: any,
+    @CurrentUser() user: CurrentUserPayload | undefined,
     @Ip() ip: string,
     @Headers('user-agent') ua: string,
   ): Promise<void> {
-    const viewerId: string | undefined = req?.user?.sub ?? req?.user?.id;
+    const viewerId: string | undefined = user?.id;
     await this.service.incrementView(BigInt(id), viewerId, ip, ua);
   }
 }
diff --git a/apps/api/src/catalog/storage/local-storage.service.ts b/apps/api/src/catalog/storage/local-storage.service.ts
index 4b5dab7..df8c6ba 100644
--- a/apps/api/src/catalog/storage/local-storage.service.ts
+++ b/apps/api/src/catalog/storage/local-storage.service.ts
@@ -3,7 +3,7 @@ import { mkdir, unlink, writeFile } from 'node:fs/promises';
 import { join, dirname, extname } from 'node:path';
 import { randomUUID } from 'node:crypto';
 import { Injectable, Logger } from '@nestjs/common';
-import { StorageService, StoredFileMetadata, UploadedFile } from './storage.service';
+import { StorageService, StoredFileMetadata, UploadedFile } from '@app/catalog/storage/storage.service';
 
 @Injectable()
 export class LocalStorageService extends StorageService {
diff --git a/apps/api/src/catalog/storage/s3-storage.service.ts b/apps/api/src/catalog/storage/s3-storage.service.ts
index fc31f7d..614bd10 100644
--- a/apps/api/src/catalog/storage/s3-storage.service.ts
+++ b/apps/api/src/catalog/storage/s3-storage.service.ts
@@ -1,6 +1,6 @@
 import { Injectable } from '@nestjs/common';
 import { Readable } from 'node:stream';
-import { StorageService, StoredFileMetadata, UploadedFile } from './storage.service';
+import { StorageService, StoredFileMetadata, UploadedFile } from '@app/catalog/storage/storage.service';
 
 @Injectable()
 export class S3StorageService extends StorageService {
diff --git a/apps/api/src/catalog/storage/storage.service.ts b/apps/api/src/catalog/storage/storage.service.ts
index b4f42c7..661561c 100644
--- a/apps/api/src/catalog/storage/storage.service.ts
+++ b/apps/api/src/catalog/storage/storage.service.ts
@@ -1,31 +1,31 @@
-import type { Readable } from 'node:stream';
-
-export interface StoredFileMetadata {
-  storageKey: string;
-  originalName?: string;
-  size?: number;
-  mimeType?: string;
-  meta?: Record<string, unknown>;
-}
-
-export interface UploadedFile {
-  fieldname: string;
-  originalname?: string;
-  encoding?: string;
-  mimetype?: string;
-  size?: number;
-  buffer?: Buffer;
-  stream?: Readable;
-}
-
-export abstract class StorageService {
-  abstract saveUploadedFile(
-    file: UploadedFile,
-  ): Promise<StoredFileMetadata>;
-
-  abstract getDownloadStream(storageKey: string): Readable;
-
-  abstract getDownloadUrl(storageKey: string): string;
-
-  abstract deleteFile(storageKey: string): Promise<void>;
-}
+import type { Readable } from 'node:stream';
+
+export interface StoredFileMetadata {
+  storageKey: string;
+  originalName?: string;
+  size?: number;
+  mimeType?: string;
+  meta?: Record<string, unknown>;
+}
+
+export interface UploadedFile {
+  fieldname: string;
+  originalname?: string;
+  encoding?: string;
+  mimetype?: string;
+  size?: number;
+  buffer?: Buffer;
+  stream?: Readable;
+}
+
+export abstract class StorageService {
+  abstract saveUploadedFile(
+    file: UploadedFile,
+  ): Promise<StoredFileMetadata>;
+
+  abstract getDownloadStream(storageKey: string): Readable;
+
+  abstract getDownloadUrl(storageKey: string): string;
+
+  abstract deleteFile(storageKey: string): Promise<void>;
+}
diff --git a/apps/api/src/catalog/tags/dtos/tag-create.dto.ts b/apps/api/src/catalog/tags/dtos/tag-create.dto.ts
index 2bee9ad..964e29a 100644
--- a/apps/api/src/catalog/tags/dtos/tag-create.dto.ts
+++ b/apps/api/src/catalog/tags/dtos/tag-create.dto.ts
@@ -1,24 +1,24 @@
-import { ApiProperty } from '@nestjs/swagger';
-import { IsNotEmpty, IsOptional, IsString, MaxLength } from 'class-validator';
-
-export class CreateTagDto {
-  @ApiProperty({
-    description: 'Display name of the tag',
-    example: 'dashboard',
-  })
-  @IsString()
-  @IsNotEmpty()
-  @MaxLength(50)
-  name: string;
-
-  @ApiProperty({
-    description: 'Optional slug, generated automatically if omitted',
-    required: false,
-    example: 'dashboard',
-  })
-  @IsOptional()
-  @IsString()
-  @MaxLength(50)
-  slug?: string;
-}
-
+import { ApiProperty } from '@nestjs/swagger';
+import { IsNotEmpty, IsOptional, IsString, MaxLength } from 'class-validator';
+
+export class CreateTagDto {
+  @ApiProperty({
+    description: 'Display name of the tag',
+    example: 'dashboard',
+  })
+  @IsString()
+  @IsNotEmpty()
+  @MaxLength(50)
+  name: string;
+
+  @ApiProperty({
+    description: 'Optional slug, generated automatically if omitted',
+    required: false,
+    example: 'dashboard',
+  })
+  @IsOptional()
+  @IsString()
+  @MaxLength(50)
+  slug?: string;
+}
+
diff --git a/apps/api/src/catalog/tags/dtos/tag-query.dto.ts b/apps/api/src/catalog/tags/dtos/tag-query.dto.ts
index c029bac..664dc32 100644
--- a/apps/api/src/catalog/tags/dtos/tag-query.dto.ts
+++ b/apps/api/src/catalog/tags/dtos/tag-query.dto.ts
@@ -1,31 +1,31 @@
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import {
-  IsBooleanString,
-  IsInt,
-  IsOptional,
-  IsString,
-  Max,
-  Min,
-} from 'class-validator';
-
-export class TagFindQueryDto {
-  @ApiPropertyOptional({ example: 'vector' })
-  @IsOptional()
-  @IsString()
-  q?: string;
-
-  @ApiPropertyOptional({
-    example: 'true',
-    description: 'فقط تگ‌هایی که حداقل یک محصول دارند',
-  })
-  @IsOptional()
-  @IsBooleanString()
-  usedOnly?: string;
-
-  @ApiPropertyOptional({ minimum: 1, maximum: 200, example: 100 })
-  @IsOptional()
-  @IsInt()
-  @Min(1)
-  @Max(200)
-  limit?: number;
-}
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import {
+  IsBooleanString,
+  IsInt,
+  IsOptional,
+  IsString,
+  Max,
+  Min,
+} from 'class-validator';
+
+export class TagFindQueryDto {
+  @ApiPropertyOptional({ example: 'vector' })
+  @IsOptional()
+  @IsString()
+  q?: string;
+
+  @ApiPropertyOptional({
+    example: 'true',
+    description: 'فقط تگ‌هایی که حداقل یک محصول دارند',
+  })
+  @IsOptional()
+  @IsBooleanString()
+  usedOnly?: string;
+
+  @ApiPropertyOptional({ minimum: 1, maximum: 200, example: 100 })
+  @IsOptional()
+  @IsInt()
+  @Min(1)
+  @Max(200)
+  limit?: number;
+}
diff --git a/apps/api/src/catalog/tags/dtos/tag-response.dto.ts b/apps/api/src/catalog/tags/dtos/tag-response.dto.ts
index e3d4320..5072a18 100644
--- a/apps/api/src/catalog/tags/dtos/tag-response.dto.ts
+++ b/apps/api/src/catalog/tags/dtos/tag-response.dto.ts
@@ -1,12 +1,12 @@
-import { ApiProperty } from '@nestjs/swagger';
-
-export class TagDto {
-  @ApiProperty() id!: string; // BigInt → string
-  @ApiProperty() name!: string;
-  @ApiProperty() slug!: string;
-  @ApiProperty({ example: 12 }) usageCount!: number; // تعداد محصولات
-}
-
-export class TagListResultDto {
-  @ApiProperty({ type: [TagDto] }) items!: TagDto[];
-}
+import { ApiProperty } from '@nestjs/swagger';
+
+export class TagDto {
+  @ApiProperty() id!: string; // BigInt → string
+  @ApiProperty() name!: string;
+  @ApiProperty() slug!: string;
+  @ApiProperty({ example: 12 }) usageCount!: number; // تعداد محصولات
+}
+
+export class TagListResultDto {
+  @ApiProperty({ type: [TagDto] }) items!: TagDto[];
+}
diff --git a/apps/api/src/catalog/tags/dtos/tag-update.dto.ts b/apps/api/src/catalog/tags/dtos/tag-update.dto.ts
index bd3f766..15b8837 100644
--- a/apps/api/src/catalog/tags/dtos/tag-update.dto.ts
+++ b/apps/api/src/catalog/tags/dtos/tag-update.dto.ts
@@ -1,16 +1,16 @@
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import { IsOptional, IsString, Length } from 'class-validator';
-
-export class UpdateTagDto {
-  @ApiPropertyOptional()
-  @IsOptional()
-  @IsString()
-  @Length(2, 255)
-  name?: string;
-
-  @ApiPropertyOptional()
-  @IsOptional()
-  @IsString()
-  @Length(2, 255)
-  slug?: string;
-}
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import { IsOptional, IsString, Length } from 'class-validator';
+
+export class UpdateTagDto {
+  @ApiPropertyOptional()
+  @IsOptional()
+  @IsString()
+  @Length(2, 255)
+  name?: string;
+
+  @ApiPropertyOptional()
+  @IsOptional()
+  @IsString()
+  @Length(2, 255)
+  slug?: string;
+}
diff --git a/apps/api/src/catalog/tags/tag.mapper.ts b/apps/api/src/catalog/tags/tag.mapper.ts
index 1a47a80..776e5f3 100644
--- a/apps/api/src/catalog/tags/tag.mapper.ts
+++ b/apps/api/src/catalog/tags/tag.mapper.ts
@@ -1,5 +1,5 @@
 import { Prisma } from '@prisma/client';
-import { TagDto } from './dtos/tag-response.dto';
+import { TagDto } from '@app/catalog/tags/dtos/tag-response.dto';
 
 export type TagWithCount = Prisma.TagGetPayload<{
   include: { _count: { select: { productLinks: true } } };
diff --git a/apps/api/src/catalog/tags/tags.controller.ts b/apps/api/src/catalog/tags/tags.controller.ts
index ef6db9f..b3b97ef 100644
--- a/apps/api/src/catalog/tags/tags.controller.ts
+++ b/apps/api/src/catalog/tags/tags.controller.ts
@@ -16,12 +16,15 @@ import {
   ApiTags,
   ApiCreatedResponse,
   ApiNoContentResponse,
+  ApiBearerAuth,
 } from '@nestjs/swagger';
-import { TagsService } from './tags.service';
-import { CreateTagDto } from './dtos/tag-create.dto';
-import { UpdateTagDto } from './dtos/tag-update.dto';
-import { TagFindQueryDto } from './dtos/tag-query.dto';
-import { TagDto, TagListResultDto } from './dtos/tag-response.dto';
+import { RoleName } from '@prisma/client';
+import { Roles } from '@app/common/decorators/roles.decorator';
+import { TagsService } from '@app/catalog/tags/tags.service';
+import { CreateTagDto } from '@app/catalog/tags/dtos/tag-create.dto';
+import { UpdateTagDto } from '@app/catalog/tags/dtos/tag-update.dto';
+import { TagFindQueryDto } from '@app/catalog/tags/dtos/tag-query.dto';
+import { TagDto, TagListResultDto } from '@app/catalog/tags/dtos/tag-response.dto';
 
 @ApiTags('Catalog / Tags')
 @Controller('catalog/tags')
@@ -29,6 +32,8 @@ export class TagsController {
   constructor(private readonly service: TagsService) {}
 
   @Post()
+  @ApiBearerAuth()
+  @Roles(RoleName.admin)
   @ApiOperation({ summary: 'Create a tag' })
   @ApiCreatedResponse({ type: TagDto })
   async create(@Body() dto: CreateTagDto): Promise<TagDto> {
@@ -36,6 +41,8 @@ export class TagsController {
   }
 
   @Patch(':id')
+  @ApiBearerAuth()
+  @Roles(RoleName.admin)
   @ApiOperation({ summary: 'Update a tag' })
   @ApiOkResponse({ type: TagDto })
   async update(
@@ -67,6 +74,8 @@ export class TagsController {
   }
 
   @Delete(':id')
+  @ApiBearerAuth()
+  @Roles(RoleName.admin)
   @ApiOperation({ summary: 'Delete a tag (removes product links first)' })
   @HttpCode(HttpStatus.NO_CONTENT)
   @ApiNoContentResponse()
diff --git a/apps/api/src/catalog/tags/tags.service.ts b/apps/api/src/catalog/tags/tags.service.ts
index eee591d..a178f00 100644
--- a/apps/api/src/catalog/tags/tags.service.ts
+++ b/apps/api/src/catalog/tags/tags.service.ts
@@ -4,12 +4,12 @@ import {
   NotFoundException,
 } from '@nestjs/common';
 import { Prisma } from '@prisma/client';
-import { PrismaService } from '../../prisma/prisma.service';
-import { CreateTagDto } from './dtos/tag-create.dto';
-import { UpdateTagDto } from './dtos/tag-update.dto';
-import { TagFindQueryDto } from './dtos/tag-query.dto';
-import { TagDto, TagListResultDto } from './dtos/tag-response.dto';
-import { TagMapper, TagWithCount } from './tag.mapper';
+import { PrismaService } from '@app/prisma/prisma.service';
+import { CreateTagDto } from '@app/catalog/tags/dtos/tag-create.dto';
+import { UpdateTagDto } from '@app/catalog/tags/dtos/tag-update.dto';
+import { TagFindQueryDto } from '@app/catalog/tags/dtos/tag-query.dto';
+import { TagDto, TagListResultDto } from '@app/catalog/tags/dtos/tag-response.dto';
+import { TagMapper, TagWithCount } from '@app/catalog/tags/tag.mapper';
 
 /* ---------- helpers ---------- */
 function slugify(s: string): string {
diff --git a/apps/api/src/catalog/utils/pagination.util.ts b/apps/api/src/catalog/utils/pagination.util.ts
index 92b18c7..dd7baca 100644
--- a/apps/api/src/catalog/utils/pagination.util.ts
+++ b/apps/api/src/catalog/utils/pagination.util.ts
@@ -1,36 +1,36 @@
-export interface PaginationResult<T> {
-  data: T[];
-  total: number;
-  page: number;
-  limit: number;
-  hasNext: boolean;
-}
-
-export const MAX_LIMIT = 100;
-
-export function clampPagination(
-  page: number | undefined,
-  limit: number | undefined,
-  maxLimit = MAX_LIMIT,
-): { page: number; limit: number; skip: number } {
-  const safePage = page && page > 0 ? page : 1;
-  const safeLimit =
-    limit && limit > 0 ? Math.min(limit, maxLimit) : Math.min(24, maxLimit);
-  const skip = (safePage - 1) * safeLimit;
-  return { page: safePage, limit: safeLimit, skip };
-}
-
-export function toPaginationResult<T>(
-  data: T[],
-  total: number,
-  page: number,
-  limit: number,
-): PaginationResult<T> {
-  return {
-    data,
-    total,
-    page,
-    limit,
-    hasNext: page * limit < total,
-  };
-}
+export interface PaginationResult<T> {
+  data: T[];
+  total: number;
+  page: number;
+  limit: number;
+  hasNext: boolean;
+}
+
+export const MAX_LIMIT = 100;
+
+export function clampPagination(
+  page: number | undefined,
+  limit: number | undefined,
+  maxLimit = MAX_LIMIT,
+): { page: number; limit: number; skip: number } {
+  const safePage = page && page > 0 ? page : 1;
+  const safeLimit =
+    limit && limit > 0 ? Math.min(limit, maxLimit) : Math.min(24, maxLimit);
+  const skip = (safePage - 1) * safeLimit;
+  return { page: safePage, limit: safeLimit, skip };
+}
+
+export function toPaginationResult<T>(
+  data: T[],
+  total: number,
+  page: number,
+  limit: number,
+): PaginationResult<T> {
+  return {
+    data,
+    total,
+    page,
+    limit,
+    hasNext: page * limit < total,
+  };
+}
diff --git a/apps/api/src/catalog/utils/slug.util.ts b/apps/api/src/catalog/utils/slug.util.ts
index 998b27b..eb96d26 100644
--- a/apps/api/src/catalog/utils/slug.util.ts
+++ b/apps/api/src/catalog/utils/slug.util.ts
@@ -1,22 +1,22 @@
-import { randomInt } from 'node:crypto';
-
-const MAX_RANDOM = 9999;
-
-export function slugify(input: string): string {
-  return input
-    .toLowerCase()
-    .replace(/[^a-z0-9]+/g, '-')
-    .replace(/^-+|-+$/g, '')
-    .replace(/-{2,}/g, '-');
-}
-
-export function buildUniqueSlugCandidate(base: string, attempt = 0): string {
-  if (attempt === 0) {
-    return slugify(base);
-  }
-  const suffix = (attempt < 5 ? attempt : randomInt(1, MAX_RANDOM + 1))
-    .toString()
-    .padStart(attempt < 5 ? 0 : 4, '0');
-  return `${slugify(base)}-${suffix}`;
-}
-
+import { randomInt } from 'node:crypto';
+
+const MAX_RANDOM = 9999;
+
+export function slugify(input: string): string {
+  return input
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, '-')
+    .replace(/^-+|-+$/g, '')
+    .replace(/-{2,}/g, '-');
+}
+
+export function buildUniqueSlugCandidate(base: string, attempt = 0): string {
+  if (attempt === 0) {
+    return slugify(base);
+  }
+  const suffix = (attempt < 5 ? attempt : randomInt(1, MAX_RANDOM + 1))
+    .toString()
+    .padStart(attempt < 5 ? 0 : 4, '0');
+  return `${slugify(base)}-${suffix}`;
+}
+
diff --git a/apps/api/src/common/decorators/current-user.decorator.ts b/apps/api/src/common/decorators/current-user.decorator.ts
index 2812a96..dd8df79 100644
--- a/apps/api/src/common/decorators/current-user.decorator.ts
+++ b/apps/api/src/common/decorators/current-user.decorator.ts
@@ -1,26 +1,26 @@
-/**
- * Provides access to the `request.user` payload assigned by authentication guards.
- */
-import { createParamDecorator, ExecutionContext } from '@nestjs/common';
-import { Request } from 'express';
-
-/**
- * Shape of the minimal user context that guards attach to Express requests.
- */
-export interface CurrentUserPayload {
-  id: string;
-  roles: string[];
-  username?: string;
-}
-
-/**
- * Parameter decorator that resolves the authenticated user context, if available.
- */
-export const CurrentUser = createParamDecorator(
-  (_data: unknown, context: ExecutionContext): CurrentUserPayload | undefined => {
-    const request = context
-      .switchToHttp()
-      .getRequest<Request & { user?: CurrentUserPayload }>();
-    return request.user;
-  },
-);
+/**
+ * Provides access to the `request.user` payload assigned by authentication guards.
+ */
+import { createParamDecorator, ExecutionContext } from '@nestjs/common';
+import { Request } from 'express';
+
+/**
+ * Shape of the minimal user context that guards attach to Express requests.
+ */
+export interface CurrentUserPayload {
+  id: string;
+  roles: string[];
+  username?: string;
+}
+
+/**
+ * Parameter decorator that resolves the authenticated user context, if available.
+ */
+export const CurrentUser = createParamDecorator(
+  (_data: unknown, context: ExecutionContext): CurrentUserPayload | undefined => {
+    const request = context
+      .switchToHttp()
+      .getRequest<Request & { user?: CurrentUserPayload }>();
+    return request.user;
+  },
+);
diff --git a/apps/api/src/common/decorators/public.decorator.ts b/apps/api/src/common/decorators/public.decorator.ts
index 767ac49..401d75c 100644
--- a/apps/api/src/common/decorators/public.decorator.ts
+++ b/apps/api/src/common/decorators/public.decorator.ts
@@ -1,5 +1,5 @@
-import { SetMetadata } from '@nestjs/common';
-
-export const IS_PUBLIC_KEY = 'isPublic';
-
-export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
+import { SetMetadata } from '@nestjs/common';
+
+export const IS_PUBLIC_KEY = 'isPublic';
+
+export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
diff --git a/apps/api/src/common/decorators/roles.decorator.ts b/apps/api/src/common/decorators/roles.decorator.ts
index 9938274..9c29454 100644
--- a/apps/api/src/common/decorators/roles.decorator.ts
+++ b/apps/api/src/common/decorators/roles.decorator.ts
@@ -1,15 +1,15 @@
-/**
- * Decorator helpers to declare required role names on route handlers for RolesGuard.
- */
-import { SetMetadata } from '@nestjs/common';
-import { RoleName } from '@prisma/client';
-
-/**
- * Metadata key used to store role requirements on route handlers.
- */
-export const ROLES_KEY = 'roles';
-
-/**
- * Marks a controller/handler as requiring the listed roles for access.
- */
-export const Roles = (...roles: RoleName[]) => SetMetadata(ROLES_KEY, roles);
+/**
+ * Decorator helpers to declare required role names on route handlers for RolesGuard.
+ */
+import { SetMetadata } from '@nestjs/common';
+import { RoleName } from '@prisma/client';
+
+/**
+ * Metadata key used to store role requirements on route handlers.
+ */
+export const ROLES_KEY = 'roles';
+
+/**
+ * Marks a controller/handler as requiring the listed roles for access.
+ */
+export const Roles = (...roles: RoleName[]) => SetMetadata(ROLES_KEY, roles);
diff --git a/apps/api/src/common/filters/http-exception.filter.ts b/apps/api/src/common/filters/http-exception.filter.ts
index 93f2e67..afbdf72 100644
--- a/apps/api/src/common/filters/http-exception.filter.ts
+++ b/apps/api/src/common/filters/http-exception.filter.ts
@@ -1,69 +1,69 @@
-import {
-  ArgumentsHost,
-  Catch,
-  ExceptionFilter,
-  HttpException,
-  HttpStatus,
-  Logger,
-} from '@nestjs/common';
-import { Request, Response } from 'express';
-import { randomUUID } from 'node:crypto';
-
-@Catch()
-export class HttpExceptionFilter implements ExceptionFilter {
-  private readonly logger = new Logger(HttpExceptionFilter.name);
-
-  catch(exception: unknown, host: ArgumentsHost) {
-    const ctx = host.switchToHttp();
-    const response = ctx.getResponse<Response>();
-    const request = ctx.getRequest<Request & { txId?: string }>();
-
-    let status = HttpStatus.INTERNAL_SERVER_ERROR;
-    let message = 'Internal server error';
-    let code = 'INTERNAL_SERVER_ERROR';
-    let stack: string | undefined;
-
-    if (exception instanceof HttpException) {
-      status = exception.getStatus();
-
-      const res = exception.getResponse();
-      if (typeof res === 'string') {
-        message = res;
-      } else if (res && typeof res === 'object') {
-        const responseObject = res as Record<string, unknown>;
-        message =
-          (responseObject.message as string) ??
-          (Array.isArray(responseObject.message)
-            ? (responseObject.message.join(', ') as string)
-            : message);
-        code =
-          (responseObject['code'] as string) ??
-          (responseObject['error'] as string) ??
-          code;
-      } else {
-        message = exception.message;
-      }
-
-      stack = exception.stack;
-    } else if (exception instanceof Error) {
-      message = exception.message;
-      stack = exception.stack;
-    }
-
-    const traceId = request.txId ?? randomUUID();
-
-    this.logger.error(
-      `traceId=${traceId} status=${status} message=${message}`,
-      stack,
-    );
-
-    response.status(status).json({
-      success: false,
-      error: {
-        code,
-        message,
-      },
-      traceId,
-    });
-  }
-}
+import {
+  ArgumentsHost,
+  Catch,
+  ExceptionFilter,
+  HttpException,
+  HttpStatus,
+  Logger,
+} from '@nestjs/common';
+import { Request, Response } from 'express';
+import { randomUUID } from 'node:crypto';
+
+@Catch()
+export class HttpExceptionFilter implements ExceptionFilter {
+  private readonly logger = new Logger(HttpExceptionFilter.name);
+
+  catch(exception: unknown, host: ArgumentsHost) {
+    const ctx = host.switchToHttp();
+    const response = ctx.getResponse<Response>();
+    const request = ctx.getRequest<Request & { txId?: string }>();
+
+    let status = HttpStatus.INTERNAL_SERVER_ERROR;
+    let message = 'Internal server error';
+    let code = 'INTERNAL_SERVER_ERROR';
+    let stack: string | undefined;
+
+    if (exception instanceof HttpException) {
+      status = exception.getStatus();
+
+      const res = exception.getResponse();
+      if (typeof res === 'string') {
+        message = res;
+      } else if (res && typeof res === 'object') {
+        const responseObject = res as Record<string, unknown>;
+        message =
+          (responseObject.message as string) ??
+          (Array.isArray(responseObject.message)
+            ? (responseObject.message.join(', ') as string)
+            : message);
+        code =
+          (responseObject['code'] as string) ??
+          (responseObject['error'] as string) ??
+          code;
+      } else {
+        message = exception.message;
+      }
+
+      stack = exception.stack;
+    } else if (exception instanceof Error) {
+      message = exception.message;
+      stack = exception.stack;
+    }
+
+    const traceId = request.txId ?? randomUUID();
+
+    this.logger.error(
+      `traceId=${traceId} status=${status} message=${message}`,
+      stack,
+    );
+
+    response.status(status).json({
+      success: false,
+      error: {
+        code,
+        message,
+      },
+      traceId,
+    });
+  }
+}
diff --git a/apps/api/src/common/guards/roles.guard.ts b/apps/api/src/common/guards/roles.guard.ts
index f2868ee..94e9031 100644
--- a/apps/api/src/common/guards/roles.guard.ts
+++ b/apps/api/src/common/guards/roles.guard.ts
@@ -9,8 +9,8 @@ import {
 } from '@nestjs/common';
 import { Reflector } from '@nestjs/core';
 import { Request } from 'express';
-import { CurrentUserPayload } from '../decorators/current-user.decorator';
-import { ROLES_KEY } from '../decorators/roles.decorator';
+import { CurrentUserPayload } from '@app/common/decorators/current-user.decorator';
+import { ROLES_KEY } from '@app/common/decorators/roles.decorator';
 import { RoleName } from '@prisma/client';
 
 @Injectable()
diff --git a/apps/api/src/common/interceptors/no-cache.interceptor.ts b/apps/api/src/common/interceptors/no-cache.interceptor.ts
index 98aadb6..331545f 100644
--- a/apps/api/src/common/interceptors/no-cache.interceptor.ts
+++ b/apps/api/src/common/interceptors/no-cache.interceptor.ts
@@ -1,24 +1,24 @@
-import {
-  CallHandler,
-  ExecutionContext,
-  Injectable,
-  NestInterceptor,
-} from '@nestjs/common';
-import { Response } from 'express';
-import { Observable } from 'rxjs';
-
-/**
- * Forces downstream clients and proxies to avoid caching the response payload.
- */
-@Injectable()
-export class NoCacheInterceptor implements NestInterceptor {
-  intercept(context: ExecutionContext, next: CallHandler): Observable<unknown> {
-    const response = context.switchToHttp().getResponse<Response>();
-
-    response.setHeader('Cache-Control', 'no-store');
-    response.setHeader('Pragma', 'no-cache');
-    response.setHeader('Expires', '0');
-
-    return next.handle();
-  }
-}
+import {
+  CallHandler,
+  ExecutionContext,
+  Injectable,
+  NestInterceptor,
+} from '@nestjs/common';
+import { Response } from 'express';
+import { Observable } from 'rxjs';
+
+/**
+ * Forces downstream clients and proxies to avoid caching the response payload.
+ */
+@Injectable()
+export class NoCacheInterceptor implements NestInterceptor {
+  intercept(context: ExecutionContext, next: CallHandler): Observable<unknown> {
+    const response = context.switchToHttp().getResponse<Response>();
+
+    response.setHeader('Cache-Control', 'no-store');
+    response.setHeader('Pragma', 'no-cache');
+    response.setHeader('Expires', '0');
+
+    return next.handle();
+  }
+}
diff --git a/apps/api/src/common/interceptors/tracing.interceptor.ts b/apps/api/src/common/interceptors/tracing.interceptor.ts
index a21bb9b..57dc37e 100644
--- a/apps/api/src/common/interceptors/tracing.interceptor.ts
+++ b/apps/api/src/common/interceptors/tracing.interceptor.ts
@@ -1,88 +1,88 @@
-import {
-  CallHandler,
-  ExecutionContext,
-  HttpException,
-  Injectable,
-  Logger,
-  NestInterceptor,
-} from '@nestjs/common';
-import { Request, Response } from 'express';
-import { randomUUID } from 'node:crypto';
-import { Observable, throwError } from 'rxjs';
-import { catchError, finalize, tap } from 'rxjs/operators';
-import { requestTraceStorage } from '@app/common/tracing/request-trace';
-
-@Injectable()
-export class TracingInterceptor implements NestInterceptor {
-  private readonly logger = new Logger(TracingInterceptor.name);
-
-  intercept(context: ExecutionContext, next: CallHandler): Observable<unknown> {
-    const httpContext = context.switchToHttp();
-    const request = httpContext.getRequest<
-      Request & { txId?: string; user?: { id?: string } }
-    >();
-    const response = httpContext.getResponse<Response>();
-
-    const txId = request.txId ?? randomUUID();
-    request.txId = txId;
-    response.setHeader('x-trace-id', txId);
-
-    const userId = request.user?.id ?? 'anonymous';
-    const { method, originalUrl } = request;
-
-    this.logger.log(
-      `traceId=${txId} userId=${userId} start method=${method} url=${originalUrl}`,
-    );
-
-    const startTime = Date.now();
-
-    return requestTraceStorage.run(
-      { traceId: txId, userId },
-      () => {
-        let finalStatus: number | undefined;
-        let capturedError: unknown;
-
-        return next.handle().pipe(
-          tap(() => {
-            finalStatus = response.statusCode;
-          }),
-          catchError((error: unknown) => {
-            capturedError = error;
-            if (error instanceof HttpException) {
-              finalStatus = error.getStatus();
-            } else if (
-              typeof (error as { status?: number }).status === 'number'
-            ) {
-              finalStatus = Number(
-                (error as { status?: number }).status ?? response.statusCode,
-              );
-            } else if (
-              typeof (error as { statusCode?: number }).statusCode === 'number'
-            ) {
-              finalStatus = Number(
-                (error as { statusCode?: number }).statusCode ??
-                  response.statusCode,
-              );
-            } else {
-              finalStatus = 500;
-            }
-            return throwError(() => error);
-          }),
-          finalize(() => {
-            const durationMs = Date.now() - startTime;
-            const status = finalStatus ?? response.statusCode;
-            const baseLog = `traceId=${txId} userId=${userId} method=${method} url=${originalUrl} status=${status} durationMs=${durationMs}`;
-            if (capturedError) {
-              this.logger.error(
-                baseLog,
-                capturedError instanceof Error ? capturedError.stack : undefined,
-              );
-            } else {
-              this.logger.log(baseLog);
-            }
-          }),
-        );
-      },
-    );
-  }
-}
+import {
+  CallHandler,
+  ExecutionContext,
+  HttpException,
+  Injectable,
+  Logger,
+  NestInterceptor,
+} from '@nestjs/common';
+import { Request, Response } from 'express';
+import { randomUUID } from 'node:crypto';
+import { Observable, throwError } from 'rxjs';
+import { catchError, finalize, tap } from 'rxjs/operators';
+import { requestTraceStorage } from '@app/common/tracing/request-trace';
+
+@Injectable()
+export class TracingInterceptor implements NestInterceptor {
+  private readonly logger = new Logger(TracingInterceptor.name);
+
+  intercept(context: ExecutionContext, next: CallHandler): Observable<unknown> {
+    const httpContext = context.switchToHttp();
+    const request = httpContext.getRequest<
+      Request & { txId?: string; user?: { id?: string } }
+    >();
+    const response = httpContext.getResponse<Response>();
+
+    const txId = request.txId ?? randomUUID();
+    request.txId = txId;
+    response.setHeader('x-trace-id', txId);
+
+    const userId = request.user?.id ?? 'anonymous';
+    const { method, originalUrl } = request;
+
+    this.logger.log(
+      `traceId=${txId} userId=${userId} start method=${method} url=${originalUrl}`,
+    );
+
+    const startTime = Date.now();
+
+    return requestTraceStorage.run(
+      { traceId: txId, userId },
+      () => {
+        let finalStatus: number | undefined;
+        let capturedError: unknown;
+
+        return next.handle().pipe(
+          tap(() => {
+            finalStatus = response.statusCode;
+          }),
+          catchError((error: unknown) => {
+            capturedError = error;
+            if (error instanceof HttpException) {
+              finalStatus = error.getStatus();
+            } else if (
+              typeof (error as { status?: number }).status === 'number'
+            ) {
+              finalStatus = Number(
+                (error as { status?: number }).status ?? response.statusCode,
+              );
+            } else if (
+              typeof (error as { statusCode?: number }).statusCode === 'number'
+            ) {
+              finalStatus = Number(
+                (error as { statusCode?: number }).statusCode ??
+                  response.statusCode,
+              );
+            } else {
+              finalStatus = 500;
+            }
+            return throwError(() => error);
+          }),
+          finalize(() => {
+            const durationMs = Date.now() - startTime;
+            const status = finalStatus ?? response.statusCode;
+            const baseLog = `traceId=${txId} userId=${userId} method=${method} url=${originalUrl} status=${status} durationMs=${durationMs}`;
+            if (capturedError) {
+              this.logger.error(
+                baseLog,
+                capturedError instanceof Error ? capturedError.stack : undefined,
+              );
+            } else {
+              this.logger.log(baseLog);
+            }
+          }),
+        );
+      },
+    );
+  }
+}
diff --git a/apps/api/src/common/interceptors/transform-response.interceptor.ts b/apps/api/src/common/interceptors/transform-response.interceptor.ts
index 484995f..a010e09 100644
--- a/apps/api/src/common/interceptors/transform-response.interceptor.ts
+++ b/apps/api/src/common/interceptors/transform-response.interceptor.ts
@@ -1,28 +1,28 @@
-import {
-  CallHandler,
-  ExecutionContext,
-  Injectable,
-  NestInterceptor,
-} from '@nestjs/common';
-import { Observable } from 'rxjs';
-import { map } from 'rxjs/operators';
-
-@Injectable()
-export class TransformResponseInterceptor implements NestInterceptor {
-  intercept(
-    _context: ExecutionContext,
-    next: CallHandler,
-  ): Observable<{ success: true; data: unknown }> {
-    return next.handle().pipe(
-      map((data) => {
-        if (data && typeof data === 'object' && 'success' in data) {
-          return data as { success: true; data: unknown };
-        }
-        return {
-          success: true as const,
-          data,
-        };
-      }),
-    );
-  }
-}
+import {
+  CallHandler,
+  ExecutionContext,
+  Injectable,
+  NestInterceptor,
+} from '@nestjs/common';
+import { Observable } from 'rxjs';
+import { map } from 'rxjs/operators';
+
+@Injectable()
+export class TransformResponseInterceptor implements NestInterceptor {
+  intercept(
+    _context: ExecutionContext,
+    next: CallHandler,
+  ): Observable<{ success: true; data: unknown }> {
+    return next.handle().pipe(
+      map((data) => {
+        if (data && typeof data === 'object' && 'success' in data) {
+          return data as { success: true; data: unknown };
+        }
+        return {
+          success: true as const,
+          data,
+        };
+      }),
+    );
+  }
+}
diff --git a/apps/api/src/common/pipes/parse-bigint.pipe.ts b/apps/api/src/common/pipes/parse-bigint.pipe.ts
index 31031e1..0dbd09c 100644
--- a/apps/api/src/common/pipes/parse-bigint.pipe.ts
+++ b/apps/api/src/common/pipes/parse-bigint.pipe.ts
@@ -1,25 +1,25 @@
-import {
-  ArgumentMetadata,
-  BadRequestException,
-  Injectable,
-  PipeTransform,
-} from '@nestjs/common';
-
-@Injectable()
-export class ParseBigIntPipe implements PipeTransform<string, bigint> {
-  transform(value: string, _metadata: ArgumentMetadata): bigint {
-    if (value === null || value === undefined || value === '') {
-      throw new BadRequestException('Value must be a bigint compatible string');
-    }
-
-    if (!/^-?\d+$/.test(value)) {
-      throw new BadRequestException('Validation failed (bigint string expected)');
-    }
-
-    try {
-      return BigInt(value);
-    } catch {
-      throw new BadRequestException('Validation failed (unable to parse bigint)');
-    }
-  }
-}
+import {
+  ArgumentMetadata,
+  BadRequestException,
+  Injectable,
+  PipeTransform,
+} from '@nestjs/common';
+
+@Injectable()
+export class ParseBigIntPipe implements PipeTransform<string, bigint> {
+  transform(value: string, _metadata: ArgumentMetadata): bigint {
+    if (value === null || value === undefined || value === '') {
+      throw new BadRequestException('Value must be a bigint compatible string');
+    }
+
+    if (!/^-?\d+$/.test(value)) {
+      throw new BadRequestException('Validation failed (bigint string expected)');
+    }
+
+    try {
+      return BigInt(value);
+    } catch {
+      throw new BadRequestException('Validation failed (unable to parse bigint)');
+    }
+  }
+}
diff --git a/apps/api/src/common/tracing/request-trace.ts b/apps/api/src/common/tracing/request-trace.ts
index 783ba00..d7d0181 100644
--- a/apps/api/src/common/tracing/request-trace.ts
+++ b/apps/api/src/common/tracing/request-trace.ts
@@ -1,9 +1,9 @@
-import { AsyncLocalStorage } from 'node:async_hooks';
-
-export interface RequestTraceContext {
-  traceId: string;
-  userId?: string;
-}
-
-export const requestTraceStorage =
-  new AsyncLocalStorage<RequestTraceContext>();
+import { AsyncLocalStorage } from 'node:async_hooks';
+
+export interface RequestTraceContext {
+  traceId: string;
+  userId?: string;
+}
+
+export const requestTraceStorage =
+  new AsyncLocalStorage<RequestTraceContext>();
diff --git a/apps/api/src/config/auth.config.ts b/apps/api/src/config/auth.config.ts
index 69e07bb..57cc7bb 100644
--- a/apps/api/src/config/auth.config.ts
+++ b/apps/api/src/config/auth.config.ts
@@ -1,62 +1,62 @@
-import { registerAs } from '@nestjs/config';
-import { z } from 'zod';
-import type { CookieOptions } from 'express';
-
-const booleanLike = z
-  .union([z.boolean(), z.string(), z.number()])
-  .optional()
-  .transform((value) => {
-    if (typeof value === 'boolean') {
-      return value;
-    }
-    if (typeof value === 'number') {
-      return value !== 0;
-    }
-    if (typeof value === 'string') {
-      const normalized = value.trim().toLowerCase();
-      if (normalized === 'auto') {
-        return undefined;
-      }
-      if (['1', 'true', 'yes', 'on'].includes(normalized)) {
-        return true;
-      }
-      if (['0', 'false', 'no', 'off'].includes(normalized)) {
-        return false;
-      }
-    }
-    return undefined;
-  });
-
-const ensureLeadingSlash = (value: string): string => {
-  if (!value.startsWith('/')) {
-    return `/${value}`;
-  }
-  return value;
-};
-
-const sanitizePrefix = (value?: string): string => {
-  if (!value) return '';
-  const trimmed = value.trim().replace(/^\/+|\/+$/g, '');
-  if (!trimmed) return '';
-  return `/${trimmed}`;
-};
-
-const applyPrefixIfNeeded = (path: string, prefix: string): string => {
-  const normalized = ensureLeadingSlash(path);
-  if (!prefix || normalized === '/') {
-    return normalized;
-  }
-  if (
-    normalized === prefix ||
-    normalized.startsWith(`${prefix}/`) ||
-    normalized.startsWith(`${prefix}?`)
-  ) {
-    return normalized;
-  }
-  const combined = `${prefix}/${normalized.replace(/^\//, '')}`;
-  return combined.replace(/\/{2,}/g, '/');
-};
-
+import { registerAs } from '@nestjs/config';
+import { z } from 'zod';
+import type { CookieOptions } from 'express';
+
+const booleanLike = z
+  .union([z.boolean(), z.string(), z.number()])
+  .optional()
+  .transform((value) => {
+    if (typeof value === 'boolean') {
+      return value;
+    }
+    if (typeof value === 'number') {
+      return value !== 0;
+    }
+    if (typeof value === 'string') {
+      const normalized = value.trim().toLowerCase();
+      if (normalized === 'auto') {
+        return undefined;
+      }
+      if (['1', 'true', 'yes', 'on'].includes(normalized)) {
+        return true;
+      }
+      if (['0', 'false', 'no', 'off'].includes(normalized)) {
+        return false;
+      }
+    }
+    return undefined;
+  });
+
+const ensureLeadingSlash = (value: string): string => {
+  if (!value.startsWith('/')) {
+    return `/${value}`;
+  }
+  return value;
+};
+
+const sanitizePrefix = (value?: string): string => {
+  if (!value) return '';
+  const trimmed = value.trim().replace(/^\/+|\/+$/g, '');
+  if (!trimmed) return '';
+  return `/${trimmed}`;
+};
+
+const applyPrefixIfNeeded = (path: string, prefix: string): string => {
+  const normalized = ensureLeadingSlash(path);
+  if (!prefix || normalized === '/') {
+    return normalized;
+  }
+  if (
+    normalized === prefix ||
+    normalized.startsWith(`${prefix}/`) ||
+    normalized.startsWith(`${prefix}?`)
+  ) {
+    return normalized;
+  }
+  const combined = `${prefix}/${normalized.replace(/^\//, '')}`;
+  return combined.replace(/\/{2,}/g, '/');
+};
+
 export const authEnvSchema = z.object({
   ACCESS_JWT_SECRET: z
     .string()
@@ -70,23 +70,23 @@ export const authEnvSchema = z.object({
   COOKIE_SECURE: booleanLike,
   COOKIE_REFRESH_PATH: z.string().default('/auth/refresh'),
   COOKIE_ACCESS_PATH: z.string().default('/'),
-});
-
-export type AuthEnv = z.infer<typeof authEnvSchema>;
-
-export interface AuthConfig {
-  accessSecret: string;
-  accessExpires: string;
-  refreshSecret: string;
-  refreshExpires: string;
-  cookie: {
-    sameSite: 'strict' | 'lax' | 'none';
-    secure: boolean;
-    refreshPath: string;
-    accessPath: string;
-  };
-}
-
+});
+
+export type AuthEnv = z.infer<typeof authEnvSchema>;
+
+export interface AuthConfig {
+  accessSecret: string;
+  accessExpires: string;
+  refreshSecret: string;
+  refreshExpires: string;
+  cookie: {
+    sameSite: 'strict' | 'lax' | 'none';
+    secure: boolean;
+    refreshPath: string;
+    accessPath: string;
+  };
+}
+
 export const authConfig = registerAs('auth', (): AuthConfig => {
   const raw = authEnvSchema.parse(process.env);
   const nodeEnv = (process.env.NODE_ENV ?? 'development').toLowerCase();
@@ -111,9 +111,9 @@ export const authConfig = registerAs('auth', (): AuthConfig => {
 
   return {
     accessSecret: raw.ACCESS_JWT_SECRET,
-    accessExpires: raw.ACCESS_JWT_EXPIRES,
-    refreshSecret: raw.REFRESH_JWT_SECRET,
-    refreshExpires: raw.REFRESH_JWT_EXPIRES,
+    accessExpires: raw.ACCESS_JWT_EXPIRES,
+    refreshSecret: raw.REFRESH_JWT_SECRET,
+    refreshExpires: raw.REFRESH_JWT_EXPIRES,
     cookie: {
       sameSite: raw.COOKIE_SAMESITE,
       secure,
@@ -122,20 +122,20 @@ export const authConfig = registerAs('auth', (): AuthConfig => {
     },
   };
 });
-
-export const buildCookieOptions = (
-  cookie: AuthConfig['cookie'],
-  type: 'refresh' | 'access',
-  overrides: Partial<CookieOptions> = {},
-): CookieOptions => {
-  const path =
-    type === 'refresh' ? cookie.refreshPath : cookie.accessPath || '/';
-
-  return {
-    httpOnly: true,
-    sameSite: cookie.sameSite,
-    secure: cookie.secure,
-    path,
-    ...overrides,
-  };
-};
+
+export const buildCookieOptions = (
+  cookie: AuthConfig['cookie'],
+  type: 'refresh' | 'access',
+  overrides: Partial<CookieOptions> = {},
+): CookieOptions => {
+  const path =
+    type === 'refresh' ? cookie.refreshPath : cookie.accessPath || '/';
+
+  return {
+    httpOnly: true,
+    sameSite: cookie.sameSite,
+    secure: cookie.secure,
+    path,
+    ...overrides,
+  };
+};
diff --git a/apps/api/src/config/config.module.ts b/apps/api/src/config/config.module.ts
index 5d9ec1b..27a35dc 100644
--- a/apps/api/src/config/config.module.ts
+++ b/apps/api/src/config/config.module.ts
@@ -1,7 +1,7 @@
 import { Module } from '@nestjs/common';
 import { ConfigModule } from '@nestjs/config';
 import { z } from 'zod';
-import { authConfig, AuthConfig } from './auth.config';
+import { authConfig, AuthConfig } from '@app/config/auth.config';
 
 /**
  * Base ENV schema
diff --git a/apps/api/src/core/auth/AUTH_MODULE.md b/apps/api/src/core/auth/AUTH_MODULE.md
index 7ff07b2..d4a5c25 100644
--- a/apps/api/src/core/auth/AUTH_MODULE.md
+++ b/apps/api/src/core/auth/AUTH_MODULE.md
@@ -1,205 +1,205 @@
-# 🧩 Auth Module — Negare Platform
-
-این ماژول مسئول **احراز هویت (Authentication)**، **مدیریت نشست‌ها (Sessions)** و **چرخش توکن‌ها (Token Rotation)** است.  
-ساختار آن بر پایه‌ی **NestJS + Redis + JWT** طراحی شده و تمام فلوهای ثبت‌نام، ورود، خروج و تنظیم رمز عبور را پوشش می‌دهد.
-
----
-
-## ⚙️ ماژول‌ها و سرویس‌ها
-
-### 1. **PasswordService**
-- مدیریت رمز عبور کاربران (ثبت، تغییر، ورود)
-- اعتبارسنجی کاربر با `email` یا `phone`
-- هش رمزها با `bcrypt`
-- تایید تیکت OTP JWT (برای set-password اولیه)
-- ساخت یا بروزرسانی کاربر (upsert) در Prisma
-- **هیچ توکنی صادر نمی‌کند** — فقط اعتبارسنجی را انجام می‌دهد.
-
-**متدهای کلیدی:**
-| متد | توضیح |
-|------|-------|
-| `setPassword(token, password)` | رمز را پس از OTP تنظیم می‌کند |
-| `login(identifier, password)` | بررسی اعتبار کاربر و بازگشت userId |
-| `changePassword(userId, old, new)` | تغییر رمز برای کاربر لاگین‌شده |
-
----
-
-### 2. **RefreshService**
-- مدیریت توکن‌های `access` و `refresh`
-- ساخت جفت‌توکن (TokenPair)
-- ثبت JTI در Redis (allow-list)
-- لغو و چرخش امن رفرش‌توکن‌ها
-- اتصال JTI به Session (برای ردیابی نشست)
-
-**متدهای کلیدی:**
-| متد | توضیح |
-|------|-------|
-| `issueTokensForUserId(userId, { sessionId })` | ساخت access و refresh جدید |
-| `refresh(refreshToken)` | چرخش (rotate) توکن‌ها |
-| `revoke(refreshToken)` | باطل کردن توکن |
-| `peekPayload(token)` | بررسی payload بدون خطا در انقضا |
-
----
-
-### 3. **SessionService**
-- ذخیره و مدیریت نشست‌ها در Redis  
-- TTL سشن‌ها معمولاً `45d`
-- ردیابی دستگاه‌ها و مرورگرهای مختلف کاربر
-- ارتباط سشن ↔ JTI برای logout اختصاصی
-
-**ساختار کلیدها در Redis:**
-```
-session:<userId>:<sessionId>      → JSON(SessionRecord)
-session:index:<userId>             → SET از sessionIdها
-session:jtis:<userId>:<sessionId>  → SET از JTIهای آن سشن
-session:jti:index:<jti>            → "userId:sessionId"
-```
-
-**متدهای کلیدی:**
-| متد | توضیح |
-|------|-------|
-| `create()` | ساخت نشست جدید با IP و User-Agent |
-| `touch()` | تمدید TTL و به‌روزرسانی lastUsedAt |
-| `linkRefreshJti()` | اتصال JTI به سشن |
-| `findSessionByJti()` | پیدا کردن سشن از روی JTI |
-| `revoke()` | بستن یک نشست خاص |
-| `revokeAll()` | خروج از همه‌ی دستگاه‌ها |
-
----
-
-### 4. **TokenService**
-- ابزار JWT مستقل برای پروژه (در صورت نیاز در سرویس‌های دیگر)
-- مدیریت sign/verify برای access و refresh
-- پشتیبانی از blacklisting در Redis
-
-(در فاز فعلی بخش اصلی کار توکن‌ها در `RefreshService` انجام می‌شود.)
-
----
-
-### 5. **AuthController**
-مسیرهای HTTP اصلی برای احراز هویت:
-
-| متد | مسیر | توضیح |
-|------|------|--------|
-| `POST /auth/login` | ورود با `email` یا `phone` و رمز عبور |
-| `POST /auth/refresh` | صدور مجدد accessToken با refresh_token |
-| `POST /auth/logout` | خروج و حذف کوکی refresh_token |
-
----
-
-## 🔐 جریان ورود (Login Flow)
-
-1. کاربر درخواست `POST /auth/login` می‌فرستد:
-   ```json
-   { "identifier": "test@example.com", "password": "123456" }
-   ```
-2. سیستم:
-   - با `PasswordService.login` اعتبار کاربر را بررسی می‌کند.
-   - یک `Session` جدید در Redis می‌سازد.
-   - جفت‌توکن (access + refresh) را با `RefreshService` تولید می‌کند.
-   - `refresh_token` را در کوکی HttpOnly ذخیره می‌کند.
-3. پاسخ:
-   ```json
-   { "accessToken": "<JWT>" }
-   ```
-4. کلاینت `accessToken` را در هدر `Authorization` می‌فرستد:
-   ```
-   Authorization: Bearer <accessToken>
-   ```
-
----
-
-## ♻️ جریان رفرش توکن (Token Rotation)
-
-1. کاربر درخواست `POST /auth/refresh` می‌فرستد.
-2. کنترلر، `refresh_token` را از **کوکی یا body** می‌خواند.
-3. `RefreshService.refresh()` جفت جدید می‌سازد:
-   - refreshToken قبلی از Redis حذف می‌شود.
-   - refreshToken جدید ثبت می‌شود.
-4. پاسخ جدید:
-   ```json
-   { "accessToken": "<new-access>" }
-   ```
-   و کوکی HttpOnly جدید ست می‌شود.
-
----
-
-## 🚪 خروج از حساب (Logout Flow)
-
-1. `POST /auth/logout`
-2. توکن رفرش از کوکی یا body گرفته می‌شود.
-3. `RefreshService.revoke()` آن را از Redis حذف می‌کند.
-4. کوکی پاک می‌شود.
-5. پاسخ:
-   ```json
-   { "success": true }
-   ```
-
----
-
-## 🧱 طراحی امنیتی
-
-- **AccessToken**: کوتاه‌عمر (مثلاً 10 دقیقه)
-- **RefreshToken**: بلندمدت (مثلاً 30 روز)
-- **HttpOnly Cookie** برای refresh (جلوگیری از دسترسی JS)
-- **Redis Allow-list** برای کنترل دقیق JTIها
-- **Session TTL** مستقل برای هر دستگاه (قابل مشاهده در داشبورد آینده)
-- **Blacklist** در حال توسعه برای revoke آنی access tokens
-
----
-
-## 🧩 وابستگی‌ها
-
-| سرویس | توضیح |
-|--------|--------|
-| `PrismaService` | ارتباط با دیتابیس کاربران |
-| `Redis` | ذخیره سشن و توکن‌ها |
-| `ConfigService` | خواندن تنظیمات از ENV |
-| `MailService` | ارسال ایمیل خوش‌آمد یا اطلاع تغییر رمز |
-
----
-
-## ✅ تست با Postman / Swagger
-
-**Login:**
-```
-POST /auth/login
-Body: { "identifier": "user@example.com", "password": "123456" }
-Response: { "accessToken": "<token>" }
-```
-
-**Refresh:**
-```
-POST /auth/refresh
-Cookie: refresh_token=<refresh>
-Response: { "accessToken": "<new token>" }
-```
-
-**Logout:**
-```
-POST /auth/logout
-Clears cookie & revokes token
-```
-
----
-
-## 🧾 Environment Variables (نمونه .env)
-```env
-ACCESS_JWT_SECRET=super-secret-access
-ACCESS_JWT_EXPIRES=10m
-REFRESH_JWT_SECRET=super-secret-refresh
-REFRESH_JWT_EXPIRES=30d
-
-SET_PWD_JWT_SECRET=otp-secret
-BCRYPT_ROUNDS=10
-
-SESSION_TTL=45d
-
-REDIS_URL=redis://redis:6379
-```
-
----
-
-**آخرین به‌روزرسانی:** 2025-10-29  
-توسعه‌دهنده: امیرحسین 👨‍💻  
-نسخه: v2.0 — ساختار کامل و تست‌شده Auth System (Negare)
+# 🧩 Auth Module — Negare Platform
+
+این ماژول مسئول **احراز هویت (Authentication)**، **مدیریت نشست‌ها (Sessions)** و **چرخش توکن‌ها (Token Rotation)** است.  
+ساختار آن بر پایه‌ی **NestJS + Redis + JWT** طراحی شده و تمام فلوهای ثبت‌نام، ورود، خروج و تنظیم رمز عبور را پوشش می‌دهد.
+
+---
+
+## ⚙️ ماژول‌ها و سرویس‌ها
+
+### 1. **PasswordService**
+- مدیریت رمز عبور کاربران (ثبت، تغییر، ورود)
+- اعتبارسنجی کاربر با `email` یا `phone`
+- هش رمزها با `bcrypt`
+- تایید تیکت OTP JWT (برای set-password اولیه)
+- ساخت یا بروزرسانی کاربر (upsert) در Prisma
+- **هیچ توکنی صادر نمی‌کند** — فقط اعتبارسنجی را انجام می‌دهد.
+
+**متدهای کلیدی:**
+| متد | توضیح |
+|------|-------|
+| `setPassword(token, password)` | رمز را پس از OTP تنظیم می‌کند |
+| `login(identifier, password)` | بررسی اعتبار کاربر و بازگشت userId |
+| `changePassword(userId, old, new)` | تغییر رمز برای کاربر لاگین‌شده |
+
+---
+
+### 2. **RefreshService**
+- مدیریت توکن‌های `access` و `refresh`
+- ساخت جفت‌توکن (TokenPair)
+- ثبت JTI در Redis (allow-list)
+- لغو و چرخش امن رفرش‌توکن‌ها
+- اتصال JTI به Session (برای ردیابی نشست)
+
+**متدهای کلیدی:**
+| متد | توضیح |
+|------|-------|
+| `issueTokensForUserId(userId, { sessionId })` | ساخت access و refresh جدید |
+| `refresh(refreshToken)` | چرخش (rotate) توکن‌ها |
+| `revoke(refreshToken)` | باطل کردن توکن |
+| `peekPayload(token)` | بررسی payload بدون خطا در انقضا |
+
+---
+
+### 3. **SessionService**
+- ذخیره و مدیریت نشست‌ها در Redis  
+- TTL سشن‌ها معمولاً `45d`
+- ردیابی دستگاه‌ها و مرورگرهای مختلف کاربر
+- ارتباط سشن ↔ JTI برای logout اختصاصی
+
+**ساختار کلیدها در Redis:**
+```
+session:<userId>:<sessionId>      → JSON(SessionRecord)
+session:index:<userId>             → SET از sessionIdها
+session:jtis:<userId>:<sessionId>  → SET از JTIهای آن سشن
+session:jti:index:<jti>            → "userId:sessionId"
+```
+
+**متدهای کلیدی:**
+| متد | توضیح |
+|------|-------|
+| `create()` | ساخت نشست جدید با IP و User-Agent |
+| `touch()` | تمدید TTL و به‌روزرسانی lastUsedAt |
+| `linkRefreshJti()` | اتصال JTI به سشن |
+| `findSessionByJti()` | پیدا کردن سشن از روی JTI |
+| `revoke()` | بستن یک نشست خاص |
+| `revokeAll()` | خروج از همه‌ی دستگاه‌ها |
+
+---
+
+### 4. **TokenService**
+- ابزار JWT مستقل برای پروژه (در صورت نیاز در سرویس‌های دیگر)
+- مدیریت sign/verify برای access و refresh
+- پشتیبانی از blacklisting در Redis
+
+(در فاز فعلی بخش اصلی کار توکن‌ها در `RefreshService` انجام می‌شود.)
+
+---
+
+### 5. **AuthController**
+مسیرهای HTTP اصلی برای احراز هویت:
+
+| متد | مسیر | توضیح |
+|------|------|--------|
+| `POST /auth/login` | ورود با `email` یا `phone` و رمز عبور |
+| `POST /auth/refresh` | صدور مجدد accessToken با refresh_token |
+| `POST /auth/logout` | خروج و حذف کوکی refresh_token |
+
+---
+
+## 🔐 جریان ورود (Login Flow)
+
+1. کاربر درخواست `POST /auth/login` می‌فرستد:
+   ```json
+   { "identifier": "test@example.com", "password": "123456" }
+   ```
+2. سیستم:
+   - با `PasswordService.login` اعتبار کاربر را بررسی می‌کند.
+   - یک `Session` جدید در Redis می‌سازد.
+   - جفت‌توکن (access + refresh) را با `RefreshService` تولید می‌کند.
+   - `refresh_token` را در کوکی HttpOnly ذخیره می‌کند.
+3. پاسخ:
+   ```json
+   { "accessToken": "<JWT>" }
+   ```
+4. کلاینت `accessToken` را در هدر `Authorization` می‌فرستد:
+   ```
+   Authorization: Bearer <accessToken>
+   ```
+
+---
+
+## ♻️ جریان رفرش توکن (Token Rotation)
+
+1. کاربر درخواست `POST /auth/refresh` می‌فرستد.
+2. کنترلر، `refresh_token` را از **کوکی یا body** می‌خواند.
+3. `RefreshService.refresh()` جفت جدید می‌سازد:
+   - refreshToken قبلی از Redis حذف می‌شود.
+   - refreshToken جدید ثبت می‌شود.
+4. پاسخ جدید:
+   ```json
+   { "accessToken": "<new-access>" }
+   ```
+   و کوکی HttpOnly جدید ست می‌شود.
+
+---
+
+## 🚪 خروج از حساب (Logout Flow)
+
+1. `POST /auth/logout`
+2. توکن رفرش از کوکی یا body گرفته می‌شود.
+3. `RefreshService.revoke()` آن را از Redis حذف می‌کند.
+4. کوکی پاک می‌شود.
+5. پاسخ:
+   ```json
+   { "success": true }
+   ```
+
+---
+
+## 🧱 طراحی امنیتی
+
+- **AccessToken**: کوتاه‌عمر (مثلاً 10 دقیقه)
+- **RefreshToken**: بلندمدت (مثلاً 30 روز)
+- **HttpOnly Cookie** برای refresh (جلوگیری از دسترسی JS)
+- **Redis Allow-list** برای کنترل دقیق JTIها
+- **Session TTL** مستقل برای هر دستگاه (قابل مشاهده در داشبورد آینده)
+- **Blacklist** در حال توسعه برای revoke آنی access tokens
+
+---
+
+## 🧩 وابستگی‌ها
+
+| سرویس | توضیح |
+|--------|--------|
+| `PrismaService` | ارتباط با دیتابیس کاربران |
+| `Redis` | ذخیره سشن و توکن‌ها |
+| `ConfigService` | خواندن تنظیمات از ENV |
+| `MailService` | ارسال ایمیل خوش‌آمد یا اطلاع تغییر رمز |
+
+---
+
+## ✅ تست با Postman / Swagger
+
+**Login:**
+```
+POST /auth/login
+Body: { "identifier": "user@example.com", "password": "123456" }
+Response: { "accessToken": "<token>" }
+```
+
+**Refresh:**
+```
+POST /auth/refresh
+Cookie: refresh_token=<refresh>
+Response: { "accessToken": "<new token>" }
+```
+
+**Logout:**
+```
+POST /auth/logout
+Clears cookie & revokes token
+```
+
+---
+
+## 🧾 Environment Variables (نمونه .env)
+```env
+ACCESS_JWT_SECRET=super-secret-access
+ACCESS_JWT_EXPIRES=10m
+REFRESH_JWT_SECRET=super-secret-refresh
+REFRESH_JWT_EXPIRES=30d
+
+SET_PWD_JWT_SECRET=otp-secret
+BCRYPT_ROUNDS=10
+
+SESSION_TTL=45d
+
+REDIS_URL=redis://redis:6379
+```
+
+---
+
+**آخرین به‌روزرسانی:** 2025-10-29  
+توسعه‌دهنده: امیرحسین 👨‍💻  
+نسخه: v2.0 — ساختار کامل و تست‌شده Auth System (Negare)
diff --git a/apps/api/src/core/auth/auth.constants.ts b/apps/api/src/core/auth/auth.constants.ts
index f0e74ce..c1fe449 100644
--- a/apps/api/src/core/auth/auth.constants.ts
+++ b/apps/api/src/core/auth/auth.constants.ts
@@ -1,9 +1,9 @@
-export const REFRESH_ALLOW_PREFIX = 'auth:refresh:allow:';
-
-export interface RefreshAllowRecord {
-  userId: string;
-  sessionId: string | null;
-}
-
-export const refreshAllowKey = (jti: string): string =>
-  `${REFRESH_ALLOW_PREFIX}${jti}`;
+export const REFRESH_ALLOW_PREFIX = 'auth:refresh:allow:';
+
+export interface RefreshAllowRecord {
+  userId: string;
+  sessionId: string | null;
+}
+
+export const refreshAllowKey = (jti: string): string =>
+  `${REFRESH_ALLOW_PREFIX}${jti}`;
diff --git a/apps/api/src/core/auth/auth.controller.spec.ts b/apps/api/src/core/auth/auth.controller.spec.ts
index bbbd8e1..4ac902c 100644
--- a/apps/api/src/core/auth/auth.controller.spec.ts
+++ b/apps/api/src/core/auth/auth.controller.spec.ts
@@ -1,6 +1,6 @@
 import { UnauthorizedException } from '@nestjs/common';
 import type { Request } from 'express';
-import { AuthController } from './auth.controller';
+import { AuthController } from '@app/core/auth/auth.controller';
 
 const authConfig = {
   accessSecret: 'spec-access',
diff --git a/apps/api/src/core/auth/auth.controller.ts b/apps/api/src/core/auth/auth.controller.ts
index fcc66cc..4a1a568 100644
--- a/apps/api/src/core/auth/auth.controller.ts
+++ b/apps/api/src/core/auth/auth.controller.ts
@@ -6,7 +6,6 @@ import {
   BadRequestException,
   Body,
   Controller,
-  ForbiddenException,
   HttpCode,
   HttpStatus,
   Logger,
@@ -14,6 +13,8 @@ import {
   Req,
   Res,
   UnauthorizedException,
+  InternalServerErrorException,
+  Inject,
 } from '@nestjs/common';
 import {
   ApiCookieAuth,
@@ -24,19 +25,21 @@ import {
 import type { Request, Response } from 'express';
 import { Public } from '@app/common/decorators/public.decorator';
 
-import { PasswordService } from './password/password.service';
-import { RefreshService } from './refresh.service';
-import { SessionService } from './session/session.service';
-import { RefreshRateLimitService } from './refresh-rate-limit.service';
+import { PasswordService } from '@app/core/auth/password/password.service';
+import { RefreshService } from '@app/core/auth/refresh.service';
+import { SessionService } from '@app/core/auth/session/session.service';
 
-import { LoginDto } from './dto/login.dto';
-import { RefreshTokenDto } from './dto/refresh-token.dto';
+import { LoginDto } from '@app/core/auth/dto/login.dto';
+import { RefreshTokenDto } from '@app/core/auth/dto/refresh-token.dto';
 
 import { ConfigService } from '@nestjs/config';
 import type { AllConfig } from '@app/config/config.module';
 import type { AuthConfig } from '@app/config/auth.config';
 import { parseDurationToSeconds } from '@app/shared/utils/parse-duration.util';
 
+import type Redis from 'ioredis';
+import { refreshAllowKey } from '@app/core/auth/auth.constants';
+
 @ApiTags('Authentication')
 @Controller('auth')
 export class AuthController {
@@ -44,8 +47,6 @@ export class AuthController {
   private readonly refreshCookieMaxAgeMs: number;
   private readonly cookieSameSite: 'lax' | 'strict' | 'none';
   private readonly cookieSecure: boolean;
-  private readonly refreshCookiePath: string;
-  private readonly allowedOrigins: Set<string>;
 
   private static readonly REFRESH_COOKIE_NAME = 'refresh_token' as const;
 
@@ -54,7 +55,7 @@ export class AuthController {
     private readonly refreshService: RefreshService,
     private readonly sessions: SessionService,
     private readonly config: ConfigService<AllConfig>,
-    private readonly refreshRateLimit: RefreshRateLimitService,
+    @Inject('REDIS') private readonly redis: Redis,
   ) {
     const auth = this.config.get<AuthConfig>('auth', { infer: true });
     if (!auth) throw new Error('Auth configuration not found.');
@@ -64,10 +65,8 @@ export class AuthController {
       30 * 24 * 3600,
     );
     this.refreshCookieMaxAgeMs = refreshTtlSeconds * 1000;
-    this.cookieSameSite = auth.cookie.sameSite ?? 'none';
+    this.cookieSameSite = auth.cookie.sameSite;
     this.cookieSecure = auth.cookie.secure;
-    this.refreshCookiePath = auth.cookie.refreshPath ?? '/';
-    this.allowedOrigins = this.resolveAllowedOrigins();
   }
 
   // ------------------------------------------------------------------
@@ -86,7 +85,7 @@ export class AuthController {
       httpOnly: true,
       secure: this.cookieSecure,
       sameSite: this.cookieSameSite,
-      path: this.refreshCookiePath,
+      path: '/', // ✅ فقط یک مسیر
       maxAge: this.refreshCookieMaxAgeMs,
     });
   }
@@ -96,7 +95,7 @@ export class AuthController {
       httpOnly: true,
       secure: this.cookieSecure,
       sameSite: this.cookieSameSite,
-      path: this.refreshCookiePath,
+      path: '/', // ✅ فقط همین مسیر
     });
   }
 
@@ -123,67 +122,6 @@ export class AuthController {
     return ip || undefined;
   }
 
-  private resolveAllowedOrigins(): Set<string> {
-    const raw =
-      this.config.get<string>('FRONTEND_URL') ??
-      process.env.FRONTEND_URL ??
-      this.config.get<string>('CORS_ORIGIN') ??
-      'http://localhost:3000';
-    const origins = raw
-      .split(',')
-      .map((origin) => this.normalizeOrigin(origin))
-      .filter(Boolean);
-    return new Set(origins);
-  }
-
-  private normalizeOrigin(value?: string | string[]): string {
-    if (!value) return '';
-    const raw = Array.isArray(value) ? value[0] : value;
-    if (!raw) return '';
-    try {
-      const parsed = new URL(raw);
-      return parsed.origin.replace(/\/+$/, '').toLowerCase();
-    } catch {
-      return raw.replace(/\/+$/, '').toLowerCase();
-    }
-  }
-
-  private assertAllowedOrigin(req: Request): void {
-    if (!this.allowedOrigins.size) return;
-    const originHeader = this.normalizeOrigin(
-      (req.headers.origin ?? req.headers.Origin) as string | undefined,
-    );
-    const refererHeader = this.normalizeOrigin(
-      (req.headers.referer ?? req.headers.Referer) as string | undefined,
-    );
-    const allowed =
-      (originHeader && this.allowedOrigins.has(originHeader)) ||
-      (refererHeader && this.allowedOrigins.has(refererHeader));
-    if (allowed) {
-      return;
-    }
-    throw new ForbiddenException({
-      code: 'OriginNotAllowed',
-      message: 'Origin is not allowed for refresh.',
-    });
-  }
-
-  private assertJsonRequest(req: Request): void {
-    const contentType = String(req.headers['content-type'] ?? '').toLowerCase();
-    if (!contentType.includes('application/json')) {
-      throw new BadRequestException({
-        code: 'InvalidContentType',
-        message: 'Content-Type must be application/json.',
-      });
-    }
-  }
-
-  private getRateLimitKey(req: Request): string {
-    const ip = this.getIp(req) ?? 'unknown';
-    const ua = (req.headers['user-agent'] as string) ?? 'unknown';
-    return `${ip}|${ua}`;
-  }
-
   // ------------------------------------------------------------------
   // Login
   // ------------------------------------------------------------------
@@ -246,60 +184,29 @@ export class AuthController {
   @HttpCode(HttpStatus.OK)
   @ApiOperation({ summary: 'Rotate refresh & mint new access token' })
   @ApiCookieAuth('refresh_token')
-  @ApiResponse({
-    status: 200,
-    schema: { example: { success: true, data: { accessToken: '...' } } },
-  })
+  @ApiResponse({ status: 200, schema: { example: { accessToken: '...' } } })
   async refresh(
     @Req() req: Request,
+    @Body() dto: RefreshTokenDto,
     @Res({ passthrough: true }) res: Response,
   ) {
-    // همیشه پاسخ non-cache
     this.setNoStore(res);
 
-    // اجازه بده درخواستِ بی‌بدنه رد نشه؛ اگر بدنه دارد باید JSON باشد
-    this.assertJsonOrEmpty(req);
-
-    // ضد-CSRF (Origin/Referer) — اگر FRONTEND_URL ست نیست، سخت‌گیری نکن
-    this.assertAllowedOrigin(req);
-
-    // ریت‌لیمیت با لاگ واضح
-    try {
-      await this.refreshRateLimit.consume(this.getRateLimitKey(req));
-    } catch (e) {
-      this.logger.warn(
-        `[refresh] rate-limited key=${this.getRateLimitKey(req)}`,
-      );
-      throw e; // معمولاً 429
-    }
-
-    const hasCookie = Boolean(req.headers?.cookie);
-    this.logger.debug(`[refresh] cookie present? ${hasCookie}`);
+    const refreshToken =
+      (dto?.refreshToken ?? '').trim() || this.getRefreshToken(req, null);
 
-    const refreshToken = this.getRefreshToken(req, null);
     if (!refreshToken) {
-      throw new UnauthorizedException({
+      throw new BadRequestException({
         code: 'MissingRefresh',
-        message: 'No refresh cookie',
+        message: 'Refresh token not provided.',
       });
     }
 
     try {
       const pair = await this.refreshService.refresh(refreshToken);
-
-      // چرخش کوکی رفرش با تنظیمات کانفیگ
       this.setRefreshCookie(res, pair.refreshToken);
-
-      // قرارداد پاسخ ثابت
-      return {
-        success: true as const,
-        data: { accessToken: pair.accessToken },
-      };
-    } catch (err) {
-      // لاگ کوتاه و پیام استاندارد برای کلاینت
-      this.logger.warn(
-        `[refresh] deny: ${err instanceof Error ? err.message : err}`,
-      );
+      return { accessToken: pair.accessToken };
+    } catch {
       throw new UnauthorizedException({
         code: 'InvalidRefresh',
         message: 'Invalid or expired refresh token.',
@@ -307,18 +214,6 @@ export class AuthController {
     }
   }
 
-  /* ================== Helpers (در همین کنترلر) ================== */
-
-  /** اگر بدنه ندارد، سخت‌گیری نکن؛ اگر بدنه دارد، باید JSON باشد. */
-  private assertJsonOrEmpty(req: Request) {
-    const ct = String(req.headers['content-type'] || '').toLowerCase();
-    const len = Number(req.headers['content-length'] || 0);
-    if (!len) return; // بدون بدنه → عبور
-    if (!ct.includes('application/json')) {
-      throw new BadRequestException('Content-Type must be application/json.');
-    }
-  }
-
   // ------------------------------------------------------------------
   // Logout
   // ------------------------------------------------------------------
diff --git a/apps/api/src/core/auth/auth.module.ts b/apps/api/src/core/auth/auth.module.ts
index ce1bfaa..0c1804f 100644
--- a/apps/api/src/core/auth/auth.module.ts
+++ b/apps/api/src/core/auth/auth.module.ts
@@ -1,31 +1,38 @@
 import { Module } from '@nestjs/common';
 import { APP_GUARD } from '@nestjs/core';
-import { HybridAuthGuard } from './guards/hybrid-auth.guard';
-import { JwtAuthGuard } from './guards/jwt-auth.guard';
+import { HybridAuthGuard } from '@app/core/auth/guards/hybrid-auth.guard';
+import { JwtAuthGuard } from '@app/core/auth/guards/jwt-auth.guard';
 import { RolesGuard } from '@app/common/guards/roles.guard';
 import { SmsModule } from '@app/sms/sms.module';
 import { MailModule } from '@app/mail/mail.module';
 import { RedisModule } from '@app/redis/redis.module';
 import { UsersModule } from '@app/core/users/users.module';
-import { TokenModule } from './token/token.module';
+import { TokenModule } from '@app/core/auth/token/token.module';
 
 // Controllers
-import { AuthController } from './auth.controller';
-import { OtpController } from './otp/otp.controller';
-import { PasswordController } from './password/password.controller';
+import { AuthController } from '@app/core/auth/auth.controller';
+import { OtpController } from '@app/core/auth/otp/otp.controller';
+import { PasswordController } from '@app/core/auth/password/password.controller';
 
 // Services
-import { OtpService } from './otp/otp.service';
-import { OtpRateLimitService } from './otp/otp-rate-limit.service';
-import { PasswordService } from './password/password.service';
-import { RefreshService } from './refresh.service';
-import { SessionService } from './session/session.service';
-import { RefreshRateLimitService } from './refresh-rate-limit.service';
+import { OtpService } from '@app/core/auth/otp/otp.service';
+import { OtpRateLimitService } from '@app/core/auth/otp/otp-rate-limit.service';
+import { PasswordService } from '@app/core/auth/password/password.service';
+import { RefreshService } from '@app/core/auth/refresh.service';
+import { SessionService } from '@app/core/auth/session/session.service';
+import { RefreshRateLimitService } from '@app/core/auth/refresh-rate-limit.service';
+
+// NEW
+import { PrismaService } from '@app/prisma/prisma.service';
+import { UserLookupProvider } from '@app/core/auth/otp/user-lookup.provider';
 
 @Module({
   imports: [SmsModule, MailModule, RedisModule, UsersModule, TokenModule],
   controllers: [AuthController, OtpController, PasswordController],
   providers: [
+    PrismaService, // ← اضافه
+    UserLookupProvider, // ← اضافه
+
     OtpService,
     PasswordService,
     RefreshService,
diff --git a/apps/api/src/core/auth/auth.service.ts b/apps/api/src/core/auth/auth.service.ts
index eac5d59..39d3414 100644
--- a/apps/api/src/core/auth/auth.service.ts
+++ b/apps/api/src/core/auth/auth.service.ts
@@ -6,10 +6,10 @@ import {
   InternalServerErrorException,
 } from '@nestjs/common';
 import type { Request, Response } from 'express';
-import { PasswordService } from './password/password.service';
-import { RefreshService } from './refresh.service';
-import { SessionService } from './session/session.service';
-import { TokenService } from './token/token.service';
+import { PasswordService } from '@app/core/auth/password/password.service';
+import { RefreshService } from '@app/core/auth/refresh.service';
+import { SessionService } from '@app/core/auth/session/session.service';
+import { TokenService } from '@app/core/auth/token/token.service';
 import { UsersService } from '@app/core/users/users.service';
 
 type LoginInput = {
diff --git a/apps/api/src/core/auth/dto/login.dto.ts b/apps/api/src/core/auth/dto/login.dto.ts
index 9590470..9a280b3 100644
--- a/apps/api/src/core/auth/dto/login.dto.ts
+++ b/apps/api/src/core/auth/dto/login.dto.ts
@@ -1,17 +1,17 @@
-﻿import { ApiProperty } from '@nestjs/swagger';
-import { Transform } from 'class-transformer';
-import { IsString, MinLength } from 'class-validator';
-
-export class LoginDto {
-  @ApiProperty({ example: 'user@example.com یا 0912xxxxxxx' })
-  @IsString()
-  @Transform(({ value }) =>
-    typeof value === 'string' ? value.trim().toLowerCase() : value,
-  )
-  identifier!: string;
-
-  @ApiProperty({ minLength: 8 })
-  @IsString()
-  @MinLength(8)
-  password!: string;
-}
+﻿import { ApiProperty } from '@nestjs/swagger';
+import { Transform } from 'class-transformer';
+import { IsString, MinLength } from 'class-validator';
+
+export class LoginDto {
+  @ApiProperty({ example: 'user@example.com یا 0912xxxxxxx' })
+  @IsString()
+  @Transform(({ value }) =>
+    typeof value === 'string' ? value.trim().toLowerCase() : value,
+  )
+  identifier!: string;
+
+  @ApiProperty({ minLength: 8 })
+  @IsString()
+  @MinLength(8)
+  password!: string;
+}
diff --git a/apps/api/src/core/auth/dto/otp/otp-request.dto.ts b/apps/api/src/core/auth/dto/otp/otp-request.dto.ts
index a280e08..43b5d6a 100644
--- a/apps/api/src/core/auth/dto/otp/otp-request.dto.ts
+++ b/apps/api/src/core/auth/dto/otp/otp-request.dto.ts
@@ -1,47 +1,63 @@
-import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import {
-  IsEnum,
-  IsOptional,
-  IsString,
-  ValidateIf,
-  IsEmail,
-  IsPhoneNumber,
-} from 'class-validator';
-import { Transform } from 'class-transformer';
-import { OtpChannel, OtpPurpose } from '@prisma/client';
-
-export class RequestOtpDto {
-  @ApiProperty({
-    enum: OtpChannel,
-    example: OtpChannel.sms,
-    description: 'sms | email',
-  })
-  @IsEnum(OtpChannel)
-  channel: OtpChannel;
-
-  @ApiProperty({
-    example: 'user@example.com',
-    description: 'ایمیل یا موبایل (بسته به channel). ایمیل lowercase می‌شود.',
-  })
-  @IsString()
-  @Transform(({ value, obj }) => {
-    const v = typeof value === 'string' ? value.trim() : value;
-    return obj?.channel === OtpChannel.email && typeof v === 'string'
-      ? v.toLowerCase()
-      : v;
-  })
-  @ValidateIf((o) => o.channel === OtpChannel.email)
-  @IsEmail({}, { message: 'Invalid email format.' })
-  @ValidateIf((o) => o.channel === OtpChannel.sms)
-  @IsPhoneNumber('IR', { message: 'Invalid phone number.' })
-  identifier: string;
-
-  @ApiPropertyOptional({
-    enum: OtpPurpose,
-    example: OtpPurpose.login,
-    description: 'Purpose of OTP (signup, login, reset)',
-  })
-  @IsOptional()
-  @IsEnum(OtpPurpose)
-  purpose?: OtpPurpose;
-}
+import { ApiProperty } from '@nestjs/swagger';
+import {
+  IsEnum,
+  IsString,
+  ValidateIf,
+  IsEmail,
+  IsPhoneNumber,
+} from 'class-validator';
+import { Transform } from 'class-transformer';
+import { OtpChannel, OtpPurpose } from '@prisma/client';
+
+function normalizePhoneIR(raw: string): string {
+  if (!raw) return raw;
+  let v = String(raw).replace(/\s+/g, '');
+  // 09xxxxxxxxx  -> +989xxxxxxxxx
+  if (/^09\d{9}$/.test(v)) return '+98' + v.slice(1);
+  // 9xxxxxxxxx   -> +989xxxxxxxxx
+  if (/^9\d{9}$/.test(v)) return '+98' + v;
+  // 0098... -> +98...
+  if (/^0098/.test(v)) return v.replace(/^00/, '+');
+  // 0+98... (حالات عجیب) -> +98...
+  if (/^0\+98/.test(v)) return v.replace(/^0\+/, '+');
+  return v;
+}
+
+export class RequestOtpDto {
+  @ApiProperty({
+    enum: OtpChannel,
+    example: OtpChannel.sms,
+    description: 'sms | email',
+  })
+  @IsEnum(OtpChannel)
+  channel!: OtpChannel;
+
+  @ApiProperty({
+    example: 'user@example.com یا 09123456789',
+    description:
+      'ایمیل یا موبایل (بسته به channel). ایمیل lowercase می‌شود؛ موبایل به E164 ایران نرمال می‌شود.',
+  })
+  @IsString()
+  @Transform(({ value, obj }) => {
+    if (obj?.channel === OtpChannel.email && typeof value === 'string') {
+      return value.trim().toLowerCase();
+    }
+    if (obj?.channel === OtpChannel.sms && typeof value === 'string') {
+      return normalizePhoneIR(value);
+    }
+    return value;
+  })
+  @ValidateIf((o) => o.channel === OtpChannel.email)
+  @IsEmail({}, { message: 'Invalid email format.' })
+  @ValidateIf((o) => o.channel === OtpChannel.sms)
+  @IsPhoneNumber('IR', { message: 'Invalid phone number.' })
+  identifier!: string;
+
+  @ApiProperty({
+    enum: OtpPurpose,
+    example: OtpPurpose.signup,
+    description: 'Purpose of OTP (signup, login, reset) — REQUIRED',
+  })
+  @IsEnum(OtpPurpose, { message: 'purpose must be one of signup|login|reset' })
+  purpose!: OtpPurpose; // ⬅️ اجباری
+}
diff --git a/apps/api/src/core/auth/dto/otp/otp-resend.dto.ts b/apps/api/src/core/auth/dto/otp/otp-resend.dto.ts
index e4ce442..650a295 100644
--- a/apps/api/src/core/auth/dto/otp/otp-resend.dto.ts
+++ b/apps/api/src/core/auth/dto/otp/otp-resend.dto.ts
@@ -1,56 +1,64 @@
-import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import {
-  IsEnum,
-  IsString,
-  IsEmail,
-  IsMobilePhone,
-  IsOptional,
-  ValidateIf,
-  IsPhoneNumber,
-} from 'class-validator';
-import { Transform } from 'class-transformer';
-import { OtpChannel, OtpPurpose } from '@prisma/client';
-
-/**
- * DTO for resending an OTP code.
- * Behavior: same as request, but checks resend cooldown instead of rate-limit window.
- */
-export class ResendOtpDto {
-  @ApiProperty({
-    enum: OtpChannel,
-    example: OtpChannel.sms,
-    description:
-      'Delivery channel — must match the one used in original request.',
-  })
-  @IsEnum(OtpChannel)
-  channel: OtpChannel;
-
-  @ApiProperty({
-    example: '09123456789',
-    description:
-      'Recipient identifier (email or phone). Validation depends on channel.',
-  })
-  @IsString()
-  @Transform(({ value, obj }) => {
-    let v = typeof value === 'string' ? value.trim() : value;
-    if (obj?.channel === OtpChannel.sms && typeof v === 'string')
-      v = v.replace(/\s+/g, '');
-    if (obj?.channel === OtpChannel.email && typeof v === 'string')
-      v = v.toLowerCase();
-    return v;
-  })
-  @ValidateIf((o) => o.channel === OtpChannel.email)
-  @IsEmail({}, { message: 'Invalid email format.' })
-  @ValidateIf((o) => o.channel === OtpChannel.sms)
-  @IsPhoneNumber('IR', { message: 'Invalid phone number format.' })
-  identifier: string;
-
-  @ApiPropertyOptional({
-    enum: OtpPurpose,
-    example: OtpPurpose.login,
-    description: 'Purpose of OTP (signup, login, reset). Default = signup.',
-  })
-  @IsOptional()
-  @IsEnum(OtpPurpose)
-  purpose?: OtpPurpose;
-}
+import { ApiProperty } from '@nestjs/swagger';
+import {
+  IsEnum,
+  IsString,
+  IsEmail,
+  ValidateIf,
+  IsPhoneNumber,
+} from 'class-validator';
+import { Transform } from 'class-transformer';
+import { OtpChannel, OtpPurpose } from '@prisma/client';
+
+/** نرمال‌سازی شماره ایران به E164 (+989xxxxxxxxx) */
+function normalizePhoneIR(raw: string): string {
+  if (!raw) return raw;
+  let v = String(raw).replace(/\s+/g, '');
+  if (/^09\d{9}$/.test(v)) return '+98' + v.slice(1); // 09xxxxxxxxx -> +989xxxxxxxxx
+  if (/^9\d{9}$/.test(v)) return '+98' + v; // 9xxxxxxxxx  -> +989xxxxxxxxx
+  if (/^0098/.test(v)) return v.replace(/^00/, '+'); // 0098...     -> +98...
+  if (/^0\+98/.test(v)) return v.replace(/^0\+/, '+'); // 0+98...     -> +98...
+  return v;
+}
+
+/**
+ * DTO for resending an OTP code.
+ * Must match the channel/identifier used in the original request.
+ */
+export class ResendOtpDto {
+  @ApiProperty({
+    enum: OtpChannel,
+    example: OtpChannel.sms,
+    description: 'sms | email',
+  })
+  @IsEnum(OtpChannel)
+  channel!: OtpChannel;
+
+  @ApiProperty({
+    example: '09123456789 یا user@example.com',
+    description:
+      'گیرنده (ایمیل یا موبایل). براساس channel اعتبارسنجی می‌شود. ایمیل lowercase و موبایل E164 می‌شود.',
+  })
+  @IsString()
+  @Transform(({ value, obj }) => {
+    if (obj?.channel === OtpChannel.email && typeof value === 'string') {
+      return value.trim().toLowerCase();
+    }
+    if (obj?.channel === OtpChannel.sms && typeof value === 'string') {
+      return normalizePhoneIR(value);
+    }
+    return value;
+  })
+  @ValidateIf((o) => o.channel === OtpChannel.email)
+  @IsEmail({}, { message: 'Invalid email format.' })
+  @ValidateIf((o) => o.channel === OtpChannel.sms)
+  @IsPhoneNumber('IR', { message: 'Invalid phone number format.' })
+  identifier!: string;
+
+  @ApiProperty({
+    enum: OtpPurpose,
+    example: OtpPurpose.signup,
+    description: 'Purpose of OTP (signup, login, reset) — REQUIRED',
+  })
+  @IsEnum(OtpPurpose, { message: 'purpose must be one of signup|login|reset' })
+  purpose!: OtpPurpose; // ⬅️ اجباری
+}
diff --git a/apps/api/src/core/auth/dto/otp/otp-verify.dto.ts b/apps/api/src/core/auth/dto/otp/otp-verify.dto.ts
index 9f15f3a..37550db 100644
--- a/apps/api/src/core/auth/dto/otp/otp-verify.dto.ts
+++ b/apps/api/src/core/auth/dto/otp/otp-verify.dto.ts
@@ -1,62 +1,74 @@
-import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import {
-  IsEnum,
-  IsString,
-  IsOptional,
-  ValidateIf,
-  IsEmail,
-  IsMobilePhone,
-  Matches,
-} from 'class-validator';
-import { Transform } from 'class-transformer';
-import { OtpChannel, OtpPurpose } from '@prisma/client';
-
-/**
- * DTO for verifying a previously requested OTP.
- * Used for signup/login/password reset verification.
- */
-export class VerifyOtpDto {
-  @ApiProperty({
-    enum: OtpChannel,
-    example: OtpChannel.sms,
-    description: 'Delivery channel — must match the one used in request.',
-  })
-  @IsEnum(OtpChannel)
-  channel: OtpChannel;
-
-  @ApiProperty({
-    example: '09123456789',
-    description:
-      'Recipient identifier (email or phone). Validation depends on channel.',
-  })
-  @IsString()
-  @Transform(({ value, obj }) => {
-    const v = typeof value === 'string' ? value.trim() : value;
-    return obj?.channel === OtpChannel.email && typeof v === 'string'
-      ? v.toLowerCase()
-      : v;
-  })
-  @ValidateIf((o) => o.channel === OtpChannel.email)
-  @IsEmail({}, { message: 'Invalid email format.' })
-  @ValidateIf((o) => o.channel === OtpChannel.sms)
-  @IsMobilePhone('fa-IR', {}, { message: 'Invalid phone number format.' })
-  identifier: string;
-
-  @ApiProperty({
-    example: '123456',
-    description: '6-digit OTP code sent to the user.',
-  })
-  @IsString()
-  @Matches(/^\d{6}$/, { message: 'Code must be exactly 6 digits.' })
-  @Transform(({ value }) => (typeof value === 'string' ? value.trim() : value))
-  code: string;
-
-  @ApiPropertyOptional({
-    enum: OtpPurpose,
-    example: OtpPurpose.signup,
-    description: 'Purpose of OTP (signup, login, reset). Default = signup.',
-  })
-  @IsOptional()
-  @IsEnum(OtpPurpose)
-  purpose?: OtpPurpose;
-}
+import { ApiProperty } from '@nestjs/swagger';
+import {
+  IsEnum,
+  IsString,
+  ValidateIf,
+  IsEmail,
+  IsPhoneNumber,
+  Matches,
+} from 'class-validator';
+import { Transform } from 'class-transformer';
+import { OtpChannel, OtpPurpose } from '@prisma/client';
+
+/** نرمال‌سازی شماره ایران به E164 (+989xxxxxxxxx) */
+function normalizePhoneIR(raw: string): string {
+  if (!raw) return raw as unknown as string;
+  let v = String(raw).replace(/\s+/g, '');
+  if (/^09\d{9}$/.test(v)) return '+98' + v.slice(1); // 09xxxxxxxxx -> +989xxxxxxxxx
+  if (/^9\d{9}$/.test(v)) return '+98' + v; // 9xxxxxxxxx  -> +989xxxxxxxxx
+  if (/^0098/.test(v)) return v.replace(/^00/, '+'); // 0098...     -> +98...
+  if (/^0\+98/.test(v)) return v.replace(/^0\+/, '+'); // 0+98...     -> +98...
+  return v;
+}
+
+/**
+ * DTO for verifying a previously requested OTP.
+ * Used for signup/login/reset verification.
+ */
+export class VerifyOtpDto {
+  @ApiProperty({
+    enum: OtpChannel,
+    example: OtpChannel.sms,
+    description: 'sms | email — باید با درخواست اولیه یکی باشد.',
+  })
+  @IsEnum(OtpChannel)
+  channel!: OtpChannel;
+
+  @ApiProperty({
+    example: '09123456789 یا user@example.com',
+    description:
+      'گیرنده (ایمیل یا موبایل). ایمیل lowercase می‌شود، موبایل به E164 ایران.',
+  })
+  @IsString()
+  @Transform(({ value, obj }) => {
+    if (obj?.channel === OtpChannel.email && typeof value === 'string') {
+      return value.trim().toLowerCase();
+    }
+    if (obj?.channel === OtpChannel.sms && typeof value === 'string') {
+      return normalizePhoneIR(value);
+    }
+    return value;
+  })
+  @ValidateIf((o) => o.channel === OtpChannel.email)
+  @IsEmail({}, { message: 'Invalid email format.' })
+  @ValidateIf((o) => o.channel === OtpChannel.sms)
+  @IsPhoneNumber('IR', { message: 'Invalid phone number format.' })
+  identifier!: string;
+
+  @ApiProperty({
+    example: '123456',
+    description: 'کد ۶ رقمی OTP که برای کاربر ارسال شده است.',
+  })
+  @IsString()
+  @Matches(/^\d{6}$/, { message: 'Code must be exactly 6 digits.' })
+  @Transform(({ value }) => (typeof value === 'string' ? value.trim() : value))
+  code!: string;
+
+  @ApiProperty({
+    enum: OtpPurpose,
+    example: OtpPurpose.signup,
+    description: 'Purpose (signup | login | reset) — REQUIRED.',
+  })
+  @IsEnum(OtpPurpose, { message: 'purpose must be one of signup|login|reset' })
+  purpose!: OtpPurpose; // ← اجباری
+}
diff --git a/apps/api/src/core/auth/dto/password/password.dto.ts b/apps/api/src/core/auth/dto/password/password.dto.ts
index 6ca46ae..ceb4ad0 100644
--- a/apps/api/src/core/auth/dto/password/password.dto.ts
+++ b/apps/api/src/core/auth/dto/password/password.dto.ts
@@ -1,33 +1,33 @@
-import { ApiProperty } from '@nestjs/swagger';
-import { IsString, MinLength } from 'class-validator';
-
-export class SetPasswordDto {
-  @ApiProperty({ minLength: 8 })
-  @IsString()
-  @MinLength(8)
-  password!: string;
-}
-
-export class ResetPasswordDto {
-  @ApiProperty({ minLength: 8 })
-  @IsString()
-  @MinLength(8)
-  password!: string;
-}
-
-export class ChangePasswordDto {
-  @ApiProperty()
-  @IsString()
-  currentPassword!: string;
-
-  @ApiProperty({ minLength: 8 })
-  @IsString()
-  @MinLength(8)
-  newPassword!: string;
-}
-
-export class PasswordStrengthDto {
-  @ApiProperty()
-  @IsString()
-  password!: string;
-}
+import { ApiProperty } from '@nestjs/swagger';
+import { IsString, MinLength } from 'class-validator';
+
+export class SetPasswordDto {
+  @ApiProperty({ minLength: 8 })
+  @IsString()
+  @MinLength(8)
+  password!: string;
+}
+
+export class ResetPasswordDto {
+  @ApiProperty({ minLength: 8 })
+  @IsString()
+  @MinLength(8)
+  password!: string;
+}
+
+export class ChangePasswordDto {
+  @ApiProperty()
+  @IsString()
+  currentPassword!: string;
+
+  @ApiProperty({ minLength: 8 })
+  @IsString()
+  @MinLength(8)
+  newPassword!: string;
+}
+
+export class PasswordStrengthDto {
+  @ApiProperty()
+  @IsString()
+  password!: string;
+}
diff --git a/apps/api/src/core/auth/dto/refresh-token.dto.ts b/apps/api/src/core/auth/dto/refresh-token.dto.ts
index 309063a..dfafd69 100644
--- a/apps/api/src/core/auth/dto/refresh-token.dto.ts
+++ b/apps/api/src/core/auth/dto/refresh-token.dto.ts
@@ -1,20 +1,20 @@
-/**
- * DTO describing the refresh token payload required for token rotation and logout.
- */
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import { IsOptional, IsString, MinLength } from 'class-validator';
-
-/**
- * Encapsulates the refresh token string passed to refresh and logout endpoints.
- */
-export class RefreshTokenDto {
-  @ApiPropertyOptional({
-    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
-    description: 'Refresh token string supplied when the HttpOnly cookie is not available.',
-
-  })
-  @IsOptional()
-  @IsString()
-  @MinLength(10)
-  refreshToken?: string;
-}
+/**
+ * DTO describing the refresh token payload required for token rotation and logout.
+ */
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import { IsOptional, IsString, MinLength } from 'class-validator';
+
+/**
+ * Encapsulates the refresh token string passed to refresh and logout endpoints.
+ */
+export class RefreshTokenDto {
+  @ApiPropertyOptional({
+    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
+    description:
+      'Refresh token string supplied when the HttpOnly cookie is not available.',
+  })
+  @IsOptional()
+  @IsString()
+  @MinLength(10)
+  refreshToken?: string;
+}
diff --git a/apps/api/src/core/auth/guards/hybrid-auth.guard.ts b/apps/api/src/core/auth/guards/hybrid-auth.guard.ts
index 6d0650d..3f4fa1f 100644
--- a/apps/api/src/core/auth/guards/hybrid-auth.guard.ts
+++ b/apps/api/src/core/auth/guards/hybrid-auth.guard.ts
@@ -1,197 +1,197 @@
-/**
- * HybridAuthGuard supports both signed bearer tokens and local development mock headers.
- * It prioritizes JWT verification, only accepting mock headers when explicitly enabled.
- */
-import {
-  CanActivate,
-  ExecutionContext,
-  Injectable,
-  Logger,
-  UnauthorizedException,
-} from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import { Reflector } from '@nestjs/core';
-import { Request } from 'express';
-import { JwtPayload, verify } from 'jsonwebtoken';
-import {
-  CurrentUserPayload,
-} from '@app/common/decorators/current-user.decorator';
-import { IS_PUBLIC_KEY } from '@app/common/decorators/public.decorator';
-import { AllConfig } from '@app/config/config.module';
-import { AuthConfig } from '@app/config/auth.config';
-
-interface MockUserHeaderPayload {
-  id: string;
-  roles?: string[];
-}
-
-interface AccessJwtPayload extends JwtPayload {
-  sub: string;
-  roles?: string[];
-  username?: string;
-}
-
-@Injectable()
-/**
- * Applies hybrid authentication: bearer JWTs in production and optional mock headers in dev.
- */
-export class HybridAuthGuard implements CanActivate {
-  private readonly logger = new Logger(HybridAuthGuard.name);
-  private readonly accessSecret: string;
-
-  constructor(
-    private readonly reflector: Reflector,
-    private readonly config: ConfigService<AllConfig>,
-  ) {
-    const auth = this.config.get<AuthConfig>('auth', { infer: true });
-    if (!auth) {
-      throw new Error('Auth configuration is not available.');
-    }
-    this.accessSecret = auth.accessSecret;
-  }
-
-  /**
-   * Resolves whether a request can proceed by checking public metadata first,
-   * then attempting bearer authentication, and finally falling back to mock headers.
-   * @throws UnauthorizedException when neither bearer nor mock access is allowed.
-   */
-  canActivate(context: ExecutionContext): boolean {
-    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
-      context.getHandler(),
-      context.getClass(),
-    ]);
-
-    const request = context.switchToHttp().getRequest<
-      Request & { user?: CurrentUserPayload }
-    >();
-
-    if (isPublic || this.isPublicPath(request)) {
-      return true;
-    }
-
-    const bearerResult = this.tryAuthenticateWithBearer(request);
-    if (bearerResult) {
-      request.user = bearerResult;
-      return true;
-    }
-
-    if (!this.isMockEnabled()) {
-      throw new UnauthorizedException('توکن دسترسی ارسال نشده است');
-    }
-
-    const mockUser = this.authenticateWithMockHeader(request);
-    request.user = mockUser;
-    return true;
-  }
-
-  /**
-   * Attempts to authenticate via Authorization bearer token and returns a user payload.
-   * @param request Incoming HTTP request.
-   * @returns Current user payload when successful, otherwise null.
-   * @throws UnauthorizedException when the scheme is not bearer or verification fails.
-   */
-  private tryAuthenticateWithBearer(
-    request: Request,
-  ): CurrentUserPayload | null {
-    const authHeader =
-      request.headers.authorization || request.headers.Authorization;
-    if (!authHeader || Array.isArray(authHeader)) {
-      return null;
-    }
-    const [scheme, token] = authHeader.split(' ');
-    if (!token) {
-      return null;
-    }
-    if (scheme?.toLowerCase() !== 'bearer') {
-      throw new UnauthorizedException('نوع احراز هویت پشتیبانی نمی‌شود');
-    }
-    try {
-      const payload = verify(token, this.accessSecret) as AccessJwtPayload;
-      if (!payload.sub) {
-        throw new UnauthorizedException('توکن دسترسی معتبر نیست');
-      }
-      return {
-        id: payload.sub,
-        roles: Array.isArray(payload.roles)
-          ? payload.roles.map((role) => String(role))
-          : [],
-        username: payload.username,
-      };
-    } catch (error) {
-      this.logger.debug(`Failed bearer auth: ${String(error)}`);
-      throw new UnauthorizedException('توکن دسترسی معتبر نیست');
-    }
-  }
-
-  /**
-   * Parses the `x-mock-user` header and returns a user payload for local workflows.
-   * @param request Current request expected to contain the header.
-   * @throws UnauthorizedException when the header is missing or malformed.
-   */
-  private authenticateWithMockHeader(request: Request): CurrentUserPayload {
-    const headerValue = request.headers['x-mock-user'];
-    if (!headerValue) {
-      throw new UnauthorizedException(' x-mock-user   ');
-    }
-
-    const serialized =
-      Array.isArray(headerValue) && headerValue.length > 0
-        ? headerValue[0]
-        : (headerValue as string);
-
-    try {
-      const parsed = JSON.parse(serialized) as MockUserHeaderPayload;
-      if (!parsed?.id || typeof parsed.id !== 'string') {
-        throw new Error('Invalid id');
-      }
-      if (parsed.roles && !Array.isArray(parsed.roles)) {
-        throw new Error('Invalid roles array');
-      }
-      const user: CurrentUserPayload = {
-        id: parsed.id,
-        roles: Array.from(
-          new Set((parsed.roles ?? []).map((role) => String(role))),
-        ),
-        username: undefined,
-      };
-      this.logger.debug(
-        `Authenticated mock user ${user.id} roles=${user.roles.join(',')}`,
-      );
-      return user;
-    } catch (error) {
-      this.logger.warn(`Failed to parse x-mock-user header: ${String(error)}`);
-      throw new UnauthorizedException('  x-mock-user  ');
-    }
-  }
-
-  /**
-   * Whitelists doc, swagger, and health endpoints regardless of auth settings.
-   * @param request Current HTTP request.
-   * @returns True if the path is intentionally public.
-   */
-  private isPublicPath(request: Request): boolean {
-    const path = request.path ?? request.url ?? '';
-    return (
-      path.startsWith('/api/docs') ||
-      path.startsWith('/docs') ||
-      path.startsWith('/swagger-ui') ||
-      path.startsWith('/health')
-    );
-  }
-
-  /**
-   * Checks environment configuration to determine if mock authentication is allowed.
-   * @returns True when the mock header fallback is enabled.
-   */
-  private isMockEnabled(): boolean {
-    const flag = this.config.get<string>('MOCK_AUTH_ENABLED');
-    if (typeof flag === 'string') {
-      return ['1', 'true', 'yes', 'on'].includes(flag.toLowerCase());
-    }
-    const env =
-      this.config.get<string>('NODE_ENV') ??
-      process.env.NODE_ENV ??
-      'development';
-    return env !== 'production';
-  }
-}
+/**
+ * HybridAuthGuard supports both signed bearer tokens and local development mock headers.
+ * It prioritizes JWT verification, only accepting mock headers when explicitly enabled.
+ */
+import {
+  CanActivate,
+  ExecutionContext,
+  Injectable,
+  Logger,
+  UnauthorizedException,
+} from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import { Reflector } from '@nestjs/core';
+import { Request } from 'express';
+import { JwtPayload, verify } from 'jsonwebtoken';
+import {
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { IS_PUBLIC_KEY } from '@app/common/decorators/public.decorator';
+import { AllConfig } from '@app/config/config.module';
+import { AuthConfig } from '@app/config/auth.config';
+
+interface MockUserHeaderPayload {
+  id: string;
+  roles?: string[];
+}
+
+interface AccessJwtPayload extends JwtPayload {
+  sub: string;
+  roles?: string[];
+  username?: string;
+}
+
+@Injectable()
+/**
+ * Applies hybrid authentication: bearer JWTs in production and optional mock headers in dev.
+ */
+export class HybridAuthGuard implements CanActivate {
+  private readonly logger = new Logger(HybridAuthGuard.name);
+  private readonly accessSecret: string;
+
+  constructor(
+    private readonly reflector: Reflector,
+    private readonly config: ConfigService<AllConfig>,
+  ) {
+    const auth = this.config.get<AuthConfig>('auth', { infer: true });
+    if (!auth) {
+      throw new Error('Auth configuration is not available.');
+    }
+    this.accessSecret = auth.accessSecret;
+  }
+
+  /**
+   * Resolves whether a request can proceed by checking public metadata first,
+   * then attempting bearer authentication, and finally falling back to mock headers.
+   * @throws UnauthorizedException when neither bearer nor mock access is allowed.
+   */
+  canActivate(context: ExecutionContext): boolean {
+    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
+      context.getHandler(),
+      context.getClass(),
+    ]);
+
+    const request = context.switchToHttp().getRequest<
+      Request & { user?: CurrentUserPayload }
+    >();
+
+    if (isPublic || this.isPublicPath(request)) {
+      return true;
+    }
+
+    const bearerResult = this.tryAuthenticateWithBearer(request);
+    if (bearerResult) {
+      request.user = bearerResult;
+      return true;
+    }
+
+    if (!this.isMockEnabled()) {
+      throw new UnauthorizedException('توکن دسترسی ارسال نشده است');
+    }
+
+    const mockUser = this.authenticateWithMockHeader(request);
+    request.user = mockUser;
+    return true;
+  }
+
+  /**
+   * Attempts to authenticate via Authorization bearer token and returns a user payload.
+   * @param request Incoming HTTP request.
+   * @returns Current user payload when successful, otherwise null.
+   * @throws UnauthorizedException when the scheme is not bearer or verification fails.
+   */
+  private tryAuthenticateWithBearer(
+    request: Request,
+  ): CurrentUserPayload | null {
+    const authHeader =
+      request.headers.authorization || request.headers.Authorization;
+    if (!authHeader || Array.isArray(authHeader)) {
+      return null;
+    }
+    const [scheme, token] = authHeader.split(' ');
+    if (!token) {
+      return null;
+    }
+    if (scheme?.toLowerCase() !== 'bearer') {
+      throw new UnauthorizedException('نوع احراز هویت پشتیبانی نمی‌شود');
+    }
+    try {
+      const payload = verify(token, this.accessSecret) as AccessJwtPayload;
+      if (!payload.sub) {
+        throw new UnauthorizedException('توکن دسترسی معتبر نیست');
+      }
+      return {
+        id: payload.sub,
+        roles: Array.isArray(payload.roles)
+          ? payload.roles.map((role) => String(role))
+          : [],
+        username: payload.username,
+      };
+    } catch (error) {
+      this.logger.debug(`Failed bearer auth: ${String(error)}`);
+      throw new UnauthorizedException('توکن دسترسی معتبر نیست');
+    }
+  }
+
+  /**
+   * Parses the `x-mock-user` header and returns a user payload for local workflows.
+   * @param request Current request expected to contain the header.
+   * @throws UnauthorizedException when the header is missing or malformed.
+   */
+  private authenticateWithMockHeader(request: Request): CurrentUserPayload {
+    const headerValue = request.headers['x-mock-user'];
+    if (!headerValue) {
+      throw new UnauthorizedException(' x-mock-user   ');
+    }
+
+    const serialized =
+      Array.isArray(headerValue) && headerValue.length > 0
+        ? headerValue[0]
+        : (headerValue as string);
+
+    try {
+      const parsed = JSON.parse(serialized) as MockUserHeaderPayload;
+      if (!parsed?.id || typeof parsed.id !== 'string') {
+        throw new Error('Invalid id');
+      }
+      if (parsed.roles && !Array.isArray(parsed.roles)) {
+        throw new Error('Invalid roles array');
+      }
+      const user: CurrentUserPayload = {
+        id: parsed.id,
+        roles: Array.from(
+          new Set((parsed.roles ?? []).map((role) => String(role))),
+        ),
+        username: undefined,
+      };
+      this.logger.debug(
+        `Authenticated mock user ${user.id} roles=${user.roles.join(',')}`,
+      );
+      return user;
+    } catch (error) {
+      this.logger.warn(`Failed to parse x-mock-user header: ${String(error)}`);
+      throw new UnauthorizedException('  x-mock-user  ');
+    }
+  }
+
+  /**
+   * Whitelists doc, swagger, and health endpoints regardless of auth settings.
+   * @param request Current HTTP request.
+   * @returns True if the path is intentionally public.
+   */
+  private isPublicPath(request: Request): boolean {
+    const path = request.path ?? request.url ?? '';
+    return (
+      path.startsWith('/api/docs') ||
+      path.startsWith('/docs') ||
+      path.startsWith('/swagger-ui') ||
+      path.startsWith('/health')
+    );
+  }
+
+  /**
+   * Checks environment configuration to determine if mock authentication is allowed.
+   * @returns True when the mock header fallback is enabled.
+   */
+  private isMockEnabled(): boolean {
+    const flag = this.config.get<string>('MOCK_AUTH_ENABLED');
+    if (typeof flag === 'string') {
+      return ['1', 'true', 'yes', 'on'].includes(flag.toLowerCase());
+    }
+    const env =
+      this.config.get<string>('NODE_ENV') ??
+      process.env.NODE_ENV ??
+      'development';
+    return env !== 'production';
+  }
+}
diff --git a/apps/api/src/core/auth/guards/jwt-auth.guard.ts b/apps/api/src/core/auth/guards/jwt-auth.guard.ts
index 9ba5ea4..8a3525a 100644
--- a/apps/api/src/core/auth/guards/jwt-auth.guard.ts
+++ b/apps/api/src/core/auth/guards/jwt-auth.guard.ts
@@ -1,130 +1,130 @@
-﻿/**
- * JwtAuthGuard enforces access-token authentication on protected routes by verifying
- * bearer tokens and attaching a minimal user payload to the request for downstream use.
- */
-import {
-  CanActivate,
-  ExecutionContext,
-  Injectable,
-  OnModuleInit,
-  UnauthorizedException,
-} from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import { Request } from 'express';
-import { JwtPayload, verify } from 'jsonwebtoken';
-import { CurrentUserPayload } from '@app/common/decorators/current-user.decorator';
-import { AllConfig } from '@app/config/config.module';
-import { AuthConfig } from '@app/config/auth.config';
-
-interface AccessJwtPayload extends JwtPayload {
-  sub: string;
-  roles?: string[];
-  username?: string;
-}
-
-@Injectable()
-/**
- * Validates bearer access tokens and populates `request.user` with user id and roles.
- */
-export class JwtAuthGuard implements CanActivate, OnModuleInit {
-  private accessSecret =
-    process.env.AUTH_ACCESS_SECRET ?? 'dev_access_secret_for_tests';
-
-  constructor(private readonly config: ConfigService<AllConfig>) {}
-
-  onModuleInit() {
-    const auth = this.config.get<AuthConfig>('auth', { infer: true });
-    if (auth?.accessSecret) {
-      this.accessSecret = auth.accessSecret;
-      return;
-    }
-    if (process.env.AUTH_ACCESS_SECRET) {
-      this.accessSecret = process.env.AUTH_ACCESS_SECRET;
-    }
-  }
-
-  /**
-   * Extracts and verifies the bearer access token, attaching the decoded payload to the request.
-   * @throws UnauthorizedException when the token is absent or invalid.
-   */
-  canActivate(context: ExecutionContext): boolean {
-    const request = context.switchToHttp().getRequest<
-      Request & { user?: CurrentUserPayload }
-    >();
-
-    const token =
-      this.extractBearerToken(request) ?? this.extractCookieToken(request);
-
-    if (!token) {
-      throw new UnauthorizedException('Authorization token not found');
-    }
-
-    const payload = this.verifyToken(token);
-
-    request.user = {
-      id: payload.sub,
-      roles: Array.isArray(payload.roles)
-        ? payload.roles.map((role) => String(role))
-        : [],
-      username: payload.username,
-    };
-
-    return true;
-  }
-
-  /**
-   * Reads the authorization header and returns the bearer token string.
-   * @param request Incoming Express request.
-   * @throws UnauthorizedException when the scheme is present but not bearer.
-   */
-  private extractBearerToken(request: Request): string | null {
-    const authHeader =
-      request.headers.authorization ?? request.headers.Authorization;
-    if (!authHeader || Array.isArray(authHeader)) {
-      return null;
-    }
-    const [scheme, token] = authHeader.split(' ');
-    if (scheme?.toLowerCase() !== 'bearer') {
-      throw new UnauthorizedException('Authorization token not found');
-    }
-    if (!token) {
-      throw new UnauthorizedException('Authorization token not found');
-    }
-    return token;
-  }
-
-  /**
-   * Extracts an access token from HttpOnly cookies when the Authorization header is absent.
-   * @param request Incoming Express request.
-   * @returns JWT string or null when no cookie was provided.
-   */
-  private extractCookieToken(request: Request): string | null {
-    const cookies = (
-      request as Request & {
-        cookies?: Record<string, string | undefined>;
-      }
-    ).cookies;
-    const token = cookies?.access_token;
-    if (typeof token === 'string' && token.length > 0) {
-      return token;
-    }
-    return null;
-  }
-
-  /**
-   * Validates the access token signature and required claims.
-   * @param token Raw JWT string from the header.
-   * @throws UnauthorizedException on signature issues, missing subject, or other verification errors.
-   */
-  private verifyToken(token: string): AccessJwtPayload {
-    try {
-      const payload = verify(token, this.accessSecret) as AccessJwtPayload;
-      if (!payload.sub) {
-        throw new UnauthorizedException('Invalid or expired access token');
-      }
-      return payload;
-    } catch (error) {
-      throw new UnauthorizedException('Invalid or expired access token');
-    }
-  }
-}
+﻿/**
+ * JwtAuthGuard enforces access-token authentication on protected routes by verifying
+ * bearer tokens and attaching a minimal user payload to the request for downstream use.
+ */
+import {
+  CanActivate,
+  ExecutionContext,
+  Injectable,
+  OnModuleInit,
+  UnauthorizedException,
+} from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import { Request } from 'express';
+import { JwtPayload, verify } from 'jsonwebtoken';
+import { CurrentUserPayload } from '@app/common/decorators/current-user.decorator';
+import { AllConfig } from '@app/config/config.module';
+import { AuthConfig } from '@app/config/auth.config';
+
+interface AccessJwtPayload extends JwtPayload {
+  sub: string;
+  roles?: string[];
+  username?: string;
+}
+
+@Injectable()
+/**
+ * Validates bearer access tokens and populates `request.user` with user id and roles.
+ */
+export class JwtAuthGuard implements CanActivate, OnModuleInit {
+  private accessSecret =
+    process.env.AUTH_ACCESS_SECRET ?? 'dev_access_secret_for_tests';
+
+  constructor(private readonly config: ConfigService<AllConfig>) {}
+
+  onModuleInit() {
+    const auth = this.config.get<AuthConfig>('auth', { infer: true });
+    if (auth?.accessSecret) {
+      this.accessSecret = auth.accessSecret;
+      return;
+    }
+    if (process.env.AUTH_ACCESS_SECRET) {
+      this.accessSecret = process.env.AUTH_ACCESS_SECRET;
+    }
+  }
+
+  /**
+   * Extracts and verifies the bearer access token, attaching the decoded payload to the request.
+   * @throws UnauthorizedException when the token is absent or invalid.
+   */
+  canActivate(context: ExecutionContext): boolean {
+    const request = context.switchToHttp().getRequest<
+      Request & { user?: CurrentUserPayload }
+    >();
+
+    const token =
+      this.extractBearerToken(request) ?? this.extractCookieToken(request);
+
+    if (!token) {
+      throw new UnauthorizedException('Authorization token not found');
+    }
+
+    const payload = this.verifyToken(token);
+
+    request.user = {
+      id: payload.sub,
+      roles: Array.isArray(payload.roles)
+        ? payload.roles.map((role) => String(role))
+        : [],
+      username: payload.username,
+    };
+
+    return true;
+  }
+
+  /**
+   * Reads the authorization header and returns the bearer token string.
+   * @param request Incoming Express request.
+   * @throws UnauthorizedException when the scheme is present but not bearer.
+   */
+  private extractBearerToken(request: Request): string | null {
+    const authHeader =
+      request.headers.authorization ?? request.headers.Authorization;
+    if (!authHeader || Array.isArray(authHeader)) {
+      return null;
+    }
+    const [scheme, token] = authHeader.split(' ');
+    if (scheme?.toLowerCase() !== 'bearer') {
+      throw new UnauthorizedException('Authorization token not found');
+    }
+    if (!token) {
+      throw new UnauthorizedException('Authorization token not found');
+    }
+    return token;
+  }
+
+  /**
+   * Extracts an access token from HttpOnly cookies when the Authorization header is absent.
+   * @param request Incoming Express request.
+   * @returns JWT string or null when no cookie was provided.
+   */
+  private extractCookieToken(request: Request): string | null {
+    const cookies = (
+      request as Request & {
+        cookies?: Record<string, string | undefined>;
+      }
+    ).cookies;
+    const token = cookies?.access_token;
+    if (typeof token === 'string' && token.length > 0) {
+      return token;
+    }
+    return null;
+  }
+
+  /**
+   * Validates the access token signature and required claims.
+   * @param token Raw JWT string from the header.
+   * @throws UnauthorizedException on signature issues, missing subject, or other verification errors.
+   */
+  private verifyToken(token: string): AccessJwtPayload {
+    try {
+      const payload = verify(token, this.accessSecret) as AccessJwtPayload;
+      if (!payload.sub) {
+        throw new UnauthorizedException('Invalid or expired access token');
+      }
+      return payload;
+    } catch (error) {
+      throw new UnauthorizedException('Invalid or expired access token');
+    }
+  }
+}
diff --git a/apps/api/src/core/auth/otp/otp-rate-limit.service.ts b/apps/api/src/core/auth/otp/otp-rate-limit.service.ts
index 4d611b7..7234103 100644
--- a/apps/api/src/core/auth/otp/otp-rate-limit.service.ts
+++ b/apps/api/src/core/auth/otp/otp-rate-limit.service.ts
@@ -1,144 +1,144 @@
-import { HttpException, HttpStatus, Inject, Injectable } from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import type Redis from 'ioredis';
-import { createHash } from 'crypto';
-import { OtpChannel, OtpPurpose } from '@prisma/client';
-
-@Injectable()
-export class OtpRateLimitService {
-  constructor(
-    @Inject('REDIS') private readonly redis: Redis,
-    private readonly cfg: ConfigService,
-  ) {}
-
-  // --- helpers ---
-
-  /** کوتاه‌سازی SHA-256 تا 40 کاراکتر برای استفاده در کلید Redis */
-  private h(v: string): string {
-    return createHash('sha256').update(v).digest('hex').slice(0, 40);
-  }
-
-  /** ساخت کلید نام‌فضادار بدون PII (identifier/ip هش می‌شود) */
-  private key(
-    scope: 'req' | 'ver', // request or verify
-    subject: 'id' | 'ip', // identifier or ip
-    value: string, // raw identifier or raw ip
-    channel?: OtpChannel,
-    purpose?: OtpPurpose | string,
-  ): string {
-    const parts = ['otp', 'rl', scope, subject, this.h(value)];
-    if (channel) parts.push(String(channel));
-    if (purpose) parts.push(String(purpose));
-    return parts.join(':'); // e.g. otp:rl:req:id:abc123:sms:login
-  }
-
-  /** افزایش شمارنده و ست کردن TTL در اولین ضربه (fixed window ساده) */
-  private async bump(
-    key: string,
-    windowSec: number,
-  ): Promise<{ count: number; ttl: number }> {
-    const count = await this.redis.incr(key);
-    if (count === 1) {
-      await this.redis.expire(key, windowSec);
-    }
-    const ttl = await this.redis.ttl(key);
-    return { count, ttl: Math.max(ttl, 0) };
-  }
-
-  // --- public API ---
-
-  /**
-   * مصرف سهمیهٔ درخواست OTP برای شناسه و (اختیاری) IP.
-   * اگر هرکدام از سقف عبور کنند، 429 می‌دهد.
-   */
-  async consumeRequestBucket(
-    identifier: string,
-    ip?: string,
-    channel?: OtpChannel,
-    purpose?: OtpPurpose | string,
-  ): Promise<void> {
-    const win = Number(this.cfg.get('OTP_REQUEST_WINDOW') ?? 60);
-    const maxId = Number(this.cfg.get('OTP_REQUEST_MAX') ?? 3);
-    const maxIp = Number(this.cfg.get('OTP_REQUEST_IP_MAX') ?? 10);
-
-    // per-identifier
-    {
-      const idKey = this.key('req', 'id', identifier, channel, purpose);
-      const { count } = await this.bump(idKey, win);
-      if (count > maxId) {
-        throw new HttpException(
-          {
-            code: 'TooManyRequests',
-            message:
-              'تعداد درخواست‌های ارسال کد بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
-          },
-          HttpStatus.TOO_MANY_REQUESTS,
-        );
-      }
-    }
-
-    // per-ip (اختیاری)
-    if (ip) {
-      const ipKey = this.key('req', 'ip', ip, channel, purpose);
-      const { count } = await this.bump(ipKey, win);
-      if (count > maxIp) {
-        throw new HttpException(
-          {
-            code: 'TooManyRequests',
-            message:
-              'تعداد درخواست‌های این IP بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
-          },
-          HttpStatus.TOO_MANY_REQUESTS,
-        );
-      }
-    }
-  }
-
-  /**
-   * مصرف سهمیهٔ تأیید OTP برای شناسه و (اختیاری) IP.
-   * اگر هرکدام از سقف عبور کنند، 429 می‌دهد.
-   * معمولاً پنجرهٔ VERIFY برابر TTL خود OTP در نظر گرفته می‌شود.
-   */
-  async consumeVerifyBucket(
-    identifier: string,
-    ip?: string,
-    channel?: OtpChannel,
-    purpose?: OtpPurpose | string,
-  ): Promise<void> {
-    const win = Number(this.cfg.get('OTP_VERIFY_WINDOW') ?? 120);
-    const maxId = Number(this.cfg.get('OTP_VERIFY_MAX') ?? 5);
-    const maxIp = Number(this.cfg.get('OTP_VERIFY_IP_MAX') ?? 30);
-
-    // per-identifier
-    {
-      const idKey = this.key('ver', 'id', identifier, channel, purpose);
-      const { count } = await this.bump(idKey, win);
-      if (count > maxId) {
-        throw new HttpException(
-          {
-            code: 'TooManyRequests',
-            message:
-              'تعداد تلاش‌های تأیید کد بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
-          },
-          HttpStatus.TOO_MANY_REQUESTS,
-        );
-      }
-    }
-
-    // per-ip (اختیاری)
-    if (ip) {
-      const ipKey = this.key('ver', 'ip', ip, channel, purpose);
-      const { count } = await this.bump(ipKey, win);
-      if (count > maxIp) {
-        throw new HttpException(
-          {
-            code: 'TooManyRequests',
-            message:
-              'تعداد تلاش‌های تأیید کد از این IP بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
-          },
-          HttpStatus.TOO_MANY_REQUESTS,
-        );
-      }
-    }
-  }
-}
+import { HttpException, HttpStatus, Inject, Injectable } from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import type Redis from 'ioredis';
+import { createHash } from 'crypto';
+import { OtpChannel, OtpPurpose } from '@prisma/client';
+
+@Injectable()
+export class OtpRateLimitService {
+  constructor(
+    @Inject('REDIS') private readonly redis: Redis,
+    private readonly cfg: ConfigService,
+  ) {}
+
+  // --- helpers ---
+
+  /** کوتاه‌سازی SHA-256 تا 40 کاراکتر برای استفاده در کلید Redis */
+  private h(v: string): string {
+    return createHash('sha256').update(v).digest('hex').slice(0, 40);
+  }
+
+  /** ساخت کلید نام‌فضادار بدون PII (identifier/ip هش می‌شود) */
+  private key(
+    scope: 'req' | 'ver', // request or verify
+    subject: 'id' | 'ip', // identifier or ip
+    value: string, // raw identifier or raw ip
+    channel?: OtpChannel,
+    purpose?: OtpPurpose | string,
+  ): string {
+    const parts = ['otp', 'rl', scope, subject, this.h(value)];
+    if (channel) parts.push(String(channel));
+    if (purpose) parts.push(String(purpose));
+    return parts.join(':'); // e.g. otp:rl:req:id:abc123:sms:login
+  }
+
+  /** افزایش شمارنده و ست کردن TTL در اولین ضربه (fixed window ساده) */
+  private async bump(
+    key: string,
+    windowSec: number,
+  ): Promise<{ count: number; ttl: number }> {
+    const count = await this.redis.incr(key);
+    if (count === 1) {
+      await this.redis.expire(key, windowSec);
+    }
+    const ttl = await this.redis.ttl(key);
+    return { count, ttl: Math.max(ttl, 0) };
+  }
+
+  // --- public API ---
+
+  /**
+   * مصرف سهمیهٔ درخواست OTP برای شناسه و (اختیاری) IP.
+   * اگر هرکدام از سقف عبور کنند، 429 می‌دهد.
+   */
+  async consumeRequestBucket(
+    identifier: string,
+    ip?: string,
+    channel?: OtpChannel,
+    purpose?: OtpPurpose | string,
+  ): Promise<void> {
+    const win = Number(this.cfg.get('OTP_REQUEST_WINDOW') ?? 60);
+    const maxId = Number(this.cfg.get('OTP_REQUEST_MAX') ?? 3);
+    const maxIp = Number(this.cfg.get('OTP_REQUEST_IP_MAX') ?? 10);
+
+    // per-identifier
+    {
+      const idKey = this.key('req', 'id', identifier, channel, purpose);
+      const { count } = await this.bump(idKey, win);
+      if (count > maxId) {
+        throw new HttpException(
+          {
+            code: 'TooManyRequests',
+            message:
+              'تعداد درخواست‌های ارسال کد بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
+          },
+          HttpStatus.TOO_MANY_REQUESTS,
+        );
+      }
+    }
+
+    // per-ip (اختیاری)
+    if (ip) {
+      const ipKey = this.key('req', 'ip', ip, channel, purpose);
+      const { count } = await this.bump(ipKey, win);
+      if (count > maxIp) {
+        throw new HttpException(
+          {
+            code: 'TooManyRequests',
+            message:
+              'تعداد درخواست‌های این IP بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
+          },
+          HttpStatus.TOO_MANY_REQUESTS,
+        );
+      }
+    }
+  }
+
+  /**
+   * مصرف سهمیهٔ تأیید OTP برای شناسه و (اختیاری) IP.
+   * اگر هرکدام از سقف عبور کنند، 429 می‌دهد.
+   * معمولاً پنجرهٔ VERIFY برابر TTL خود OTP در نظر گرفته می‌شود.
+   */
+  async consumeVerifyBucket(
+    identifier: string,
+    ip?: string,
+    channel?: OtpChannel,
+    purpose?: OtpPurpose | string,
+  ): Promise<void> {
+    const win = Number(this.cfg.get('OTP_VERIFY_WINDOW') ?? 120);
+    const maxId = Number(this.cfg.get('OTP_VERIFY_MAX') ?? 5);
+    const maxIp = Number(this.cfg.get('OTP_VERIFY_IP_MAX') ?? 30);
+
+    // per-identifier
+    {
+      const idKey = this.key('ver', 'id', identifier, channel, purpose);
+      const { count } = await this.bump(idKey, win);
+      if (count > maxId) {
+        throw new HttpException(
+          {
+            code: 'TooManyRequests',
+            message:
+              'تعداد تلاش‌های تأیید کد بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
+          },
+          HttpStatus.TOO_MANY_REQUESTS,
+        );
+      }
+    }
+
+    // per-ip (اختیاری)
+    if (ip) {
+      const ipKey = this.key('ver', 'ip', ip, channel, purpose);
+      const { count } = await this.bump(ipKey, win);
+      if (count > maxIp) {
+        throw new HttpException(
+          {
+            code: 'TooManyRequests',
+            message:
+              'تعداد تلاش‌های تأیید کد از این IP بیش از حد مجاز است. لطفاً بعداً دوباره تلاش کنید.',
+          },
+          HttpStatus.TOO_MANY_REQUESTS,
+        );
+      }
+    }
+  }
+}
diff --git a/apps/api/src/core/auth/otp/otp.controller.ts b/apps/api/src/core/auth/otp/otp.controller.ts
index 1e78d40..7d609d7 100644
--- a/apps/api/src/core/auth/otp/otp.controller.ts
+++ b/apps/api/src/core/auth/otp/otp.controller.ts
@@ -4,38 +4,48 @@ import {
   Body,
   Req,
   Res,
-  HttpCode,
   Headers,
+  HttpCode,
+  UsePipes,
+  ValidationPipe,
 } from '@nestjs/common';
 import {
   ApiTags,
   ApiOperation,
   ApiOkResponse,
-  ApiResponse,
+  ApiBadRequestResponse,
+  ApiConflictResponse,
+  ApiTooManyRequestsResponse,
 } from '@nestjs/swagger';
 import type { Request, Response } from 'express';
 import { Public } from '@app/common/decorators/public.decorator';
-import { OtpService } from './otp.service';
-import { RequestOtpDto } from '../dto/otp/otp-request.dto';
-import { ResendOtpDto } from '../dto/otp/otp-resend.dto';
-import { VerifyOtpDto } from '../dto/otp/otp-verify.dto';
-import { OtpPurpose } from '@prisma/client';
+import { OtpService } from '@app/core/auth/otp/otp.service';
+import { RequestOtpDto } from '@app/core/auth/dto/otp/otp-request.dto';
+import { ResendOtpDto } from '@app/core/auth/dto/otp/otp-resend.dto';
+import { VerifyOtpDto } from '@app/core/auth/dto/otp/otp-verify.dto';
 
 @ApiTags('Authentication - OTP')
 @Controller('auth/otp')
 export class OtpController {
   constructor(private readonly otp: OtpService) {}
 
-  // ─────────────────────────────────────────────
-  // 1) درخواست ارسال کد (Signup / Login / Reset)
-  // ─────────────────────────────────────────────
+  /* ------------------------------------------------------------------ *
+   * 1) Request OTP (signup / login / reset)
+   * ------------------------------------------------------------------ */
   @Public()
   @Post('request')
   @HttpCode(200)
+  @UsePipes(
+    new ValidationPipe({
+      whitelist: true,
+      forbidNonWhitelisted: true,
+      transform: true, // DTO ها را به enum/نوع درست تبدیل می‌کند
+    }),
+  )
   @ApiOperation({
-    summary: 'Request a 6-digit OTP code via SMS or Email',
+    summary: 'Request a 6-digit OTP via SMS or Email',
     description:
-      'ارسال یا بازیابی کد تأیید ۶ رقمی. اگر کدی هنوز فعال است، تایمرها برمی‌گردند.',
+      'اگر کد فعال باشد، فقط تایمرها برمی‌گردند؛ وگرنه کد جدید صادر و ارسال می‌شود.',
   })
   @ApiOkResponse({
     schema: {
@@ -49,21 +59,32 @@ export class OtpController {
       },
     },
   })
+  @ApiBadRequestResponse({
+    description:
+      'در حالت‌های ورودی نامعتبر، یا برای login/reset وقتی کاربر وجود ندارد (USER_NOT_FOUND).',
+  })
+  @ApiConflictResponse({
+    description: 'برای signup اگر کاربر از قبل وجود دارد (USER_EXISTS).',
+  })
+  @ApiTooManyRequestsResponse({
+    description: 'ریفریش/ورودی بیش از حد (ریتلجیک).',
+  })
   async request(
     @Body() dto: RequestOtpDto,
     @Req() req: Request,
     @Res({ passthrough: true }) res: Response,
     @Headers('user-agent') ua?: string,
   ) {
+    // ⚠️ هیچ fallback برای purpose نگذار؛ ValidationPipe تضمین می‌کند معتبر/حاضر باشد
     const out = await this.otp.requestOtp(
       dto.channel,
       dto.identifier,
-      dto.purpose ?? OtpPurpose.login,
+      dto.purpose,
       this.getIp(req),
       ua,
     );
 
-    // اگر کد فعال بود → هدر Retry-After تنظیم شود
+    // UX headers
     if (
       out?.data?.alreadyActive &&
       typeof out.data.resendAvailableIn === 'number' &&
@@ -71,24 +92,41 @@ export class OtpController {
     ) {
       res.setHeader('Retry-After', String(out.data.resendAvailableIn));
     }
-
     res.setHeader('Cache-Control', 'no-store');
     res.setHeader('Vary', 'Cookie');
     return out;
   }
 
-  // ─────────────────────────────────────────────
-  // 2) بازارسال OTP (بدون تغییر purpose)
-  // ─────────────────────────────────────────────
+  /* ------------------------------------------------------------------ *
+   * 2) Resend active OTP (respects cooldown)
+   * ------------------------------------------------------------------ */
   @Public()
   @Post('resend')
   @HttpCode(200)
+  @UsePipes(
+    new ValidationPipe({
+      whitelist: true,
+      forbidNonWhitelisted: true,
+      transform: true,
+    }),
+  )
   @ApiOperation({
-    summary: 'Resend active OTP code (respects cooldown)',
+    summary: 'Resend the active OTP (if cooldown passed)',
     description:
-      'بازارسال کد فعال در صورت گذشت کول‌داون. در غیر اینصورت، تایمرها برمی‌گردند.',
+      'اگر کد فعال نباشد، رفتار مثل request است؛ اگر کول‌داون تمام نشده باشد، تایمر برگردانده می‌شود.',
+  })
+  @ApiOkResponse({
+    schema: {
+      example: {
+        success: true,
+        data: {
+          alreadyActive: true,
+          expiresIn: 240,
+          resendAvailableIn: 55,
+        },
+      },
+    },
   })
-  @ApiResponse({ status: 200 })
   async resend(
     @Body() dto: ResendOtpDto,
     @Req() req: Request,
@@ -98,12 +136,11 @@ export class OtpController {
     const out = await this.otp.resendOtp(
       dto.channel,
       dto.identifier,
-      dto.purpose ?? OtpPurpose.login,
+      dto.purpose,
       this.getIp(req),
       ua,
     );
 
-    // تنظیم هدرها برای UX
     if (
       out?.data?.alreadyActive &&
       typeof out.data.resendAvailableIn === 'number' &&
@@ -111,22 +148,28 @@ export class OtpController {
     ) {
       res.setHeader('Retry-After', String(out.data.resendAvailableIn));
     }
-
     res.setHeader('Cache-Control', 'no-store');
     res.setHeader('Vary', 'Cookie');
     return out;
   }
 
-  // ─────────────────────────────────────────────
-  // 3) بررسی OTP و صدور تیکت (JWT ticket)
-  // ─────────────────────────────────────────────
+  /* ------------------------------------------------------------------ *
+   * 3) Verify OTP and issue ticket (JWT)
+   * ------------------------------------------------------------------ */
   @Public()
   @Post('verify')
   @HttpCode(200)
+  @UsePipes(
+    new ValidationPipe({
+      whitelist: true,
+      forbidNonWhitelisted: true,
+      transform: true,
+    }),
+  )
   @ApiOperation({
-    summary: 'Verify a 6-digit OTP and issue a temporary ticket',
+    summary: 'Verify 6-digit OTP and return a temporary JWT ticket',
     description:
-      'اعتبارسنجی کد ۶ رقمی و صدور تیکت یک‌بارمصرف (JWT) برای مرحله‌ی بعدی مانند set-password.',
+      'پس از موفقیت، تیکت یک‌بارمصرف برای مرحله بعد (set/reset password) صادر می‌شود.',
   })
   @ApiOkResponse({
     schema: {
@@ -150,19 +193,16 @@ export class OtpController {
       dto.channel,
       dto.identifier,
       dto.code,
-      dto.purpose ?? OtpPurpose.login,
+      dto.purpose,
       this.getIp(req),
       ua,
     );
-
     res.setHeader('Cache-Control', 'no-store');
     res.setHeader('Vary', 'Cookie');
     return out;
   }
 
-  // ─────────────────────────────────────────────
-  // Helper برای تشخیص IP کاربر (proxy-aware)
-  // ─────────────────────────────────────────────
+  /* ----------------------------- helper ----------------------------- */
   private getIp(req: Request): string | undefined {
     const ip =
       (req.headers['cf-connecting-ip'] as string) ||
diff --git a/apps/api/src/core/auth/otp/otp.service.ts b/apps/api/src/core/auth/otp/otp.service.ts
index 9010c0c..3ee3c2f 100644
--- a/apps/api/src/core/auth/otp/otp.service.ts
+++ b/apps/api/src/core/auth/otp/otp.service.ts
@@ -2,18 +2,43 @@ import {
   Injectable,
   BadRequestException,
   ForbiddenException,
+  ConflictException,
+  NotFoundException,
   Inject,
 } from '@nestjs/common';
 import { ConfigService } from '@nestjs/config';
-import { sign, SignOptions } from 'jsonwebtoken';
-import * as crypto from 'crypto';
+import { OtpChannel, OtpPurpose } from '@prisma/client';
 import type Redis from 'ioredis';
+import * as crypto from 'crypto';
+import { sign, type SignOptions } from 'jsonwebtoken';
+
 import { SmsService } from '@app/sms/sms.service';
 import { MailService } from '@app/mail/mail.service';
-import { OtpRateLimitService } from './otp-rate-limit.service';
-import { OtpChannel, OtpPurpose } from '@prisma/client';
+import { OtpRateLimitService } from '@app/core/auth/otp/otp-rate-limit.service';
+import type { UserLookup } from '@app/core/auth/otp/user-lookup.provider';
+
+/* ───────────── Types ───────────── */
+type RedisHash = Record<string, string>;
 
-export interface AuditService {
+type RequestOtpResult = {
+  success: true;
+  data: {
+    alreadyActive: boolean;
+    expiresIn: number;
+    resendAvailableIn: number;
+  };
+};
+
+type VerifyOtpResult = {
+  success: true;
+  data: {
+    ticket: string;
+    next: 'set-password' | 'reset-password';
+    expiresIn: number;
+  };
+};
+
+interface AuditService {
   log(
     action: string,
     data: {
@@ -26,11 +51,7 @@ export interface AuditService {
   ): Promise<void>;
 }
 
-type RedisHash = Record<string, string>;
-
-// ───────────────────────────────
-// Helpers
-// ───────────────────────────────
+/* ───────────── Helpers ───────────── */
 function sha256Hex(v: string): string {
   return crypto.createHash('sha256').update(v).digest('hex');
 }
@@ -42,25 +63,29 @@ function nowEpoch(): number {
 }
 function normalizeIdentifier(channel: OtpChannel, raw: string): string {
   let v = (raw ?? '').trim();
-  if (channel === OtpChannel.sms && typeof v === 'string')
-    v = v.replace(/\s+/g, '');
-  if (channel === OtpChannel.email && typeof v === 'string')
-    v = v.toLowerCase();
+  if (channel === OtpChannel.sms) v = v.replace(/\s+/g, '');
+  if (channel === OtpChannel.email) v = v.toLowerCase();
   return v;
 }
+function isValidPurpose(p: unknown): p is OtpPurpose {
+  return (
+    typeof p === 'string' && (p === 'signup' || p === 'login' || p === 'reset')
+  );
+}
 
 @Injectable()
 export class OtpService {
-  // ---------- Config ----------
+  /* ---- Runtime config ---- */
   private readonly OTP_TTL: number;
   private readonly RESEND_COOLDOWN: number;
   private readonly OTP_MAX_ATTEMPTS: number;
+
+  // (تعمدی نگه داشته شده برای توسعه‌های بعدی)
   private readonly OTP_MAX_RESENDS_PER_CODE: number;
   private readonly OTP_MIN_REGEN_IF_REMAINING: number;
 
-  // Ticket
+  /* ---- Ticket (JWT) ---- */
   private readonly TICKET_SECRET: string;
-  private readonly TICKET_EXPIRES: string;
   private readonly TICKET_TTL_SEC: number;
   private readonly TICKET_ISSUER = 'negare-auth';
   private readonly TICKET_AUDIENCE = 'negare-core';
@@ -72,10 +97,12 @@ export class OtpService {
     private readonly mail: MailService,
     @Inject('REDIS') private readonly redis: Redis,
     @Inject('AuditService') private readonly audit?: AuditService,
+    @Inject('UserLookup') private readonly users?: UserLookup,
   ) {
-    this.OTP_TTL = Number(this.config.get('OTP_VERIFY_WINDOW') ?? 300);
-    this.RESEND_COOLDOWN = Number(this.config.get('OTP_REQUEST_WINDOW') ?? 120);
+    this.OTP_TTL = Number(this.config.get('OTP_VERIFY_WINDOW') ?? 300); // 5m
+    this.RESEND_COOLDOWN = Number(this.config.get('OTP_REQUEST_WINDOW') ?? 120); // 2m
     this.OTP_MAX_ATTEMPTS = Number(this.config.get('OTP_VERIFY_MAX') ?? 5);
+
     this.OTP_MAX_RESENDS_PER_CODE = Number(
       this.config.get('OTP_MAX_RESENDS_PER_CODE') ?? 3,
     );
@@ -83,25 +110,39 @@ export class OtpService {
       this.config.get('OTP_MIN_REGEN_IF_REMAINING_SECONDS') ?? 60,
     );
 
+    const expRaw = this.config.get<string>('SET_PWD_JWT_EXPIRES') ?? '10m';
     this.TICKET_SECRET = this.config.getOrThrow<string>('SET_PWD_JWT_SECRET');
-    this.TICKET_EXPIRES =
-      this.config.get<string>('SET_PWD_JWT_EXPIRES') ?? '10m';
-    this.TICKET_TTL_SEC = this.parseDurationToSeconds(this.TICKET_EXPIRES);
+    this.TICKET_TTL_SEC = this.parseDurationToSeconds(expRaw);
   }
 
-  // ───────────────────────────────
-  // Public APIs
-  // ───────────────────────────────
+  /* ─────────────────────── Public APIs ─────────────────────── */
 
+  /**
+   * Request OTP
+   * - signup: اگر کاربر موجود است → 409 USER_EXISTS
+   * - reset/login: اگر کاربر موجود نیست → 404 USER_NOT_FOUND
+   */
   async requestOtp(
     channel: OtpChannel,
     rawIdentifier: string,
     purpose: OtpPurpose = OtpPurpose.login,
     requestIp?: string,
     userAgent?: string,
-  ) {
+  ): Promise<RequestOtpResult> {
     const identifier = normalizeIdentifier(channel, rawIdentifier);
 
+    // purpose guard
+    if (!isValidPurpose(purpose)) {
+      throw new BadRequestException({
+        success: false,
+        error: {
+          code: 'INVALID_PURPOSE',
+          message: 'purpose must be one of signup|login|reset',
+        },
+      });
+    }
+
+    // request level rate-limit
     await this.rateLimit.consumeRequestBucket(
       identifier,
       requestIp,
@@ -109,26 +150,65 @@ export class OtpService {
       purpose,
     );
 
+    // temporary block (too many attempts)
     if (await this.redis.exists(this.keyBlock(purpose, channel, identifier))) {
-      throw new ForbiddenException('Too many attempts. Try again later.');
+      throw new ForbiddenException({
+        success: false,
+        error: {
+          code: 'OTP_TEMP_BLOCKED',
+          message: 'Too many attempts. Try again later.',
+        },
+      });
+    }
+
+    // presence guard (if provider is bound)
+    if (this.users) {
+      const exists = await this.users.exists(channel, identifier);
+      if (purpose === OtpPurpose.signup && exists) {
+        throw new ConflictException({
+          success: false,
+          error: {
+            code: 'USER_EXISTS',
+            message: 'This identifier is already registered.',
+          },
+        });
+      }
+      if (
+        (purpose === OtpPurpose.reset || purpose === OtpPurpose.login) &&
+        !exists
+      ) {
+        throw new NotFoundException({
+          success: false,
+          error: {
+            code: 'USER_NOT_FOUND',
+            message: 'No account matches this identifier.',
+          },
+        });
+      }
     }
 
     const activeKey = this.keyActive(purpose, channel, identifier);
     const cooldownKey = this.keyCooldown(purpose, channel, identifier);
     const now = nowEpoch();
 
-    let hash: RedisHash | null = await this.redis.hgetall(activeKey);
-    if (hash && Object.keys(hash).length === 0) hash = null;
-
+    // If an active code exists
+    const hash = await this.readActiveHash(activeKey);
     if (hash) {
       const resendAt = Number(hash.resendAt ?? '0');
       const exp = Number(hash.exp ?? '0');
       const resendRemaining = Math.max(0, resendAt - now);
       const expiresIn = Math.max(0, exp - now);
 
+      // still in cooldown → just return timers
       if (resendRemaining > 0) {
+        await this.audit?.log('OTP_REQUEST_HIT_COOLDOWN', {
+          meta: { channel, purpose },
+          ipHash: this.maskIp(requestIp),
+          uaHash: this.hashUa(userAgent),
+        });
+
         return {
-          success: true as const,
+          success: true,
           data: {
             alreadyActive: true,
             expiresIn,
@@ -136,16 +216,27 @@ export class OtpService {
           },
         };
       }
-    }
 
-    await this.issueNewCode(
-      channel,
-      identifier,
-      purpose,
-      requestIp,
-      activeKey,
-      cooldownKey,
-    );
+      // cooldown passed → regenerate a new code
+      await this.issueNewCode(
+        channel,
+        identifier,
+        purpose,
+        requestIp,
+        activeKey,
+        cooldownKey,
+      );
+    } else {
+      // fresh issue
+      await this.issueNewCode(
+        channel,
+        identifier,
+        purpose,
+        requestIp,
+        activeKey,
+        cooldownKey,
+      );
+    }
 
     await this.audit?.log('OTP_REQUEST', {
       meta: { channel, purpose },
@@ -154,7 +245,7 @@ export class OtpService {
     });
 
     return {
-      success: true as const,
+      success: true,
       data: {
         alreadyActive: false,
         expiresIn: this.OTP_TTL,
@@ -163,6 +254,9 @@ export class OtpService {
     };
   }
 
+  /**
+   * Verify OTP and issue a short-lived ticket
+   */
   async verifyOtp(
     channel: OtpChannel,
     rawIdentifier: string,
@@ -170,9 +264,19 @@ export class OtpService {
     purpose: OtpPurpose = OtpPurpose.login,
     requestIp?: string,
     userAgent?: string,
-  ) {
+  ): Promise<VerifyOtpResult> {
     const identifier = normalizeIdentifier(channel, rawIdentifier);
 
+    if (!isValidPurpose(purpose)) {
+      throw new BadRequestException({
+        success: false,
+        error: {
+          code: 'INVALID_PURPOSE',
+          message: 'purpose must be one of signup|login|reset',
+        },
+      });
+    }
+
     await this.rateLimit.consumeVerifyBucket(
       identifier,
       requestIp,
@@ -184,19 +288,31 @@ export class OtpService {
     const blockKey = this.keyBlock(purpose, channel, identifier);
 
     if (await this.redis.exists(blockKey)) {
-      throw new ForbiddenException('Too many attempts. Try again later.');
+      throw new ForbiddenException({
+        success: false,
+        error: {
+          code: 'OTP_TEMP_BLOCKED',
+          message: 'Too many attempts. Try again later.',
+        },
+      });
     }
 
-    const hash = await this.redis.hgetall(activeKey);
-    if (!hash || Object.keys(hash).length === 0) {
-      throw new BadRequestException('Invalid or expired code.');
+    const hash = await this.readActiveHash(activeKey);
+    if (!hash) {
+      throw new BadRequestException({
+        success: false,
+        error: { code: 'OTP_INVALID', message: 'Invalid or expired code.' },
+      });
     }
 
     const now = nowEpoch();
     const exp = Number(hash.exp ?? '0');
     if (exp <= now) {
       await this.redis.del(activeKey);
-      throw new BadRequestException('Invalid or expired code.');
+      throw new BadRequestException({
+        success: false,
+        error: { code: 'OTP_EXPIRED', message: 'Invalid or expired code.' },
+      });
     }
 
     const attempts = await this.redis.hincrby(activeKey, 'attempts', 1);
@@ -207,15 +323,24 @@ export class OtpService {
         .del(activeKey)
         .set(blockKey, '1', 'EX', this.blockWindowSeconds())
         .exec();
-      throw new ForbiddenException('Too many attempts. Try again later.');
+      throw new ForbiddenException({
+        success: false,
+        error: {
+          code: 'OTP_TEMP_BLOCKED',
+          message: 'Too many attempts. Try again later.',
+        },
+      });
     }
 
-    const ok = hash.codeHash === sha256Hex(code);
+    const ok = hash.codeHash === sha256Hex(String(code));
     if (!ok) {
-      throw new BadRequestException('Invalid or expired code.');
+      throw new BadRequestException({
+        success: false,
+        error: { code: 'OTP_INVALID', message: 'Invalid or expired code.' },
+      });
     }
 
-    // موفقیت: پاکسازی و صدور تیکت
+    // success → issue ticket
     const jti = crypto.randomUUID();
     const payload = { purpose, channel, identifier };
     const opts: SignOptions = {
@@ -227,7 +352,6 @@ export class OtpService {
     };
     const ticket = sign(payload, this.TICKET_SECRET, opts);
 
-    // ✅ ذخیره هش تیکت (برای هماهنگی با PasswordService)
     await this.redis
       .multi()
       .del(activeKey)
@@ -242,7 +366,7 @@ export class OtpService {
     });
 
     return {
-      success: true as const,
+      success: true,
       data: {
         ticket,
         next: purpose === OtpPurpose.reset ? 'reset-password' : 'set-password',
@@ -251,110 +375,28 @@ export class OtpService {
     };
   }
 
-  // ───────────────────────────────
-  // Helpers
-  // ───────────────────────────────
-  private async issueNewCode(
-    channel: OtpChannel,
-    identifier: string,
-    purpose: OtpPurpose,
-    requestIp: string | undefined,
-    activeKey: string,
-    cooldownKey: string,
-  ): Promise<void> {
-    const now = nowEpoch();
-    const code = random6Digits();
-    const multi = this.redis.multi();
-
-    multi.hset(activeKey, {
-      codeHash: sha256Hex(code),
-      attempts: '0',
-      maxAttempts: String(this.OTP_MAX_ATTEMPTS),
-      exp: String(now + this.OTP_TTL),
-      resendAt: String(now + this.RESEND_COOLDOWN),
-      sendCount: '1',
-      ip: this.maskIp(requestIp) ?? '',
-      ch: channel,
-      pu: purpose,
-    });
-    multi.expire(activeKey, this.OTP_TTL);
-    multi.set(cooldownKey, '1', 'EX', this.RESEND_COOLDOWN);
-
-    await multi.exec();
-
-    // ارسال کد
-    if (channel === OtpChannel.sms) {
-      await this.sms.sendOtp(identifier, code);
-    } else {
-      await this.mail.sendOtp(identifier, code);
-    }
-  }
-
-  private keyBase(
-    purpose: OtpPurpose,
-    channel: OtpChannel,
-    identifier: string,
-  ): string {
-    const idHash = sha256Hex(`${purpose}|${channel}|${identifier}`).slice(
-      0,
-      40,
-    );
-    return `otp:${idHash}`;
-  }
-  private keyActive(
-    purpose: OtpPurpose,
-    channel: OtpChannel,
-    identifier: string,
-  ): string {
-    return this.keyBase(purpose, channel, identifier);
-  }
-  private keyCooldown(
-    purpose: OtpPurpose,
-    channel: OtpChannel,
-    identifier: string,
-  ): string {
-    return `${this.keyBase(purpose, channel, identifier)}:cd`;
-  }
-  private keyBlock(
-    purpose: OtpPurpose,
-    channel: OtpChannel,
-    identifier: string,
-  ): string {
-    return `${this.keyBase(purpose, channel, identifier)}:blk`;
-  }
-  private keyTicket(jti: string): string {
-    return `otp:ticket:${jti}`;
-  }
-
-  private parseDurationToSeconds(s: string): number {
-    const m = /^(\d+)([smh])$/.exec(String(s).trim());
-    if (!m) return Number(s) || 600;
-    const n = Number(m[1]);
-    return m[2] === 's' ? n : m[2] === 'm' ? n * 60 : n * 3600;
-  }
-
-  private blockWindowSeconds(): number {
-    return Number(this.config.get('OTP_BLOCK_WINDOW') ?? 900);
-  }
-
-  private maskIp(ip?: string): string | undefined {
-    if (!ip) return undefined;
-    const parts = ip.split('.');
-    return parts.length === 4 ? `${parts[0]}.${parts[1]}.${parts[2]}.0/24` : ip;
-  }
-  private hashUa(ua?: string): string | undefined {
-    return ua ? sha256Hex(ua).slice(0, 32) : undefined;
-  }
-
+  /**
+   * Resend OTP (respect cooldown). If no active code, behaves like requestOtp.
+   */
   async resendOtp(
     channel: OtpChannel,
     rawIdentifier: string,
     purpose: OtpPurpose = OtpPurpose.login,
     requestIp?: string,
     userAgent?: string,
-  ) {
+  ): Promise<RequestOtpResult> {
     const identifier = normalizeIdentifier(channel, rawIdentifier);
 
+    if (!isValidPurpose(purpose)) {
+      throw new BadRequestException({
+        success: false,
+        error: {
+          code: 'INVALID_PURPOSE',
+          message: 'purpose must be one of signup|login|reset',
+        },
+      });
+    }
+
     await this.rateLimit.consumeRequestBucket(
       identifier,
       requestIp,
@@ -366,12 +408,9 @@ export class OtpService {
     const cooldownKey = this.keyCooldown(purpose, channel, identifier);
     const now = nowEpoch();
 
-    let hash: Record<string, string> | null =
-      await this.redis.hgetall(activeKey);
-    if (hash && Object.keys(hash).length === 0) hash = null;
-
+    const hash = await this.readActiveHash(activeKey);
     if (!hash) {
-      // اگر کدی فعال نیست، مثل request رفتار کن
+      // no active → same as request
       return this.requestOtp(
         channel,
         identifier,
@@ -388,7 +427,7 @@ export class OtpService {
     if (resendRemaining > 0) {
       const expiresIn = Math.max(0, exp - now);
       return {
-        success: true as const,
+        success: true,
         data: {
           alreadyActive: true,
           expiresIn,
@@ -397,7 +436,7 @@ export class OtpService {
       };
     }
 
-    // بعد از اتمام کول‌داون، کد جدید صادر کن
+    // cooldown passed → issue new code
     await this.issueNewCode(
       channel,
       identifier,
@@ -414,7 +453,7 @@ export class OtpService {
     });
 
     return {
-      success: true as const,
+      success: true,
       data: {
         alreadyActive: false,
         expiresIn: this.OTP_TTL,
@@ -422,4 +461,121 @@ export class OtpService {
       },
     };
   }
+
+  /* ─────────────────────── Internals ─────────────────────── */
+
+  private parseDurationToSeconds(s: string): number {
+    const m = /^(\d+)([smh])$/.exec(String(s).trim());
+    if (!m) return Number(s) || 600;
+    const n = Number(m[1]);
+    return m[2] === 's' ? n : m[2] === 'm' ? n * 60 : n * 3600;
+  }
+
+  private blockWindowSeconds(): number {
+    return Number(this.config.get('OTP_BLOCK_WINDOW') ?? 900); // 15m
+  }
+
+  private maskIp(ip?: string): string | undefined {
+    if (!ip) return undefined;
+    const parts = ip.split('.');
+    return parts.length === 4 ? `${parts[0]}.${parts[1]}.${parts[2]}.0/24` : ip;
+  }
+
+  private hashUa(ua?: string): string | undefined {
+    return ua ? sha256Hex(ua).slice(0, 32) : undefined;
+  }
+
+  private keyBase(
+    purpose: OtpPurpose,
+    channel: OtpChannel,
+    identifier: string,
+  ): string {
+    const idHash = sha256Hex(`${purpose}|${channel}|${identifier}`).slice(
+      0,
+      40,
+    );
+    return `otp:${idHash}`;
+  }
+  private keyActive(
+    purpose: OtpPurpose,
+    channel: OtpChannel,
+    identifier: string,
+  ): string {
+    return this.keyBase(purpose, channel, identifier);
+  }
+  private keyCooldown(
+    purpose: OtpPurpose,
+    channel: OtpChannel,
+    identifier: string,
+  ): string {
+    return `${this.keyBase(purpose, channel, identifier)}:cd`;
+  }
+  private keyBlock(
+    purpose: OtpPurpose,
+    channel: OtpChannel,
+    identifier: string,
+  ): string {
+    return `${this.keyBase(purpose, channel, identifier)}:blk`;
+  }
+  private keyTicket(jti: string): string {
+    return `otp:ticket:${jti}`;
+  }
+
+  private async readActiveHash(activeKey: string): Promise<RedisHash | null> {
+    const hash = await this.redis.hgetall(activeKey);
+    if (!hash || Object.keys(hash).length === 0) return null;
+    return hash;
+  }
+
+  /**
+   * Issue and persist a new code; rollback keys if delivery fails.
+   */
+  private async issueNewCode(
+    channel: OtpChannel,
+    identifier: string,
+    purpose: OtpPurpose,
+    requestIp: string | undefined,
+    activeKey: string,
+    cooldownKey: string,
+  ): Promise<void> {
+    const now = nowEpoch();
+    const code = random6Digits();
+
+    const fields: RedisHash = {
+      codeHash: sha256Hex(code),
+      attempts: '0',
+      maxAttempts: String(this.OTP_MAX_ATTEMPTS),
+      exp: String(now + this.OTP_TTL),
+      resendAt: String(now + this.RESEND_COOLDOWN),
+      sendCount: '1',
+      ip: this.maskIp(requestIp) ?? '',
+      ch: channel,
+      pu: purpose,
+    };
+
+    await this.redis
+      .multi()
+      .hset(activeKey, fields)
+      .expire(activeKey, this.OTP_TTL)
+      .set(cooldownKey, '1', 'EX', this.RESEND_COOLDOWN)
+      .exec();
+
+    try {
+      if (channel === OtpChannel.sms) {
+        await this.sms.sendOtp(identifier, code);
+      } else {
+        await this.mail.sendOtp(identifier, code);
+      }
+    } catch {
+      // rollback if delivery fails
+      await this.redis.multi().del(activeKey).del(cooldownKey).exec();
+      throw new BadRequestException({
+        success: false,
+        error: {
+          code: 'OTP_DELIVERY_FAILED',
+          message: 'Failed to send verification code.',
+        },
+      });
+    }
+  }
 }
diff --git a/apps/api/src/core/auth/password/password.controller.ts b/apps/api/src/core/auth/password/password.controller.ts
index a5b6ae1..574727a 100644
--- a/apps/api/src/core/auth/password/password.controller.ts
+++ b/apps/api/src/core/auth/password/password.controller.ts
@@ -28,18 +28,18 @@ import {
 import { JwtAuthGuard } from '@app/core/auth/guards/jwt-auth.guard';
 import { NoCacheInterceptor } from '@app/common/interceptors/no-cache.interceptor';
 
-import { OtpService } from '../otp/otp.service';
-import { TokenService } from '../token/token.service';
-import { PasswordService } from './password.service';
-import { RequestOtpDto } from '../dto/otp/otp-request.dto';
-import { ResendOtpDto } from '../dto/otp/otp-resend.dto';
-import { VerifyOtpDto } from '../dto/otp/otp-verify.dto';
+import { OtpService } from '@app/core/auth/otp/otp.service';
+import { TokenService } from '@app/core/auth/token/token.service';
+import { PasswordService } from '@app/core/auth/password/password.service';
+import { RequestOtpDto } from '@app/core/auth/dto/otp/otp-request.dto';
+import { ResendOtpDto } from '@app/core/auth/dto/otp/otp-resend.dto';
+import { VerifyOtpDto } from '@app/core/auth/dto/otp/otp-verify.dto';
 import {
   ChangePasswordDto,
   PasswordStrengthDto,
   ResetPasswordDto,
   SetPasswordDto,
-} from '../dto/password/password.dto';
+} from '@app/core/auth/dto/password/password.dto';
 import { OtpChannel, OtpPurpose } from '@prisma/client';
 
 @ApiTags('Authentication - Password')
diff --git a/apps/api/src/core/auth/password/password.service.ts b/apps/api/src/core/auth/password/password.service.ts
index c00fa66..7d1f28b 100644
--- a/apps/api/src/core/auth/password/password.service.ts
+++ b/apps/api/src/core/auth/password/password.service.ts
@@ -1,574 +1,574 @@
-// apps/api/src/core/auth/password/password.service.ts
-
-import {
-  BadRequestException,
-  Inject,
-  Injectable,
-  UnauthorizedException,
-  InternalServerErrorException,
-  HttpException,
-  HttpStatus,
-  Logger,
-} from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import * as bcrypt from 'bcrypt';
-import type { Prisma } from '@prisma/client';
-import { Secret, verify } from 'jsonwebtoken';
-import type Redis from 'ioredis';
-import { PrismaService } from '@app/prisma/prisma.service';
-import { MailService } from '@app/mail/mail.service';
-import type { AllConfig } from '@app/config/config.module';
-import { createHash, timingSafeEqual } from 'crypto';
-
-/** 429 اختصاصی (Nest v8-compatible) */
-class TooManyRequestsException extends HttpException {
-  constructor(response?: unknown) {
-    super(response ?? 'Too many requests', HttpStatus.TOO_MANY_REQUESTS);
-  }
-}
-
-/** Payload تیکت set-password */
-interface SetPasswordPayload {
-  purpose: 'login' | 'signup' | 'reset';
-  channel: 'sms' | 'email';
-  identifier: string;
-  jti: string;
-}
-
-/** نمای باریک کاربر برای Login */
-type UserSlim = {
-  id: string;
-  passwordHash: string | null;
-  email: string | null;
-  phone: string | null;
-  username: string | null;
-  name: string | null;
-  status: string;
-  isEmailVerified: boolean;
-  isPhoneVerified: boolean;
-};
-
-function sha256Hex(v: string): string {
-  return createHash('sha256').update(v).digest('hex');
-}
-function safeEqHex(a: string, b: string): boolean {
-  try {
-    const ab = Buffer.from(a, 'hex');
-    const bb = Buffer.from(b, 'hex');
-    if (ab.length !== bb.length) return false;
-    return timingSafeEqual(ab, bb);
-  } catch {
-    return false;
-  }
-}
-
-@Injectable()
-export class PasswordService {
-  private readonly logger = new Logger(PasswordService.name);
-
-  private readonly setPwdSecret: Secret;
-  private readonly setPwdIssuer = 'negare-auth';
-  private readonly setPwdAudience = 'negare-core';
-  private readonly bcryptRounds: number;
-  private readonly loginThrottleLimit: number;
-  private readonly loginThrottleWindowSec: number;
-  private readonly dummyBcryptHash: string;
-
-  constructor(
-    private readonly prisma: PrismaService,
-    private readonly config: ConfigService<AllConfig>,
-    private readonly mail: MailService,
-    @Inject('REDIS') private readonly redis: Redis,
-  ) {
-    this.setPwdSecret = this.config.getOrThrow<string>('SET_PWD_JWT_SECRET');
-    this.bcryptRounds = Number(this.config.get('BCRYPT_ROUNDS') ?? 10);
-    this.loginThrottleLimit = Number(
-      this.config.get('LOGIN_THROTTLE_LIMIT') ?? 6,
-    );
-    this.loginThrottleWindowSec = Number(
-      this.config.get('LOGIN_THROTTLE_WINDOW_SEC') ?? 300,
-    );
-    // bcrypt hash of "dummy"
-    this.dummyBcryptHash =
-      this.config.get('DUMMY_BCRYPT_HASH') ??
-      '$2b$10$Cj2EoHjE7k0eJw1v1jv7ruo3Y4nH7C3d9xYd1p6kq6nWlYwX0r0uW';
-  }
-
-  // ────────────────────────────────────────────────────────────────────────────
-  // Normalizers
-  // ────────────────────────────────────────────────────────────────────────────
-  private normalizeEmail(raw?: string | null): string | null {
-    const v = (raw ?? '').trim();
-    if (!v || !v.includes('@')) return null;
-    return v.toLowerCase();
-  }
-  /** موبایل به E.164 ایران (+98...) */
-  private normalizePhone(raw?: string | null): string | null {
-    const v = (raw ?? '').trim();
-    if (!v) return null;
-    if (/^\+\d{7,15}$/.test(v)) return v;
-    const digits = v.replace(/\D/g, '');
-    if (!digits) return null;
-    if (digits.startsWith('0098')) return `+${digits.slice(2)}`;
-    if (digits.startsWith('98')) return `+${digits}`;
-    if (digits.startsWith('0') && digits.length === 11)
-      return `+98${digits.slice(1)}`;
-    if (digits.length === 10 && digits.startsWith('9')) return `+98${digits}`;
-    return null;
-  }
-  private splitIdentifier(raw: string): {
-    email?: string;
-    phone?: string;
-    username?: string;
-  } {
-    const email = this.normalizeEmail(raw);
-    if (email) return { email };
-    const phone = this.normalizePhone(raw);
-    if (phone) return { phone };
-    const username = (raw ?? '').trim().toLowerCase();
-    if (username) return { username };
-    return {};
-  }
-
-  // ────────────────────────────────────────────────────────────────────────────
-  // OTP Ticket (اختیاری برای set-password)
-  // ────────────────────────────────────────────────────────────────────────────
-  async issueSetPasswordTicket(
-    token: string,
-    jti: string,
-    ttlSec?: number,
-  ): Promise<void> {
-    const key = `otp:ticket:${jti}`;
-    const value = sha256Hex(token);
-    const ttl =
-      ttlSec ?? Number(this.config.get('SET_PWD_JWT_EXPIRES_SEC') ?? 600);
-    try {
-      await this.redis.set(key, value, 'EX', ttl);
-      this.logger.debug(`SET_PWD ticket stored jti=${jti} ttl=${ttl}s`);
-    } catch (err) {
-      throw new InternalServerErrorException({
-        code: 'RedisError',
-        message: 'Failed to store OTP ticket.',
-        details: (err as Error).message,
-      });
-    }
-  }
-
-  private async verifyAndConsumeOtpTicket(
-    token: string,
-  ): Promise<SetPasswordPayload> {
-    let decoded: Partial<SetPasswordPayload> & { jti?: string };
-    try {
-      decoded = verify(token, this.setPwdSecret, {
-        algorithms: ['HS256'],
-        issuer: this.setPwdIssuer,
-        audience: this.setPwdAudience,
-      }) as Partial<SetPasswordPayload> & { jti?: string };
-    } catch {
-      throw new BadRequestException({
-        code: 'InvalidOrExpiredToken',
-        message: 'Set-password token is invalid or expired.',
-      });
-    }
-
-    if (!decoded?.jti) {
-      throw new BadRequestException({
-        code: 'MissingJti',
-        message: 'Token missing its unique ID (jti).',
-      });
-    }
-    if (!decoded.identifier || !decoded.channel || !decoded.purpose) {
-      throw new BadRequestException({
-        code: 'IncompletePayload',
-        message: 'Set-password token payload incomplete.',
-      });
-    }
-
-    const key = `otp:ticket:${decoded.jti}`;
-    const redisAny = this.redis as unknown as {
-      getdel?: (k: string) => Promise<string | null>;
-    };
-
-    let storedHex: string | null = null;
-    try {
-      storedHex =
-        typeof redisAny.getdel === 'function'
-          ? await redisAny.getdel(key)
-          : await this.redis.get(key);
-      if (!redisAny.getdel && storedHex) await this.redis.del(key);
-    } catch (err) {
-      throw new InternalServerErrorException({
-        code: 'RedisError',
-        message: 'Failed to validate OTP ticket.',
-        details: (err as Error).message,
-      });
-    }
-
-    if (!storedHex) {
-      throw new BadRequestException({
-        code: 'TicketUsedOrMissing',
-        message: 'Set-password token already used or missing.',
-      });
-    }
-
-    const actualHex = sha256Hex(token);
-    if (!safeEqHex(storedHex, actualHex)) {
-      throw new BadRequestException({
-        code: 'TicketIntegrity',
-        message: 'Set-password token integrity check failed.',
-      });
-    }
-
-    return {
-      purpose: decoded.purpose as SetPasswordPayload['purpose'],
-      channel: decoded.channel as SetPasswordPayload['channel'],
-      identifier: decoded.identifier as string,
-      jti: decoded.jti as string,
-    };
-  }
-
-  // ────────────────────────────────────────────────────────────────────────────
-  // SET PASSWORD (consume ticket + upsert user + hash)
-  // ────────────────────────────────────────────────────────────────────────────
-  async setPassword(
-    token: string,
-    password: string,
-  ): Promise<{ success: true; userId: string }> {
-    const payload = await this.verifyAndConsumeOtpTicket(token);
-    const { identifier, channel } = payload;
-
-    if (typeof password !== 'string' || password.length < 8) {
-      throw new BadRequestException({
-        code: 'WeakPassword',
-        message: 'Password must be at least 8 characters long.',
-      });
-    }
-
-    const passwordHash = await bcrypt.hash(password, this.bcryptRounds);
-    const persisted = await this.upsertUserForChannel(
-      channel,
-      identifier,
-      passwordHash,
-    );
-
-    if (persisted.email) {
-      this.mail
-        .sendWelcome(
-          persisted.email,
-          persisted.name ?? persisted.username ?? identifier,
-        )
-        .catch(() => undefined);
-    }
-
-    this.logger.debug(`SET_PWD success userId=${persisted.id}`);
-    return { success: true, userId: persisted.id };
-  }
-
-  // ────────────────────────────────────────────────────────────────────────────
-  // LOGIN (Throttle + OR-lookup + Dummy bcrypt)
-  // ────────────────────────────────────────────────────────────────────────────
-  async login(
-    identifier: string,
-    password: string,
-    ip?: string,
-  ): Promise<{ userId: string }> {
-    const idn = (identifier ?? '').trim();
-    this.logger.debug(`LOGIN start idn="${idn}" ip="${ip ?? 'n/a'}"`);
-    if (!idn) {
-      this.logger.debug('LOGIN early-exit: empty identifier');
-      throw new UnauthorizedException({
-        code: 'InvalidCredentials',
-        message: 'Invalid credentials.',
-      });
-    }
-
-    // throttle
-    const throttleKey = ip
-      ? `auth:login:throttle:${idn}:${ip}`
-      : `auth:login:throttle:${idn}`;
-    try {
-      const attempts = await this.redis.incr(throttleKey);
-      if (attempts === 1)
-        await this.redis.expire(throttleKey, this.loginThrottleWindowSec);
-      this.logger.debug(
-        `LOGIN throttle attempts=${attempts}/${this.loginThrottleLimit} window=${this.loginThrottleWindowSec}s`,
-      );
-      if (attempts > this.loginThrottleLimit) {
-        this.logger.warn(`LOGIN too-many-attempts key=${throttleKey}`);
-        throw new TooManyRequestsException({
-          code: 'TooManyAttempts',
-          message: 'Too many login attempts. Try again later.',
-        });
-      }
-    } catch (e) {
-      this.logger.warn(
-        `LOGIN throttle error (ignored): ${(e as Error).message}`,
-      );
-    }
-
-    const { email, phone, username } = this.splitIdentifier(idn);
-    this.logger.debug(
-      `LOGIN split email=${email ?? '-'} phone=${phone ?? '-'} username=${username ?? '-'}`,
-    );
-
-    // select فقط فیلدهای موجود در جدول شما
-    const selectFields: Prisma.UserSelect = {
-      id: true,
-      passwordHash: true,
-      email: true,
-      phone: true,
-      username: true,
-      name: true,
-      status: true as unknown as never,
-      isEmailVerified: true as unknown as never,
-      isPhoneVerified: true as unknown as never,
-    };
-
-    let user: UserSlim | null = null;
-    try {
-      user = (await this.prisma.user.findFirst({
-        where: {
-          OR: [
-            ...(email ? [{ email }] : []),
-            ...(phone ? [{ phone }] : []),
-            ...(username ? [{ username }] : []),
-          ],
-        },
-        select: selectFields,
-      })) as unknown as UserSlim;
-    } catch (e) {
-      this.logger.error(`LOGIN DB error: ${(e as Error).message}`);
-      user = null;
-    }
-
-    this.logger.debug(
-      `LOGIN post-find found=${!!user} id=${user?.id ?? '-'} status=${user?.status ?? '-'} ` +
-        `emailVer=${user?.isEmailVerified ?? '-'} phoneVer=${user?.isPhoneVerified ?? '-'} hasHash=${!!user?.passwordHash}`,
-    );
-
-    const hashToCheck = user?.passwordHash ?? this.dummyBcryptHash;
-    const okBcrypt = await bcrypt.compare(password, hashToCheck);
-    this.logger.debug(
-      `LOGIN compare okBcrypt=${okBcrypt} userId=${user?.id ?? '-'}`,
-    );
-
-    if (user?.id && okBcrypt) {
-      try {
-        await this.redis.del(throttleKey);
-      } catch {}
-      this.logger.debug(`LOGIN success userId=${user.id}`);
-      return { userId: user.id };
-    }
-
-    // شکست
-    try {
-      await this.redis.incr(throttleKey);
-    } catch {}
-    this.logger.debug(`LOGIN fail -> 401 idn="${idn}"`);
-    throw new UnauthorizedException({
-      code: 'InvalidCredentials',
-      message: 'Invalid credentials.',
-    });
-  }
-
-  // ────────────────────────────────────────────────────────────────────────────
-  // CHANGE PASSWORD
-  // ────────────────────────────────────────────────────────────────────────────
-  async changePassword(
-    userId: string,
-    currentPassword: string,
-    newPassword: string,
-  ): Promise<{ success: true }> {
-    const user = await this.prisma.user.findUnique({
-      where: { id: userId },
-      select: {
-        id: true,
-        passwordHash: true,
-        email: true,
-        username: true,
-        name: true,
-      },
-    });
-
-    if (!user?.passwordHash) {
-      throw new UnauthorizedException({
-        code: 'InvalidCredentials',
-        message: 'Invalid credentials.',
-      });
-    }
-
-    const ok = await bcrypt.compare(currentPassword, user.passwordHash);
-    if (!ok) {
-      throw new UnauthorizedException({
-        code: 'InvalidCredentials',
-        message: 'Invalid credentials.',
-      });
-    }
-
-    if (typeof newPassword !== 'string' || newPassword.length < 8) {
-      throw new BadRequestException({
-        code: 'WeakPassword',
-        message: 'New password is too weak.',
-      });
-    }
-
-    const hash = await bcrypt.hash(newPassword, this.bcryptRounds);
-
-    try {
-      await this.prisma.user.update({
-        where: { id: userId },
-        data: { passwordHash: hash } as Prisma.UserUpdateInput,
-      });
-    } catch (err) {
-      throw new InternalServerErrorException({
-        code: 'DatabaseError',
-        message: 'Failed to update password.',
-        details: (err as Error).message,
-      });
-    }
-
-    return { success: true };
-  }
-
-  // ────────────────────────────────────────────────────────────────────────────
-  // Upsert user by channel (email/sms)
-  // ────────────────────────────────────────────────────────────────────────────
-  private async upsertUserForChannel(
-    channel: 'sms' | 'email',
-    identifier: string,
-    passwordHash: string,
-  ): Promise<{
-    id: string;
-    username: string | null;
-    name: string | null;
-    email: string | null;
-  }> {
-    if (channel === 'sms') {
-      const phone = this.normalizePhone(identifier);
-      if (!phone)
-        throw new BadRequestException({
-          code: 'InvalidPhone',
-          message: 'Invalid phone format.',
-        });
-
-      try {
-        return (await this.prisma.user.upsert({
-          where: { phone },
-          create: {
-            username: await this.generateUsername(phone),
-            phone,
-            email: null,
-            name: null,
-            passwordHash,
-          } as Prisma.UserCreateInput,
-          update: { passwordHash, phone } as Prisma.UserUpdateInput,
-          select: { id: true, username: true, name: true, email: true },
-        })) as {
-          id: string;
-          username: string | null;
-          name: string | null;
-          email: string | null;
-        };
-      } catch (err) {
-        if ((err as { code?: string })?.code === 'P2002') {
-          const existing = await this.prisma.user.findUnique({
-            where: { phone },
-            select: { id: true, phone: true },
-          });
-          if (existing) {
-            return (await this.prisma.user.update({
-              where: { id: existing.id },
-              data: {
-                passwordHash,
-                phone: existing.phone ?? phone,
-              } as Prisma.UserUpdateInput,
-              select: { id: true, username: true, name: true, email: true },
-            })) as {
-              id: string;
-              username: string | null;
-              name: string | null;
-              email: string | null;
-            };
-          }
-        }
-        throw new InternalServerErrorException({
-          code: 'DatabaseError',
-          message: 'Failed to upsert user (sms).',
-          details: (err as Error).message,
-        });
-      }
-    }
-
-    // email channel
-    const email = this.normalizeEmail(identifier);
-    if (!email)
-      throw new BadRequestException({
-        code: 'InvalidEmail',
-        message: 'Invalid email format.',
-      });
-
-    try {
-      return (await this.prisma.user.upsert({
-        where: { email },
-        create: {
-          username: await this.generateUsername(email),
-          email,
-          phone: null,
-          name: null,
-          passwordHash,
-        } as Prisma.UserCreateInput,
-        update: { passwordHash, email } as Prisma.UserUpdateInput,
-        select: { id: true, username: true, name: true, email: true },
-      })) as {
-        id: string;
-        username: string | null;
-        name: string | null;
-        email: string | null;
-      };
-    } catch (err) {
-      if ((err as { code?: string })?.code === 'P2002') {
-        const existing = await this.prisma.user.findUnique({
-          where: { email },
-          select: { id: true, email: true },
-        });
-        if (existing) {
-          return (await this.prisma.user.update({
-            where: { id: existing.id },
-            data: {
-              passwordHash,
-              email: existing.email ?? email,
-            } as Prisma.UserUpdateInput,
-            select: { id: true, username: true, name: true, email: true },
-          })) as {
-            id: string;
-            username: string | null;
-            name: string | null;
-            email: string | null;
-          };
-        }
-      }
-      throw new InternalServerErrorException({
-        code: 'DatabaseError',
-        message: 'Failed to upsert user (email).',
-        details: (err as Error).message,
-      });
-    }
-  }
-
-  private async generateUsername(seed: string): Promise<string> {
-    const base =
-      (seed ?? '')
-        .toLowerCase()
-        .replace(/[^a-z0-9]/g, '')
-        .slice(0, 20) || 'user';
-    for (let i = 0; i < 1000; i += 1) {
-      const cand = i === 0 ? base : `${base}${i + 1}`;
-      const exists = await this.prisma.user.findUnique({
-        where: { username: cand },
-        select: { id: true },
-      });
-      if (!exists) return cand;
-    }
-    return `${base}${Math.floor(Math.random() * 1_000_000)}`;
-  }
-}
+// apps/api/src/core/auth/password/password.service.ts
+
+import {
+  BadRequestException,
+  Inject,
+  Injectable,
+  UnauthorizedException,
+  InternalServerErrorException,
+  HttpException,
+  HttpStatus,
+  Logger,
+} from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import * as bcrypt from 'bcrypt';
+import type { Prisma } from '@prisma/client';
+import { Secret, verify } from 'jsonwebtoken';
+import type Redis from 'ioredis';
+import { PrismaService } from '@app/prisma/prisma.service';
+import { MailService } from '@app/mail/mail.service';
+import type { AllConfig } from '@app/config/config.module';
+import { createHash, timingSafeEqual } from 'crypto';
+
+/** 429 اختصاصی (Nest v8-compatible) */
+class TooManyRequestsException extends HttpException {
+  constructor(response?: unknown) {
+    super(response ?? 'Too many requests', HttpStatus.TOO_MANY_REQUESTS);
+  }
+}
+
+/** Payload تیکت set-password */
+interface SetPasswordPayload {
+  purpose: 'login' | 'signup' | 'reset';
+  channel: 'sms' | 'email';
+  identifier: string;
+  jti: string;
+}
+
+/** نمای باریک کاربر برای Login */
+type UserSlim = {
+  id: string;
+  passwordHash: string | null;
+  email: string | null;
+  phone: string | null;
+  username: string | null;
+  name: string | null;
+  status: string;
+  isEmailVerified: boolean;
+  isPhoneVerified: boolean;
+};
+
+function sha256Hex(v: string): string {
+  return createHash('sha256').update(v).digest('hex');
+}
+function safeEqHex(a: string, b: string): boolean {
+  try {
+    const ab = Buffer.from(a, 'hex');
+    const bb = Buffer.from(b, 'hex');
+    if (ab.length !== bb.length) return false;
+    return timingSafeEqual(ab, bb);
+  } catch {
+    return false;
+  }
+}
+
+@Injectable()
+export class PasswordService {
+  private readonly logger = new Logger(PasswordService.name);
+
+  private readonly setPwdSecret: Secret;
+  private readonly setPwdIssuer = 'negare-auth';
+  private readonly setPwdAudience = 'negare-core';
+  private readonly bcryptRounds: number;
+  private readonly loginThrottleLimit: number;
+  private readonly loginThrottleWindowSec: number;
+  private readonly dummyBcryptHash: string;
+
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly config: ConfigService<AllConfig>,
+    private readonly mail: MailService,
+    @Inject('REDIS') private readonly redis: Redis,
+  ) {
+    this.setPwdSecret = this.config.getOrThrow<string>('SET_PWD_JWT_SECRET');
+    this.bcryptRounds = Number(this.config.get('BCRYPT_ROUNDS') ?? 10);
+    this.loginThrottleLimit = Number(
+      this.config.get('LOGIN_THROTTLE_LIMIT') ?? 6,
+    );
+    this.loginThrottleWindowSec = Number(
+      this.config.get('LOGIN_THROTTLE_WINDOW_SEC') ?? 300,
+    );
+    // bcrypt hash of "dummy"
+    this.dummyBcryptHash =
+      this.config.get('DUMMY_BCRYPT_HASH') ??
+      '$2b$10$Cj2EoHjE7k0eJw1v1jv7ruo3Y4nH7C3d9xYd1p6kq6nWlYwX0r0uW';
+  }
+
+  // ────────────────────────────────────────────────────────────────────────────
+  // Normalizers
+  // ────────────────────────────────────────────────────────────────────────────
+  private normalizeEmail(raw?: string | null): string | null {
+    const v = (raw ?? '').trim();
+    if (!v || !v.includes('@')) return null;
+    return v.toLowerCase();
+  }
+  /** موبایل به E.164 ایران (+98...) */
+  private normalizePhone(raw?: string | null): string | null {
+    const v = (raw ?? '').trim();
+    if (!v) return null;
+    if (/^\+\d{7,15}$/.test(v)) return v;
+    const digits = v.replace(/\D/g, '');
+    if (!digits) return null;
+    if (digits.startsWith('0098')) return `+${digits.slice(2)}`;
+    if (digits.startsWith('98')) return `+${digits}`;
+    if (digits.startsWith('0') && digits.length === 11)
+      return `+98${digits.slice(1)}`;
+    if (digits.length === 10 && digits.startsWith('9')) return `+98${digits}`;
+    return null;
+  }
+  private splitIdentifier(raw: string): {
+    email?: string;
+    phone?: string;
+    username?: string;
+  } {
+    const email = this.normalizeEmail(raw);
+    if (email) return { email };
+    const phone = this.normalizePhone(raw);
+    if (phone) return { phone };
+    const username = (raw ?? '').trim().toLowerCase();
+    if (username) return { username };
+    return {};
+  }
+
+  // ────────────────────────────────────────────────────────────────────────────
+  // OTP Ticket (اختیاری برای set-password)
+  // ────────────────────────────────────────────────────────────────────────────
+  async issueSetPasswordTicket(
+    token: string,
+    jti: string,
+    ttlSec?: number,
+  ): Promise<void> {
+    const key = `otp:ticket:${jti}`;
+    const value = sha256Hex(token);
+    const ttl =
+      ttlSec ?? Number(this.config.get('SET_PWD_JWT_EXPIRES_SEC') ?? 600);
+    try {
+      await this.redis.set(key, value, 'EX', ttl);
+      this.logger.debug(`SET_PWD ticket stored jti=${jti} ttl=${ttl}s`);
+    } catch (err) {
+      throw new InternalServerErrorException({
+        code: 'RedisError',
+        message: 'Failed to store OTP ticket.',
+        details: (err as Error).message,
+      });
+    }
+  }
+
+  private async verifyAndConsumeOtpTicket(
+    token: string,
+  ): Promise<SetPasswordPayload> {
+    let decoded: Partial<SetPasswordPayload> & { jti?: string };
+    try {
+      decoded = verify(token, this.setPwdSecret, {
+        algorithms: ['HS256'],
+        issuer: this.setPwdIssuer,
+        audience: this.setPwdAudience,
+      }) as Partial<SetPasswordPayload> & { jti?: string };
+    } catch {
+      throw new BadRequestException({
+        code: 'InvalidOrExpiredToken',
+        message: 'Set-password token is invalid or expired.',
+      });
+    }
+
+    if (!decoded?.jti) {
+      throw new BadRequestException({
+        code: 'MissingJti',
+        message: 'Token missing its unique ID (jti).',
+      });
+    }
+    if (!decoded.identifier || !decoded.channel || !decoded.purpose) {
+      throw new BadRequestException({
+        code: 'IncompletePayload',
+        message: 'Set-password token payload incomplete.',
+      });
+    }
+
+    const key = `otp:ticket:${decoded.jti}`;
+    const redisAny = this.redis as unknown as {
+      getdel?: (k: string) => Promise<string | null>;
+    };
+
+    let storedHex: string | null = null;
+    try {
+      storedHex =
+        typeof redisAny.getdel === 'function'
+          ? await redisAny.getdel(key)
+          : await this.redis.get(key);
+      if (!redisAny.getdel && storedHex) await this.redis.del(key);
+    } catch (err) {
+      throw new InternalServerErrorException({
+        code: 'RedisError',
+        message: 'Failed to validate OTP ticket.',
+        details: (err as Error).message,
+      });
+    }
+
+    if (!storedHex) {
+      throw new BadRequestException({
+        code: 'TicketUsedOrMissing',
+        message: 'Set-password token already used or missing.',
+      });
+    }
+
+    const actualHex = sha256Hex(token);
+    if (!safeEqHex(storedHex, actualHex)) {
+      throw new BadRequestException({
+        code: 'TicketIntegrity',
+        message: 'Set-password token integrity check failed.',
+      });
+    }
+
+    return {
+      purpose: decoded.purpose as SetPasswordPayload['purpose'],
+      channel: decoded.channel as SetPasswordPayload['channel'],
+      identifier: decoded.identifier as string,
+      jti: decoded.jti as string,
+    };
+  }
+
+  // ────────────────────────────────────────────────────────────────────────────
+  // SET PASSWORD (consume ticket + upsert user + hash)
+  // ────────────────────────────────────────────────────────────────────────────
+  async setPassword(
+    token: string,
+    password: string,
+  ): Promise<{ success: true; userId: string }> {
+    const payload = await this.verifyAndConsumeOtpTicket(token);
+    const { identifier, channel } = payload;
+
+    if (typeof password !== 'string' || password.length < 8) {
+      throw new BadRequestException({
+        code: 'WeakPassword',
+        message: 'Password must be at least 8 characters long.',
+      });
+    }
+
+    const passwordHash = await bcrypt.hash(password, this.bcryptRounds);
+    const persisted = await this.upsertUserForChannel(
+      channel,
+      identifier,
+      passwordHash,
+    );
+
+    if (persisted.email) {
+      this.mail
+        .sendWelcome(
+          persisted.email,
+          persisted.name ?? persisted.username ?? identifier,
+        )
+        .catch(() => undefined);
+    }
+
+    this.logger.debug(`SET_PWD success userId=${persisted.id}`);
+    return { success: true, userId: persisted.id };
+  }
+
+  // ────────────────────────────────────────────────────────────────────────────
+  // LOGIN (Throttle + OR-lookup + Dummy bcrypt)
+  // ────────────────────────────────────────────────────────────────────────────
+  async login(
+    identifier: string,
+    password: string,
+    ip?: string,
+  ): Promise<{ userId: string }> {
+    const idn = (identifier ?? '').trim();
+    this.logger.debug(`LOGIN start idn="${idn}" ip="${ip ?? 'n/a'}"`);
+    if (!idn) {
+      this.logger.debug('LOGIN early-exit: empty identifier');
+      throw new UnauthorizedException({
+        code: 'InvalidCredentials',
+        message: 'Invalid credentials.',
+      });
+    }
+
+    // throttle
+    const throttleKey = ip
+      ? `auth:login:throttle:${idn}:${ip}`
+      : `auth:login:throttle:${idn}`;
+    try {
+      const attempts = await this.redis.incr(throttleKey);
+      if (attempts === 1)
+        await this.redis.expire(throttleKey, this.loginThrottleWindowSec);
+      this.logger.debug(
+        `LOGIN throttle attempts=${attempts}/${this.loginThrottleLimit} window=${this.loginThrottleWindowSec}s`,
+      );
+      if (attempts > this.loginThrottleLimit) {
+        this.logger.warn(`LOGIN too-many-attempts key=${throttleKey}`);
+        throw new TooManyRequestsException({
+          code: 'TooManyAttempts',
+          message: 'Too many login attempts. Try again later.',
+        });
+      }
+    } catch (e) {
+      this.logger.warn(
+        `LOGIN throttle error (ignored): ${(e as Error).message}`,
+      );
+    }
+
+    const { email, phone, username } = this.splitIdentifier(idn);
+    this.logger.debug(
+      `LOGIN split email=${email ?? '-'} phone=${phone ?? '-'} username=${username ?? '-'}`,
+    );
+
+    // select فقط فیلدهای موجود در جدول شما
+    const selectFields: Prisma.UserSelect = {
+      id: true,
+      passwordHash: true,
+      email: true,
+      phone: true,
+      username: true,
+      name: true,
+      status: true as unknown as never,
+      isEmailVerified: true as unknown as never,
+      isPhoneVerified: true as unknown as never,
+    };
+
+    let user: UserSlim | null = null;
+    try {
+      user = (await this.prisma.user.findFirst({
+        where: {
+          OR: [
+            ...(email ? [{ email }] : []),
+            ...(phone ? [{ phone }] : []),
+            ...(username ? [{ username }] : []),
+          ],
+        },
+        select: selectFields,
+      })) as unknown as UserSlim;
+    } catch (e) {
+      this.logger.error(`LOGIN DB error: ${(e as Error).message}`);
+      user = null;
+    }
+
+    this.logger.debug(
+      `LOGIN post-find found=${!!user} id=${user?.id ?? '-'} status=${user?.status ?? '-'} ` +
+        `emailVer=${user?.isEmailVerified ?? '-'} phoneVer=${user?.isPhoneVerified ?? '-'} hasHash=${!!user?.passwordHash}`,
+    );
+
+    const hashToCheck = user?.passwordHash ?? this.dummyBcryptHash;
+    const okBcrypt = await bcrypt.compare(password, hashToCheck);
+    this.logger.debug(
+      `LOGIN compare okBcrypt=${okBcrypt} userId=${user?.id ?? '-'}`,
+    );
+
+    if (user?.id && okBcrypt) {
+      try {
+        await this.redis.del(throttleKey);
+      } catch {}
+      this.logger.debug(`LOGIN success userId=${user.id}`);
+      return { userId: user.id };
+    }
+
+    // شکست
+    try {
+      await this.redis.incr(throttleKey);
+    } catch {}
+    this.logger.debug(`LOGIN fail -> 401 idn="${idn}"`);
+    throw new UnauthorizedException({
+      code: 'InvalidCredentials',
+      message: 'Invalid credentials.',
+    });
+  }
+
+  // ────────────────────────────────────────────────────────────────────────────
+  // CHANGE PASSWORD
+  // ────────────────────────────────────────────────────────────────────────────
+  async changePassword(
+    userId: string,
+    currentPassword: string,
+    newPassword: string,
+  ): Promise<{ success: true }> {
+    const user = await this.prisma.user.findUnique({
+      where: { id: userId },
+      select: {
+        id: true,
+        passwordHash: true,
+        email: true,
+        username: true,
+        name: true,
+      },
+    });
+
+    if (!user?.passwordHash) {
+      throw new UnauthorizedException({
+        code: 'InvalidCredentials',
+        message: 'Invalid credentials.',
+      });
+    }
+
+    const ok = await bcrypt.compare(currentPassword, user.passwordHash);
+    if (!ok) {
+      throw new UnauthorizedException({
+        code: 'InvalidCredentials',
+        message: 'Invalid credentials.',
+      });
+    }
+
+    if (typeof newPassword !== 'string' || newPassword.length < 8) {
+      throw new BadRequestException({
+        code: 'WeakPassword',
+        message: 'New password is too weak.',
+      });
+    }
+
+    const hash = await bcrypt.hash(newPassword, this.bcryptRounds);
+
+    try {
+      await this.prisma.user.update({
+        where: { id: userId },
+        data: { passwordHash: hash } as Prisma.UserUpdateInput,
+      });
+    } catch (err) {
+      throw new InternalServerErrorException({
+        code: 'DatabaseError',
+        message: 'Failed to update password.',
+        details: (err as Error).message,
+      });
+    }
+
+    return { success: true };
+  }
+
+  // ────────────────────────────────────────────────────────────────────────────
+  // Upsert user by channel (email/sms)
+  // ────────────────────────────────────────────────────────────────────────────
+  private async upsertUserForChannel(
+    channel: 'sms' | 'email',
+    identifier: string,
+    passwordHash: string,
+  ): Promise<{
+    id: string;
+    username: string | null;
+    name: string | null;
+    email: string | null;
+  }> {
+    if (channel === 'sms') {
+      const phone = this.normalizePhone(identifier);
+      if (!phone)
+        throw new BadRequestException({
+          code: 'InvalidPhone',
+          message: 'Invalid phone format.',
+        });
+
+      try {
+        return (await this.prisma.user.upsert({
+          where: { phone },
+          create: {
+            username: await this.generateUsername(phone),
+            phone,
+            email: null,
+            name: null,
+            passwordHash,
+          } as Prisma.UserCreateInput,
+          update: { passwordHash, phone } as Prisma.UserUpdateInput,
+          select: { id: true, username: true, name: true, email: true },
+        })) as {
+          id: string;
+          username: string | null;
+          name: string | null;
+          email: string | null;
+        };
+      } catch (err) {
+        if ((err as { code?: string })?.code === 'P2002') {
+          const existing = await this.prisma.user.findUnique({
+            where: { phone },
+            select: { id: true, phone: true },
+          });
+          if (existing) {
+            return (await this.prisma.user.update({
+              where: { id: existing.id },
+              data: {
+                passwordHash,
+                phone: existing.phone ?? phone,
+              } as Prisma.UserUpdateInput,
+              select: { id: true, username: true, name: true, email: true },
+            })) as {
+              id: string;
+              username: string | null;
+              name: string | null;
+              email: string | null;
+            };
+          }
+        }
+        throw new InternalServerErrorException({
+          code: 'DatabaseError',
+          message: 'Failed to upsert user (sms).',
+          details: (err as Error).message,
+        });
+      }
+    }
+
+    // email channel
+    const email = this.normalizeEmail(identifier);
+    if (!email)
+      throw new BadRequestException({
+        code: 'InvalidEmail',
+        message: 'Invalid email format.',
+      });
+
+    try {
+      return (await this.prisma.user.upsert({
+        where: { email },
+        create: {
+          username: await this.generateUsername(email),
+          email,
+          phone: null,
+          name: null,
+          passwordHash,
+        } as Prisma.UserCreateInput,
+        update: { passwordHash, email } as Prisma.UserUpdateInput,
+        select: { id: true, username: true, name: true, email: true },
+      })) as {
+        id: string;
+        username: string | null;
+        name: string | null;
+        email: string | null;
+      };
+    } catch (err) {
+      if ((err as { code?: string })?.code === 'P2002') {
+        const existing = await this.prisma.user.findUnique({
+          where: { email },
+          select: { id: true, email: true },
+        });
+        if (existing) {
+          return (await this.prisma.user.update({
+            where: { id: existing.id },
+            data: {
+              passwordHash,
+              email: existing.email ?? email,
+            } as Prisma.UserUpdateInput,
+            select: { id: true, username: true, name: true, email: true },
+          })) as {
+            id: string;
+            username: string | null;
+            name: string | null;
+            email: string | null;
+          };
+        }
+      }
+      throw new InternalServerErrorException({
+        code: 'DatabaseError',
+        message: 'Failed to upsert user (email).',
+        details: (err as Error).message,
+      });
+    }
+  }
+
+  private async generateUsername(seed: string): Promise<string> {
+    const base =
+      (seed ?? '')
+        .toLowerCase()
+        .replace(/[^a-z0-9]/g, '')
+        .slice(0, 20) || 'user';
+    for (let i = 0; i < 1000; i += 1) {
+      const cand = i === 0 ? base : `${base}${i + 1}`;
+      const exists = await this.prisma.user.findUnique({
+        where: { username: cand },
+        select: { id: true },
+      });
+      if (!exists) return cand;
+    }
+    return `${base}${Math.floor(Math.random() * 1_000_000)}`;
+  }
+}
diff --git a/apps/api/src/core/auth/refresh.service.spec.ts b/apps/api/src/core/auth/refresh.service.spec.ts
index 7dd9670..55fcbe1 100644
--- a/apps/api/src/core/auth/refresh.service.spec.ts
+++ b/apps/api/src/core/auth/refresh.service.spec.ts
@@ -1,8 +1,8 @@
 import { RoleName } from '@app/prisma/prisma.constants';
-import { refreshAllowKey } from './auth.constants';
-import { RefreshService } from './refresh.service';
-import { SessionService } from './session/session.service';
-import { TokenService } from './token/token.service';
+import { refreshAllowKey } from '@app/core/auth/auth.constants';
+import { RefreshService } from '@app/core/auth/refresh.service';
+import { SessionService } from '@app/core/auth/session/session.service';
+import { TokenService } from '@app/core/auth/token/token.service';
 import { createFakeRedis } from '@test/utils/fake-redis';
 
 class ConfigStub {
diff --git a/apps/api/src/core/auth/refresh.service.ts b/apps/api/src/core/auth/refresh.service.ts
index a4b2d13..25e3ba3 100644
--- a/apps/api/src/core/auth/refresh.service.ts
+++ b/apps/api/src/core/auth/refresh.service.ts
@@ -11,11 +11,10 @@ import { UsersService, UserWithRelations } from '@app/core/users/users.service';
 import { parseDurationToSeconds } from '@app/shared/utils/parse-duration.util';
 import { AllConfig } from '@app/config/config.module';
 import { AuthConfig } from '@app/config/auth.config';
-import { SessionService } from './session/session.service';
-import { RefreshAllowRecord, refreshAllowKey } from './auth.constants';
-import { TokenService, RefreshTokenPayload } from './token/token.service';
+import { SessionService } from '@app/core/auth/session/session.service';
+import { RefreshAllowRecord, refreshAllowKey } from '@app/core/auth/auth.constants';
+import { TokenService, RefreshTokenPayload } from '@app/core/auth/token/token.service';
 import { RoleName } from '@prisma/client';
-import { requestTraceStorage } from '@app/common/tracing/request-trace';
 
 export interface TokenPair {
   accessToken: string;
@@ -29,6 +28,7 @@ export interface IssueOpts {
 @Injectable()
 export class RefreshService {
   private readonly logger = new Logger(RefreshService.name);
+
   private readonly refreshTtlSeconds: number;
 
   constructor(
@@ -39,79 +39,70 @@ export class RefreshService {
     private readonly tokens: TokenService,
   ) {
     const auth = this.config.get<AuthConfig>('auth', { infer: true });
-    if (!auth) throw new Error('Auth configuration is not available.');
+    if (!auth) {
+      throw new Error('Auth configuration is not available.');
+    }
     this.refreshTtlSeconds = parseDurationToSeconds(
       auth.refreshExpires,
       30 * 24 * 3600,
     );
   }
 
-  // --------------------------------------------------------------------------
-  // Public API
-  // --------------------------------------------------------------------------
-
+  /** قبلی: فقط userId می‌گرفت — حالا opts اختیاری هم دارد */
   async issueTokensForUserId(
     userId: string,
     opts: IssueOpts = {},
   ): Promise<TokenPair> {
     const hydrated = await this.usersService.ensureActiveWithRoles(userId);
-    return this.buildPair(hydrated, opts.sessionId);
+    return this.buildPair(hydrated, opts.sessionId); // ➜ sessionId پاس داده می‌شود
   }
 
   async refresh(refreshToken: string): Promise<TokenPair> {
     const payload = await this.verifyRefreshToken(refreshToken);
-    if (!payload?.sub || !payload?.jti) {
-      this.logger.warn(
-        this.withTrace(
-          `Invalid refresh payload: sub=${payload?.sub} jti=${payload?.jti}`,
-        ),
-      );
-      throw new UnauthorizedException('Malformed refresh token.');
-    }
-
     const key = this.refreshKey(payload.jti);
-    const ttl = await this.safeTtl(key);
 
-    this.logger.debug(
-      this.withTrace(
-        `refresh attempt sub=${payload.sub} sid=${payload.sid ?? '-'} jti=${payload.jti} key=${key} ttl=${ttl}`,
-      ),
-    );
-
-    // --- ATOMIC read+consume allow-list
-    const stored = await this.atomicGetDel(key);
+    const stored = await this.redis.get(key);
     if (!stored) {
       this.logger.debug(
-        this.withTrace(`Allow-list MISS jti=${payload.jti} key=${key}`),
+        `Rejecting refresh for user ${payload.sub}: JTI ${payload.jti} not allow-listed`,
       );
       throw new UnauthorizedException(
         'Refresh token is no longer valid. Please sign in again.',
       );
     }
-    this.logger.debug(this.withTrace(`Allow-list HIT jti=${payload.jti}`));
 
-    const record = this.parseAllowRecord(stored, payload.sub, payload.sid);
-    if (!record) {
-      this.logger.warn(
-        this.withTrace(
-          `Refresh state mismatch user=${payload.sub} jti=${payload.jti}`,
-        ),
-      );
-      throw new UnauthorizedException('Refresh state mismatch.');
+    let record: RefreshAllowRecord | null = null;
+    try {
+      record = JSON.parse(stored) as RefreshAllowRecord;
+    } catch {
+      if (stored === '1') {
+        record = {
+          userId: payload.sub,
+          sessionId: payload.sid ?? null,
+        };
+      } else {
+        record = null;
+      }
+    }
+
+    if (!record || record.userId !== payload.sub) {
+      throw new UnauthorizedException('Malformed refresh token state.');
     }
+
     if (record.sessionId && record.sessionId !== payload.sid) {
-      this.logger.warn(
-        this.withTrace(
-          `Session mismatch rec=${record.sessionId} payload=${payload.sid}`,
-        ),
-      );
       throw new UnauthorizedException('Refresh token session mismatch.');
     }
 
-    // blacklist old jti (best-effort)
-    await this.safeBlacklist(payload.jti);
+    await this.redis.del(key);
+
+    await this.tokens
+      .blacklistRefreshJti(payload.jti, this.refreshTtlSeconds)
+      .catch((err) =>
+        this.logger.warn(
+          `Failed to blacklist refresh JTI=${payload.jti}: ${err?.message ?? err}`,
+        ),
+      );
 
-    // unlink old jti from session (best-effort)
     if (record.sessionId) {
       await this.sessions
         .unlinkRefreshJti(payload.sub, record.sessionId, payload.jti)
@@ -119,16 +110,22 @@ export class RefreshService {
     }
 
     const user = await this.usersService.ensureActiveWithRoles(payload.sub);
-    // prefer a real sid if present
     return this.buildPair(user, record.sessionId ?? payload.sid);
   }
 
   async revoke(refreshToken: string): Promise<void> {
     const payload = await this.verifyRefreshToken(refreshToken, true, true);
-    if (!payload?.sub || !payload?.jti) return;
+    if (!payload.sub || !payload.jti) return;
+
+    await this.redis.del(this.refreshKey(payload.jti));
 
-    await this.redis.del(this.refreshKey(payload.jti)).catch(() => undefined);
-    await this.safeBlacklist(payload.jti);
+    await this.tokens
+      .blacklistRefreshJti(payload.jti, this.refreshTtlSeconds)
+      .catch((err) =>
+        this.logger.warn(
+          `Failed to blacklist revoked refresh JTI=${payload.jti}: ${err?.message ?? err}`,
+        ),
+      );
 
     if (payload.sid) {
       await this.sessions
@@ -137,6 +134,7 @@ export class RefreshService {
     }
   }
 
+  /** NEW: فقط payload را برمی‌گرداند (برای logout/touch سناریوها) */
   async peekPayload(
     token: string,
     ignoreExpiration = false,
@@ -147,24 +145,23 @@ export class RefreshService {
     });
   }
 
-  // --------------------------------------------------------------------------
-  // Internals
-  // --------------------------------------------------------------------------
+  // ----------------- داخلی‌ها -----------------
 
   private async buildPair(
     user: UserWithRelations,
     sessionId?: string,
   ): Promise<TokenPair> {
     const jti = randomUUID();
-
     const rawRoles = (user.userRoles ?? [])
-      .map((rel) => rel.role?.name)
+      .map((relation) => relation.role?.name)
       .filter((name): name is RoleName => Boolean(name));
-    const roleNames = Array.from(new Set(rawRoles)) as RoleName[];
+    const roleNames = Array.from(new Set(rawRoles)).map((role) =>
+      role.toString(),
+    );
 
     const accessToken = this.tokens.signAccess({
       userId: user.id,
-      roles: roleNames,
+      roles: roleNames as RoleName[],
     });
 
     const refreshToken = this.tokens.signRefresh({
@@ -177,32 +174,21 @@ export class RefreshService {
 
     const record: RefreshAllowRecord = {
       userId: user.id,
-      // اگر می‌خواهی کاملاً سفت باشد می‌توانی این را به (sessionId ?? jti) تغییر دهی
       sessionId: sessionId ?? null,
     };
 
-    await this.redis
-      .set(this.refreshKey(jti), JSON.stringify(record), 'EX', ttl)
-      .catch((err) =>
-        this.logger.warn(
-          this.withTrace(
-            `Failed to set allow-list for jti=${jti}: ${err?.message ?? err}`,
-          ),
-        ),
-      );
+    await this.redis.set(
+      this.refreshKey(jti),
+      JSON.stringify(record),
+      'EX',
+      ttl,
+    );
 
+    // اگر sessionId داریم، JTI را به سشن لینک کن تا بعداً بتوانیم revoke/touch کنیم
     if (sessionId) {
-      await this.sessions
-        .linkRefreshJti(user.id, sessionId, jti)
-        .catch(() => undefined);
+      await this.sessions.linkRefreshJti(user.id, sessionId, jti);
     }
 
-    this.logger.debug(
-      this.withTrace(
-        `Issued new refresh pair user=${user.id} session=${sessionId ?? jti} newJti=${jti}`,
-      ),
-    );
-
     return { accessToken, refreshToken };
   }
 
@@ -211,90 +197,22 @@ export class RefreshService {
     ignoreExpiration = false,
     skipBlacklist = false,
   ): Promise<RefreshTokenPayload> {
-    if (!token)
+    if (!token) {
       throw new UnauthorizedException('Refresh token must be provided.');
+    }
+
     try {
       return await this.tokens.verifyRefresh(token, {
         ignoreExpiration,
         skipBlacklist,
       });
-    } catch {
+    } catch (error) {
       throw new UnauthorizedException('Refresh token verification failed.');
     }
   }
 
   private refreshKey(jti: string | undefined): string {
-    return refreshAllowKey(jti ?? 'unknown');
-  }
-
-  private withTrace(message: string): string {
-    const traceId = requestTraceStorage.getStore()?.traceId;
-    return traceId ? `[traceId=${traceId}] ${message}` : message;
-  }
-
-  // --------------------------------------------------------------------------
-  // Helpers
-  // --------------------------------------------------------------------------
-
-  /** Atomic read+delete: uses GETDEL when available; falls back to MULTI(get+del) */
-  private async atomicGetDel(key: string): Promise<string | null> {
-    const anyRedis = this.redis as unknown as {
-      getdel?: (k: string) => Promise<string | null>;
-    };
-    if (typeof anyRedis.getdel === 'function') {
-      return await anyRedis.getdel(key);
-    }
-    // fallback for older Redis/ioredis
-    const pipeline = this.redis.multi();
-    pipeline.get(key);
-    pipeline.del(key);
-    const res = await pipeline.exec();
-    // res: [[err|null, getValue], [err|null, delCount]]
-    const getRes = res?.[0]?.[1] as string | null;
-    return getRes ?? null;
-  }
-
-  private parseAllowRecord(
-    stored: string,
-    expectedUserId: string,
-    payloadSid?: string | null,
-  ): RefreshAllowRecord | null {
-    try {
-      const rec = JSON.parse(stored) as RefreshAllowRecord;
-      if (!rec?.userId) return null;
-      if (rec.userId !== expectedUserId) return null;
-      // اگر لازم داری سخت‌تر باشی می‌توانی در اینجا sid را هم الزاماً مقایسه کنی
-      return rec;
-    } catch {
-      // backward compatibility: legacy '1' value
-      if (stored === '1') {
-        return {
-          userId: expectedUserId,
-          sessionId: payloadSid ?? null,
-        };
-      }
-      return null;
-    }
-  }
-
-  private async safeBlacklist(jti?: string | null): Promise<void> {
-    if (!jti) return;
-    await this.tokens
-      .blacklistRefreshJti(jti, this.refreshTtlSeconds)
-      .catch((err) =>
-        this.logger.warn(
-          this.withTrace(
-            `Failed to blacklist JTI=${jti}: ${err?.message ?? err}`,
-          ),
-        ),
-      );
-  }
-
-  private async safeTtl(key: string): Promise<number> {
-    try {
-      return await this.redis.ttl(key);
-    } catch {
-      return -2; // unknown / error
-    }
+    if (!jti) return refreshAllowKey('unknown');
+    return refreshAllowKey(jti);
   }
 }
diff --git a/apps/api/src/core/auth/session/session.service.spec.ts b/apps/api/src/core/auth/session/session.service.spec.ts
index e678758..2922011 100644
--- a/apps/api/src/core/auth/session/session.service.spec.ts
+++ b/apps/api/src/core/auth/session/session.service.spec.ts
@@ -1,4 +1,4 @@
-import { SessionService } from './session.service';
+import { SessionService } from '@app/core/auth/session/session.service';
 import { createFakeRedis } from '@test/utils/fake-redis';
 
 class ConfigStub {
diff --git a/apps/api/src/core/auth/session/session.service.ts b/apps/api/src/core/auth/session/session.service.ts
index fa1a1b6..3dc62cc 100644
--- a/apps/api/src/core/auth/session/session.service.ts
+++ b/apps/api/src/core/auth/session/session.service.ts
@@ -5,7 +5,7 @@ import { randomUUID } from 'node:crypto';
 import type Redis from 'ioredis';
 import type { AllConfig } from '@app/config/config.module';
 import { parseDurationToSeconds } from '@app/shared/utils/parse-duration.util';
-import { refreshAllowKey } from '../auth.constants';
+import { refreshAllowKey } from '@app/core/auth/auth.constants';
 
 /**
  * رکورد سشن که در Redis ذخیره می‌شود.
@@ -327,5 +327,4 @@ export class SessionService {
   private keyJtiIndex(jti: string): string {
     return `${SessionService.NS}:session:jti:index:${jti}`;
   }
-
 }
diff --git a/apps/api/src/core/auth/token/token.module.ts b/apps/api/src/core/auth/token/token.module.ts
index 6f16a67..9ee8144 100644
--- a/apps/api/src/core/auth/token/token.module.ts
+++ b/apps/api/src/core/auth/token/token.module.ts
@@ -1,5 +1,5 @@
 import { Module } from '@nestjs/common';
-import { TokenService } from './token.service';
+import { TokenService } from '@app/core/auth/token/token.service';
 import { RedisModule } from '@app/redis/redis.module';
 
 @Module({
diff --git a/apps/api/src/core/auth/token/token.service.spec.ts b/apps/api/src/core/auth/token/token.service.spec.ts
index 901a772..26eb644 100644
--- a/apps/api/src/core/auth/token/token.service.spec.ts
+++ b/apps/api/src/core/auth/token/token.service.spec.ts
@@ -1,5 +1,5 @@
 import { RoleName } from '@app/prisma/prisma.constants';
-import { TokenService } from './token.service';
+import { TokenService } from '@app/core/auth/token/token.service';
 import { createFakeRedis } from '@test/utils/fake-redis';
 
 class ConfigServiceStub {
diff --git a/apps/api/src/core/auth/token/token.service.ts b/apps/api/src/core/auth/token/token.service.ts
index 4b91569..b0c9490 100644
--- a/apps/api/src/core/auth/token/token.service.ts
+++ b/apps/api/src/core/auth/token/token.service.ts
@@ -1,349 +1,349 @@
-import {
-  Inject,
-  Injectable,
-  Logger,
-  UnauthorizedException,
-} from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import type { JwtPayload, Secret, SignOptions } from 'jsonwebtoken';
-import { decode, sign, verify } from 'jsonwebtoken';
-import type Redis from 'ioredis';
-import type { AllConfig } from '@app/config/config.module';
-import { parseDurationToSeconds } from '@app/shared/utils/parse-duration.util';
-import { RoleName } from '@prisma/client';
-
-/* ===================== Types ===================== */
-
-export type AccessTokenPayload = JwtPayload & {
-  sub: string;
-  roles: RoleName[];
-  typ: 'access';
-};
-
-export type RefreshTokenPayload = JwtPayload & {
-  sub: string;
-  sid: string;
-  jti: string;
-  typ: 'refresh';
-};
-
-interface VerifyRefreshOptions {
-  ignoreExpiration?: boolean;
-  skipBlacklist?: boolean;
-}
-
-interface PeekRefreshOptions {
-  ignoreExpiration?: boolean;
-  allowBlacklisted?: boolean;
-}
-
-type SignAccessInput = {
-  userId: string;
-  roles: RoleName[];
-};
-
-type SignRefreshInput = {
-  userId: string;
-  sessionId: string;
-  jti: string;
-};
-
-type AuthConfigLike =
-  | {
-      accessSecret: string;
-      accessExpires: string;
-      refreshSecret: string;
-      refreshExpires: string;
-      cookie?: {
-        sameSite: 'strict' | 'lax' | 'none';
-        secure: boolean;
-        refreshPath: string;
-        accessPath: string;
-      };
-    }
-  | {
-      jwt: {
-        issuer?: string;
-        audience?: string;
-        accessSecret: string;
-        refreshSecret: string;
-      };
-      accessExpires: string;
-      refreshExpires: string;
-      cookie?: {
-        sameSite: 'strict' | 'lax' | 'none';
-        secure: boolean;
-        refreshPath: string;
-        accessPath: string;
-      };
-    };
-
-/* ===================== Service ===================== */
-
-@Injectable()
-export class TokenService {
-  private readonly logger = new Logger(TokenService.name);
-
-  private static readonly RBL_PREFIX = 'auth:rbl:'; // refresh blacklist
-  private static readonly ONCE_PREFIX = 'auth:once:'; // one-time token
-
-  private readonly accessSecret: Secret;
-  private readonly refreshSecret: Secret;
-
-  private readonly issuer: string | undefined;
-  private readonly audience: string | undefined;
-
-  private readonly accessTtlSec: number;
-  private readonly refreshTtlSec: number;
-
-  constructor(
-    private readonly config: ConfigService<AllConfig>,
-    @Inject('REDIS') private readonly redis: Redis,
-  ) {
-    const auth = this.config.get<AuthConfigLike>('auth', { infer: true });
-    if (!auth) throw new Error('Auth config missing');
-
-    this.issuer = 'jwt' in auth ? auth.jwt?.issuer : undefined;
-    this.audience = 'jwt' in auth ? auth.jwt?.audience : undefined;
-
-    this.accessSecret = (
-      'jwt' in auth ? auth.jwt.accessSecret : auth.accessSecret
-    ) as Secret;
-    this.refreshSecret = (
-      'jwt' in auth ? auth.jwt.refreshSecret : auth.refreshSecret
-    ) as Secret;
-
-    if (!this.accessSecret || !this.refreshSecret) {
-      throw new Error('Missing JWT secrets (accessSecret/refreshSecret)');
-    }
-
-    const accessExpires = (auth as any).accessExpires ?? '10m';
-    const refreshExpires = (auth as any).refreshExpires ?? '30d';
-
-    this.accessTtlSec = parseDurationToSeconds(accessExpires, 600);
-    this.refreshTtlSec = parseDurationToSeconds(refreshExpires, 30 * 24 * 3600);
-
-    // لاگ مختصر کانفیگ (حساسیت‌ها را لو نمی‌دهیم)
-    this.logger.debug(
-      `init: issuer=${this.issuer ?? '-'} audience=${this.audience ?? '-'} accessTTL=${this.accessTtlSec}s refreshTTL=${this.refreshTtlSec}s aSecLen=${
-        String(this.accessSecret).length
-      } rSecLen=${String(this.refreshSecret).length}`,
-    );
-  }
-
-  /* -------------------- Sign -------------------- */
-
-  signAccess({ userId, roles }: SignAccessInput): string {
-    const payload: Partial<AccessTokenPayload> = {
-      sub: userId,
-      roles,
-      typ: 'access',
-    };
-    const opts: SignOptions = {
-      algorithm: 'HS256',
-      expiresIn: this.accessTtlSec,
-      ...(this.issuer ? { issuer: this.issuer } : {}),
-      ...(this.audience ? { audience: this.audience } : {}),
-    };
-    const tok = sign(payload, this.accessSecret, opts);
-    this.logger.debug(
-      `signAccess: sub=${userId} roles=${roles.join(',')} iss=${this.issuer ?? '-'} aud=${this.audience ?? '-'} alg=HS256`,
-    );
-    return tok;
-  }
-
-  signRefresh({ userId, sessionId, jti }: SignRefreshInput): string {
-    const payload: Partial<RefreshTokenPayload> = {
-      sub: userId,
-      sid: sessionId,
-      typ: 'refresh',
-    };
-    const opts: SignOptions = {
-      algorithm: 'HS256',
-      expiresIn: this.refreshTtlSec,
-      ...(this.issuer ? { issuer: this.issuer } : {}),
-      ...(this.audience ? { audience: this.audience } : {}),
-      jwtid: jti,
-    };
-    const tok = sign(payload, this.refreshSecret, opts);
-    this.logger.debug(
-      `signRefresh: sub=${userId} sid=${sessionId} jti=${jti} iss=${this.issuer ?? '-'} aud=${this.audience ?? '-'} alg=HS256`,
-    );
-    return tok;
-  }
-
-  /* -------------------- Verify -------------------- */
-
-  verifyAccess(token: string): AccessTokenPayload {
-    const decoded = this.safeVerify<AccessTokenPayload>(
-      token,
-      this.accessSecret,
-      false,
-      'access',
-    );
-    if (decoded.typ !== 'access') {
-      throw new UnauthorizedException('Invalid token type.');
-    }
-    if (
-      !decoded.sub ||
-      !Array.isArray(decoded.roles) ||
-      decoded.roles.some((r) => typeof r !== 'string')
-    ) {
-      throw new UnauthorizedException('Malformed access token.');
-    }
-    return decoded;
-  }
-
-  async verifyRefresh(
-    token: string,
-    options: VerifyRefreshOptions = {},
-  ): Promise<RefreshTokenPayload> {
-    const decoded = this.safeVerify<RefreshTokenPayload>(
-      token,
-      this.refreshSecret,
-      options.ignoreExpiration ?? false,
-      'refresh',
-    );
-    if (decoded.typ !== 'refresh' || !decoded.jti || !decoded.sid) {
-      throw new UnauthorizedException('Malformed refresh token.');
-    }
-
-    if (!(options.skipBlacklist ?? false)) {
-      if (await this.isRefreshBlacklisted(decoded.jti)) {
-        throw new UnauthorizedException('Refresh token is revoked.');
-      }
-    }
-
-    return decoded;
-  }
-
-  async peekRefresh(
-    token: string,
-    options: PeekRefreshOptions = {},
-  ): Promise<RefreshTokenPayload | null> {
-    try {
-      const decoded = this.safeVerify<RefreshTokenPayload>(
-        token,
-        this.refreshSecret,
-        options.ignoreExpiration ?? false,
-        'refresh',
-      );
-      if (decoded.typ !== 'refresh' || !decoded.jti || !decoded.sid)
-        return null;
-
-      if (!(options.allowBlacklisted ?? true)) {
-        if (await this.isRefreshBlacklisted(decoded.jti)) return null;
-      }
-      return decoded;
-    } catch {
-      // fallback: decode خام برای دیباگ
-      try {
-        const raw = this.decodeUnsafe(token);
-        if (raw && typeof raw === 'object') return raw as any;
-      } catch {}
-      return null;
-    }
-  }
-
-  /* -------- Blacklist / One-time helpers -------- */
-
-  async blacklistRefreshJti(jti: string, ttlSec?: number): Promise<void> {
-    const key = TokenService.keyRefreshBlacklist(jti);
-    const ttl = Number.isFinite(ttlSec) && ttlSec ? ttlSec : this.refreshTtlSec;
-    await this.redis.set(key, '1', 'EX', ttl);
-  }
-
-  async isRefreshBlacklisted(jti: string): Promise<boolean> {
-    const key = TokenService.keyRefreshBlacklist(jti);
-    const val = await this.redis.get(key);
-    return val === '1';
-  }
-
-  async allowOneTime(jti: string, ttlSec: number): Promise<void> {
-    await this.redis.set(TokenService.keyOneTime(jti), '1', 'EX', ttlSec);
-  }
-
-  async consumeOneTime(jti: string): Promise<boolean> {
-    const key = TokenService.keyOneTime(jti);
-    const exists = await this.redis.get(key);
-    if (!exists) return false;
-    await this.redis.del(key);
-    return true;
-  }
-
-  /* -------------------- Utilities -------------------- */
-
-  decodeUnsafe(token: string): JwtPayload | string | null {
-    return decode(token);
-  }
-
-  extractBearer(authHeader?: string): string | null {
-    if (!authHeader) return null;
-    const [type, ...rest] = authHeader.trim().split(/\s+/);
-    const token = rest.join(' ');
-    return type?.toLowerCase() === 'bearer' && token ? token : null;
-  }
-
-  /* -------------------- Private helpers -------------------- */
-
-  private safeVerify<T extends JwtPayload>(
-    token: string,
-    secret: Secret,
-    ignoreExpiration = false,
-    expectedTyp?: 'access' | 'refresh',
-  ): T {
-    try {
-      const opts: import('jsonwebtoken').VerifyOptions & {
-        ignoreExpiration: boolean;
-        clockTolerance: number;
-      } = {
-        algorithms: ['HS256'],
-        clockTolerance: 5,
-        ignoreExpiration,
-      };
-      if (this.issuer) opts.issuer = this.issuer;
-      if (this.audience) opts.audience = this.audience;
-
-      const decoded = verify(token, secret, opts) as T;
-
-      // typ چک اولیه (اگر خواستیم)
-      if (
-        expectedTyp &&
-        (decoded as any)?.typ &&
-        (decoded as any).typ !== expectedTyp
-      ) {
-        this.logger.warn(
-          `verify typ mismatch: expected=${expectedTyp} got=${(decoded as any).typ}`,
-        );
-        throw new UnauthorizedException('Wrong token type');
-      }
-      return decoded;
-    } catch (err: any) {
-      // تشخیص mismatch: header/payload را decode کنیم
-      try {
-        const [h, p] = token.split('.');
-        const header = JSON.parse(Buffer.from(h, 'base64').toString('utf8'));
-        const payload = JSON.parse(Buffer.from(p, 'base64').toString('utf8'));
-        this.logger.warn(
-          `verify failed: ${err?.message ?? err}\n` +
-            `expected => alg=HS256 iss=${this.issuer ?? '-'} aud=${this.audience ?? '-'} ignoreExp=${ignoreExpiration}\n` +
-            `got      => alg=${header?.alg ?? '-'} typ=${payload?.typ ?? '-'} iss=${payload?.iss ?? '-'} aud=${payload?.aud ?? '-'}\n` +
-            `claims   => sub=${payload?.sub ?? '-'} sid=${payload?.sid ?? '-'} jti=${payload?.jti ?? '-'} exp=${payload?.exp ?? '-'}`,
-        );
-      } catch {
-        this.logger.warn(
-          `verify failed (also decode failed): ${err?.message ?? err}`,
-        );
-      }
-      throw new UnauthorizedException('Invalid token.');
-    }
-  }
-
-  private static keyRefreshBlacklist(jti: string): string {
-    return `${TokenService.RBL_PREFIX}${jti}`;
-  }
-
-  private static keyOneTime(jti: string): string {
-    return `${TokenService.ONCE_PREFIX}${jti}`;
-  }
-}
+import {
+  Inject,
+  Injectable,
+  Logger,
+  UnauthorizedException,
+} from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import type { JwtPayload, Secret, SignOptions } from 'jsonwebtoken';
+import { decode, sign, verify } from 'jsonwebtoken';
+import type Redis from 'ioredis';
+import type { AllConfig } from '@app/config/config.module';
+import { parseDurationToSeconds } from '@app/shared/utils/parse-duration.util';
+import { RoleName } from '@prisma/client';
+
+/* ===================== Types ===================== */
+
+export type AccessTokenPayload = JwtPayload & {
+  sub: string;
+  roles: RoleName[];
+  typ: 'access';
+};
+
+export type RefreshTokenPayload = JwtPayload & {
+  sub: string;
+  sid: string;
+  jti: string;
+  typ: 'refresh';
+};
+
+interface VerifyRefreshOptions {
+  ignoreExpiration?: boolean;
+  skipBlacklist?: boolean;
+}
+
+interface PeekRefreshOptions {
+  ignoreExpiration?: boolean;
+  allowBlacklisted?: boolean;
+}
+
+type SignAccessInput = {
+  userId: string;
+  roles: RoleName[];
+};
+
+type SignRefreshInput = {
+  userId: string;
+  sessionId: string;
+  jti: string;
+};
+
+type AuthConfigLike =
+  | {
+      accessSecret: string;
+      accessExpires: string;
+      refreshSecret: string;
+      refreshExpires: string;
+      cookie?: {
+        sameSite: 'strict' | 'lax' | 'none';
+        secure: boolean;
+        refreshPath: string;
+        accessPath: string;
+      };
+    }
+  | {
+      jwt: {
+        issuer?: string;
+        audience?: string;
+        accessSecret: string;
+        refreshSecret: string;
+      };
+      accessExpires: string;
+      refreshExpires: string;
+      cookie?: {
+        sameSite: 'strict' | 'lax' | 'none';
+        secure: boolean;
+        refreshPath: string;
+        accessPath: string;
+      };
+    };
+
+/* ===================== Service ===================== */
+
+@Injectable()
+export class TokenService {
+  private readonly logger = new Logger(TokenService.name);
+
+  private static readonly RBL_PREFIX = 'auth:rbl:'; // refresh blacklist
+  private static readonly ONCE_PREFIX = 'auth:once:'; // one-time token
+
+  private readonly accessSecret: Secret;
+  private readonly refreshSecret: Secret;
+
+  private readonly issuer: string | undefined;
+  private readonly audience: string | undefined;
+
+  private readonly accessTtlSec: number;
+  private readonly refreshTtlSec: number;
+
+  constructor(
+    private readonly config: ConfigService<AllConfig>,
+    @Inject('REDIS') private readonly redis: Redis,
+  ) {
+    const auth = this.config.get<AuthConfigLike>('auth', { infer: true });
+    if (!auth) throw new Error('Auth config missing');
+
+    this.issuer = 'jwt' in auth ? auth.jwt?.issuer : undefined;
+    this.audience = 'jwt' in auth ? auth.jwt?.audience : undefined;
+
+    this.accessSecret = (
+      'jwt' in auth ? auth.jwt.accessSecret : auth.accessSecret
+    ) as Secret;
+    this.refreshSecret = (
+      'jwt' in auth ? auth.jwt.refreshSecret : auth.refreshSecret
+    ) as Secret;
+
+    if (!this.accessSecret || !this.refreshSecret) {
+      throw new Error('Missing JWT secrets (accessSecret/refreshSecret)');
+    }
+
+    const accessExpires = (auth as any).accessExpires ?? '10m';
+    const refreshExpires = (auth as any).refreshExpires ?? '30d';
+
+    this.accessTtlSec = parseDurationToSeconds(accessExpires, 600);
+    this.refreshTtlSec = parseDurationToSeconds(refreshExpires, 30 * 24 * 3600);
+
+    // لاگ مختصر کانفیگ (حساسیت‌ها را لو نمی‌دهیم)
+    this.logger.debug(
+      `init: issuer=${this.issuer ?? '-'} audience=${this.audience ?? '-'} accessTTL=${this.accessTtlSec}s refreshTTL=${this.refreshTtlSec}s aSecLen=${
+        String(this.accessSecret).length
+      } rSecLen=${String(this.refreshSecret).length}`,
+    );
+  }
+
+  /* -------------------- Sign -------------------- */
+
+  signAccess({ userId, roles }: SignAccessInput): string {
+    const payload: Partial<AccessTokenPayload> = {
+      sub: userId,
+      roles,
+      typ: 'access',
+    };
+    const opts: SignOptions = {
+      algorithm: 'HS256',
+      expiresIn: this.accessTtlSec,
+      ...(this.issuer ? { issuer: this.issuer } : {}),
+      ...(this.audience ? { audience: this.audience } : {}),
+    };
+    const tok = sign(payload, this.accessSecret, opts);
+    this.logger.debug(
+      `signAccess: sub=${userId} roles=${roles.join(',')} iss=${this.issuer ?? '-'} aud=${this.audience ?? '-'} alg=HS256`,
+    );
+    return tok;
+  }
+
+  signRefresh({ userId, sessionId, jti }: SignRefreshInput): string {
+    const payload: Partial<RefreshTokenPayload> = {
+      sub: userId,
+      sid: sessionId,
+      typ: 'refresh',
+    };
+    const opts: SignOptions = {
+      algorithm: 'HS256',
+      expiresIn: this.refreshTtlSec,
+      ...(this.issuer ? { issuer: this.issuer } : {}),
+      ...(this.audience ? { audience: this.audience } : {}),
+      jwtid: jti,
+    };
+    const tok = sign(payload, this.refreshSecret, opts);
+    this.logger.debug(
+      `signRefresh: sub=${userId} sid=${sessionId} jti=${jti} iss=${this.issuer ?? '-'} aud=${this.audience ?? '-'} alg=HS256`,
+    );
+    return tok;
+  }
+
+  /* -------------------- Verify -------------------- */
+
+  verifyAccess(token: string): AccessTokenPayload {
+    const decoded = this.safeVerify<AccessTokenPayload>(
+      token,
+      this.accessSecret,
+      false,
+      'access',
+    );
+    if (decoded.typ !== 'access') {
+      throw new UnauthorizedException('Invalid token type.');
+    }
+    if (
+      !decoded.sub ||
+      !Array.isArray(decoded.roles) ||
+      decoded.roles.some((r) => typeof r !== 'string')
+    ) {
+      throw new UnauthorizedException('Malformed access token.');
+    }
+    return decoded;
+  }
+
+  async verifyRefresh(
+    token: string,
+    options: VerifyRefreshOptions = {},
+  ): Promise<RefreshTokenPayload> {
+    const decoded = this.safeVerify<RefreshTokenPayload>(
+      token,
+      this.refreshSecret,
+      options.ignoreExpiration ?? false,
+      'refresh',
+    );
+    if (decoded.typ !== 'refresh' || !decoded.jti || !decoded.sid) {
+      throw new UnauthorizedException('Malformed refresh token.');
+    }
+
+    if (!(options.skipBlacklist ?? false)) {
+      if (await this.isRefreshBlacklisted(decoded.jti)) {
+        throw new UnauthorizedException('Refresh token is revoked.');
+      }
+    }
+
+    return decoded;
+  }
+
+  async peekRefresh(
+    token: string,
+    options: PeekRefreshOptions = {},
+  ): Promise<RefreshTokenPayload | null> {
+    try {
+      const decoded = this.safeVerify<RefreshTokenPayload>(
+        token,
+        this.refreshSecret,
+        options.ignoreExpiration ?? false,
+        'refresh',
+      );
+      if (decoded.typ !== 'refresh' || !decoded.jti || !decoded.sid)
+        return null;
+
+      if (!(options.allowBlacklisted ?? true)) {
+        if (await this.isRefreshBlacklisted(decoded.jti)) return null;
+      }
+      return decoded;
+    } catch {
+      // fallback: decode خام برای دیباگ
+      try {
+        const raw = this.decodeUnsafe(token);
+        if (raw && typeof raw === 'object') return raw as any;
+      } catch {}
+      return null;
+    }
+  }
+
+  /* -------- Blacklist / One-time helpers -------- */
+
+  async blacklistRefreshJti(jti: string, ttlSec?: number): Promise<void> {
+    const key = TokenService.keyRefreshBlacklist(jti);
+    const ttl = Number.isFinite(ttlSec) && ttlSec ? ttlSec : this.refreshTtlSec;
+    await this.redis.set(key, '1', 'EX', ttl);
+  }
+
+  async isRefreshBlacklisted(jti: string): Promise<boolean> {
+    const key = TokenService.keyRefreshBlacklist(jti);
+    const val = await this.redis.get(key);
+    return val === '1';
+  }
+
+  async allowOneTime(jti: string, ttlSec: number): Promise<void> {
+    await this.redis.set(TokenService.keyOneTime(jti), '1', 'EX', ttlSec);
+  }
+
+  async consumeOneTime(jti: string): Promise<boolean> {
+    const key = TokenService.keyOneTime(jti);
+    const exists = await this.redis.get(key);
+    if (!exists) return false;
+    await this.redis.del(key);
+    return true;
+  }
+
+  /* -------------------- Utilities -------------------- */
+
+  decodeUnsafe(token: string): JwtPayload | string | null {
+    return decode(token);
+  }
+
+  extractBearer(authHeader?: string): string | null {
+    if (!authHeader) return null;
+    const [type, ...rest] = authHeader.trim().split(/\s+/);
+    const token = rest.join(' ');
+    return type?.toLowerCase() === 'bearer' && token ? token : null;
+  }
+
+  /* -------------------- Private helpers -------------------- */
+
+  private safeVerify<T extends JwtPayload>(
+    token: string,
+    secret: Secret,
+    ignoreExpiration = false,
+    expectedTyp?: 'access' | 'refresh',
+  ): T {
+    try {
+      const opts: import('jsonwebtoken').VerifyOptions & {
+        ignoreExpiration: boolean;
+        clockTolerance: number;
+      } = {
+        algorithms: ['HS256'],
+        clockTolerance: 5,
+        ignoreExpiration,
+      };
+      if (this.issuer) opts.issuer = this.issuer;
+      if (this.audience) opts.audience = this.audience;
+
+      const decoded = verify(token, secret, opts) as T;
+
+      // typ چک اولیه (اگر خواستیم)
+      if (
+        expectedTyp &&
+        (decoded as any)?.typ &&
+        (decoded as any).typ !== expectedTyp
+      ) {
+        this.logger.warn(
+          `verify typ mismatch: expected=${expectedTyp} got=${(decoded as any).typ}`,
+        );
+        throw new UnauthorizedException('Wrong token type');
+      }
+      return decoded;
+    } catch (err: any) {
+      // تشخیص mismatch: header/payload را decode کنیم
+      try {
+        const [h, p] = token.split('.');
+        const header = JSON.parse(Buffer.from(h, 'base64').toString('utf8'));
+        const payload = JSON.parse(Buffer.from(p, 'base64').toString('utf8'));
+        this.logger.warn(
+          `verify failed: ${err?.message ?? err}\n` +
+            `expected => alg=HS256 iss=${this.issuer ?? '-'} aud=${this.audience ?? '-'} ignoreExp=${ignoreExpiration}\n` +
+            `got      => alg=${header?.alg ?? '-'} typ=${payload?.typ ?? '-'} iss=${payload?.iss ?? '-'} aud=${payload?.aud ?? '-'}\n` +
+            `claims   => sub=${payload?.sub ?? '-'} sid=${payload?.sid ?? '-'} jti=${payload?.jti ?? '-'} exp=${payload?.exp ?? '-'}`,
+        );
+      } catch {
+        this.logger.warn(
+          `verify failed (also decode failed): ${err?.message ?? err}`,
+        );
+      }
+      throw new UnauthorizedException('Invalid token.');
+    }
+  }
+
+  private static keyRefreshBlacklist(jti: string): string {
+    return `${TokenService.RBL_PREFIX}${jti}`;
+  }
+
+  private static keyOneTime(jti: string): string {
+    return `${TokenService.ONCE_PREFIX}${jti}`;
+  }
+}
diff --git a/apps/api/src/core/core.module.ts b/apps/api/src/core/core.module.ts
index 7922db6..5019242 100644
--- a/apps/api/src/core/core.module.ts
+++ b/apps/api/src/core/core.module.ts
@@ -1,9 +1,9 @@
 import { Module } from '@nestjs/common';
-import { AuthModule } from './auth/auth.module';
-import { ProfileModule } from './users/profile/profile.module';
-import { RolesModule } from './roles/roles.module';
-import { UsersModule } from './users/users.module';
-import { UploadModule } from './upload/upload.module';
+import { AuthModule } from '@app/core/auth/auth.module';
+import { ProfileModule } from '@app/core/users/profile/profile.module';
+import { RolesModule } from '@app/core/roles/roles.module';
+import { UsersModule } from '@app/core/users/users.module';
+import { UploadModule } from '@app/core/upload/upload.module';
 
 @Module({
   imports: [AuthModule, ProfileModule, RolesModule, UsersModule, UploadModule],
diff --git a/apps/api/src/core/media/media.module.ts b/apps/api/src/core/media/media.module.ts
index 75c708b..7602685 100644
--- a/apps/api/src/core/media/media.module.ts
+++ b/apps/api/src/core/media/media.module.ts
@@ -1,5 +1,5 @@
 import { Module } from '@nestjs/common';
-import { MediaService } from './media.service';
+import { MediaService } from '@app/core/media/media.service';
 import { PrismaModule } from '@app/prisma/prisma.module';
 
 @Module({
diff --git a/apps/api/src/core/media/media.service.ts b/apps/api/src/core/media/media.service.ts
index bfb6830..b9d87e6 100644
--- a/apps/api/src/core/media/media.service.ts
+++ b/apps/api/src/core/media/media.service.ts
@@ -1,67 +1,67 @@
-import {
-  Injectable,
-  InternalServerErrorException,
-  Logger,
-} from '@nestjs/common';
-import { PrismaService } from '@app/prisma/prisma.service';
-
-export type CreateFileInput = {
-  userId: string;
-  filename: string;
-  mime: string;
-  size: bigint;
-  path: string;
-  url: string; // absolute CDN url
-  status?: 'pending' | 'uploaded' | 'failed';
-};
-
-@Injectable()
-export class MediaService {
-  private readonly logger = new Logger(MediaService.name);
-
-  constructor(private readonly prisma: PrismaService) {}
-
-  /**
-   * Persist uploaded file metadata into database.
-   * Called by UploadService.finish() after successful storage upload.
-   */
-  async createFile(input: CreateFileInput) {
-    try {
-      const created = await this.prisma.file.create({
-        data: {
-          userId: input.userId,
-          filename: input.filename,
-          mime: input.mime,
-          size: input.size,
-          path: input.path,
-          url: input.url,
-          status: input.status ?? 'uploaded',
-        },
-      });
-      this.logger.debug(`Media file saved: ${created.id} (${input.filename})`);
-      return created;
-    } catch (err) {
-      this.logger.error(
-        `Failed to create media record: ${(err as Error).message}`,
-      );
-      throw new InternalServerErrorException('failed to create media record');
-    }
-  }
-
-  /**
-   * Fetch single file by id.
-   */
-  async getFile(id: string) {
-    return this.prisma.file.findUnique({ where: { id } });
-  }
-
-  /**
-   * Optional: list all files of a user (useful for dashboards).
-   */
-  async listUserFiles(userId: string) {
-    return this.prisma.file.findMany({
-      where: { userId },
-      orderBy: { createdAt: 'desc' },
-    });
-  }
-}
+import {
+  Injectable,
+  InternalServerErrorException,
+  Logger,
+} from '@nestjs/common';
+import { PrismaService } from '@app/prisma/prisma.service';
+
+export type CreateFileInput = {
+  userId: string;
+  filename: string;
+  mime: string;
+  size: bigint;
+  path: string;
+  url: string; // absolute CDN url
+  status?: 'pending' | 'uploaded' | 'failed';
+};
+
+@Injectable()
+export class MediaService {
+  private readonly logger = new Logger(MediaService.name);
+
+  constructor(private readonly prisma: PrismaService) {}
+
+  /**
+   * Persist uploaded file metadata into database.
+   * Called by UploadService.finish() after successful storage upload.
+   */
+  async createFile(input: CreateFileInput) {
+    try {
+      const created = await this.prisma.file.create({
+        data: {
+          userId: input.userId,
+          filename: input.filename,
+          mime: input.mime,
+          size: input.size,
+          path: input.path,
+          url: input.url,
+          status: input.status ?? 'uploaded',
+        },
+      });
+      this.logger.debug(`Media file saved: ${created.id} (${input.filename})`);
+      return created;
+    } catch (err) {
+      this.logger.error(
+        `Failed to create media record: ${(err as Error).message}`,
+      );
+      throw new InternalServerErrorException('failed to create media record');
+    }
+  }
+
+  /**
+   * Fetch single file by id.
+   */
+  async getFile(id: string) {
+    return this.prisma.file.findUnique({ where: { id } });
+  }
+
+  /**
+   * Optional: list all files of a user (useful for dashboards).
+   */
+  async listUserFiles(userId: string) {
+    return this.prisma.file.findMany({
+      where: { userId },
+      orderBy: { createdAt: 'desc' },
+    });
+  }
+}
diff --git a/apps/api/src/core/roles/dto/assign-role.dto.ts b/apps/api/src/core/roles/dto/assign-role.dto.ts
index 17b9306..d3e4be8 100644
--- a/apps/api/src/core/roles/dto/assign-role.dto.ts
+++ b/apps/api/src/core/roles/dto/assign-role.dto.ts
@@ -1,18 +1,40 @@
-﻿/**
- * DTO describing the payload for assigning a role to a user.
- */
-import { ApiProperty } from '@nestjs/swagger';
-import { IsUUID } from 'class-validator';
-
-/**
- * Requires both user and role identifiers.
- */
-export class AssignRoleDto {
-  @ApiProperty({ format: 'uuid', description: 'Target user identifier.' })
-  @IsUUID('4')
-  userId: string;
-
-  @ApiProperty({ format: 'uuid', description: 'Role identifier to assign.' })
-  @IsUUID('4')
-  roleId: string;
-}
+﻿/**
+ * DTO for assigning a role to a user.
+ * Supports either roleId (UUID) or roleName (enum value).
+ */
+import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
+import { IsEnum, IsOptional, IsUUID, ValidateIf } from 'class-validator';
+import { RoleName } from '@prisma/client';
+
+export class AssignRoleDto {
+  @ApiProperty({
+    format: 'uuid',
+    description: 'UUID of the target user who will receive the role.',
+    example: 'a97d63b8-1f4e-4c3b-91d8-69f3a9a1a888',
+  })
+  @IsUUID('4', { message: 'Invalid userId format. Must be a UUID v4.' })
+  userId!: string;
+
+  @ApiPropertyOptional({
+    format: 'uuid',
+    description: 'UUID of the role to assign (alternative to roleName).',
+    example: '67a6dbea-0d3b-4e1e-8aa8-2f6c6df83bb4',
+  })
+  @ValidateIf((o) => !o.roleName)
+  @IsUUID('4', { message: 'Invalid roleId format. Must be a UUID v4.' })
+  @IsOptional()
+  roleId?: string;
+
+  @ApiPropertyOptional({
+    enum: RoleName,
+    description:
+      'Name of the role to assign (alternative to roleId). Uses Prisma enum values.',
+    example: 'admin',
+  })
+  @ValidateIf((o) => !o.roleId)
+  @IsEnum(RoleName, {
+    message: 'Invalid roleName. Must be a valid RoleName enum.',
+  })
+  @IsOptional()
+  roleName?: RoleName;
+}
diff --git a/apps/api/src/core/roles/dto/create-role.dto.ts b/apps/api/src/core/roles/dto/create-role.dto.ts
index 63a59e0..65ac379 100644
--- a/apps/api/src/core/roles/dto/create-role.dto.ts
+++ b/apps/api/src/core/roles/dto/create-role.dto.ts
@@ -1,18 +1,19 @@
-/**
- * DTO for creating new role definitions.
- */
-import { ApiProperty } from '@nestjs/swagger';
-import { RoleName } from '@prisma/client';
-import { IsEnum } from 'class-validator';
-
-/**
- * Captures the enum-backed name when creating a role.
- */
-export class CreateRoleDto {
-  @ApiProperty({
-    enum: RoleName,
-    description: 'Role name from the predefined enum.',
-  })
-  @IsEnum(RoleName)
-  name: RoleName;
-}
+/**
+ * DTO for creating new role definitions.
+ * Wraps a single enum-backed name property.
+ */
+import { ApiProperty } from '@nestjs/swagger';
+import { RoleName } from '@prisma/client';
+import { IsEnum } from 'class-validator';
+
+export class CreateRoleDto {
+  @ApiProperty({
+    enum: RoleName,
+    description: 'Predefined role name from the RoleName enum.',
+    example: 'admin',
+  })
+  @IsEnum(RoleName, {
+    message: 'Invalid role name. Must be one of the RoleName enum values.',
+  })
+  name!: RoleName;
+}
diff --git a/apps/api/src/core/roles/dto/find-roles-query.dto.ts b/apps/api/src/core/roles/dto/find-roles-query.dto.ts
index 3067760..0d09e29 100644
--- a/apps/api/src/core/roles/dto/find-roles-query.dto.ts
+++ b/apps/api/src/core/roles/dto/find-roles-query.dto.ts
@@ -1,27 +1,36 @@
-/**
- * DTO describing optional filters when listing roles.
- */
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import { RoleName } from '@prisma/client';
-import { Type } from 'class-transformer';
-import { IsEnum, IsOptional, Max, Min } from 'class-validator';
-
-/**
- * Allows filtering by name and limiting results.
- */
-export class FindRolesQueryDto {
-  @ApiPropertyOptional({ enum: RoleName, description: 'Filter by role name.' })
-  @IsOptional()
-  @IsEnum(RoleName)
-  name?: RoleName;
-
-  @ApiPropertyOptional({
-    default: 25,
-    description: 'Maximum number of records to return.',
-  })
-  @IsOptional()
-  @Type(() => Number)
-  @Min(1)
-  @Max(100)
-  limit?: number;
-}
+/**
+ * DTO for querying and filtering role records.
+ * Supports filtering by enum name and limiting page size.
+ */
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import { RoleName } from '@prisma/client';
+import { Type } from 'class-transformer';
+import { IsEnum, IsOptional, IsInt, Max, Min } from 'class-validator';
+
+export class FindRolesQueryDto {
+  @ApiPropertyOptional({
+    enum: RoleName,
+    description: 'Filter results by specific role name (optional).',
+    example: 'admin',
+  })
+  @IsOptional()
+  @IsEnum(RoleName, {
+    message: 'Invalid role name. Must be a valid RoleName enum value.',
+  })
+  name?: RoleName;
+
+  @ApiPropertyOptional({
+    type: Number,
+    default: 25,
+    minimum: 1,
+    maximum: 100,
+    description: 'Maximum number of roles to return (1–100). Default is 25.',
+    example: 25,
+  })
+  @IsOptional()
+  @Type(() => Number)
+  @IsInt({ message: 'Limit must be an integer number.' })
+  @Min(1, { message: 'Limit must be at least 1.' })
+  @Max(100, { message: 'Limit cannot exceed 100.' })
+  limit?: number = 25;
+}
diff --git a/apps/api/src/core/roles/dto/find-user-roles-query.dto.ts b/apps/api/src/core/roles/dto/find-user-roles-query.dto.ts
index 3a9594c..723b1ae 100644
--- a/apps/api/src/core/roles/dto/find-user-roles-query.dto.ts
+++ b/apps/api/src/core/roles/dto/find-user-roles-query.dto.ts
@@ -1,35 +1,38 @@
-/**
- * DTO describing optional filters when querying user-role assignments.
- */
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import { RoleName } from '@prisma/client';
-import { IsEnum, IsOptional, IsUUID } from 'class-validator';
-
-/**
- * Filter object used to narrow user-role listings.
- */
-export class FindUserRolesQueryDto {
-  @ApiPropertyOptional({
-    format: 'uuid',
-    description: 'Filter results by user identifier.',
-  })
-  @IsOptional()
-  @IsUUID('4')
-  userId?: string;
-
-  @ApiPropertyOptional({
-    format: 'uuid',
-    description: 'Filter results by role identifier.',
-  })
-  @IsOptional()
-  @IsUUID('4')
-  roleId?: string;
-
-  @ApiPropertyOptional({
-    enum: RoleName,
-    description: 'Filter by role name enum value.',
-  })
-  @IsOptional()
-  @IsEnum(RoleName)
-  roleName?: RoleName;
-}
+/**
+ * DTO for filtering user–role assignments in administrative queries.
+ * Supports filtering by userId, roleId, or roleName.
+ */
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import { RoleName } from '@prisma/client';
+import { IsEnum, IsOptional, IsUUID } from 'class-validator';
+
+export class FindUserRolesQueryDto {
+  @ApiPropertyOptional({
+    format: 'uuid',
+    description: 'Filter results by target user UUID.',
+    example: '3b797f02-91f8-4d81-8bad-abb197690ecd',
+  })
+  @IsOptional()
+  @IsUUID('4', { message: 'userId must be a valid UUID v4.' })
+  userId?: string;
+
+  @ApiPropertyOptional({
+    format: 'uuid',
+    description: 'Filter results by role UUID.',
+    example: 'a4e66398-75ab-4909-9c65-58ac4d99be3b',
+  })
+  @IsOptional()
+  @IsUUID('4', { message: 'roleId must be a valid UUID v4.' })
+  roleId?: string;
+
+  @ApiPropertyOptional({
+    enum: RoleName,
+    description: 'Filter results by role name (enum value).',
+    example: 'admin',
+  })
+  @IsOptional()
+  @IsEnum(RoleName, {
+    message: 'roleName must be a valid RoleName enum value.',
+  })
+  roleName?: RoleName;
+}
diff --git a/apps/api/src/core/roles/dto/role-name-param.dto.ts b/apps/api/src/core/roles/dto/role-name-param.dto.ts
index b3ddb1a..0d04504 100644
--- a/apps/api/src/core/roles/dto/role-name-param.dto.ts
+++ b/apps/api/src/core/roles/dto/role-name-param.dto.ts
@@ -1,15 +1,20 @@
-/**
- * DTO validating the role name route parameter.
- */
-import { ApiProperty } from '@nestjs/swagger';
-import { RoleName } from '@prisma/client';
-import { IsEnum } from 'class-validator';
-
-/**
- * Ensures the name parameter matches the RoleName enum.
- */
-export class RoleNameParamDto {
-  @ApiProperty({ enum: RoleName, description: 'Target role name parameter.' })
-  @IsEnum(RoleName)
-  name: RoleName;
-}
+/**
+ * DTO validating the `name` route parameter for role-related endpoints.
+ * Ensures that the provided name is a valid RoleName enum value.
+ */
+import { ApiProperty } from '@nestjs/swagger';
+import { RoleName } from '@prisma/client';
+import { IsEnum } from 'class-validator';
+
+export class RoleNameParamDto {
+  @ApiProperty({
+    enum: RoleName,
+    description:
+      'Role name parameter (must match one of the RoleName enum values).',
+    example: 'admin',
+  })
+  @IsEnum(RoleName, {
+    message: 'Invalid role name. Must be a valid RoleName enum value.',
+  })
+  name!: RoleName;
+}
diff --git a/apps/api/src/core/roles/dto/update-role.dto.ts b/apps/api/src/core/roles/dto/update-role.dto.ts
index 23a245d..fd9c7ff 100644
--- a/apps/api/src/core/roles/dto/update-role.dto.ts
+++ b/apps/api/src/core/roles/dto/update-role.dto.ts
@@ -1,10 +1,21 @@
 /**
- * DTO for updating an existing role; leverages CreateRoleDto for validation.
+ * DTO for updating an existing role definition.
+ * Inherits validation rules from CreateRoleDto but makes all fields optional.
  */
-import { PartialType } from '@nestjs/swagger';
-import { CreateRoleDto } from './create-role.dto';
+import { PartialType, ApiPropertyOptional } from '@nestjs/swagger';
+import { CreateRoleDto } from '@app/core/roles/dto/create-role.dto';
+import { RoleName } from '@prisma/client';
+import { IsEnum, IsOptional } from 'class-validator';
 
-/**
- * Partial version of CreateRoleDto used for role updates.
- */
-export class UpdateRoleDto extends PartialType(CreateRoleDto) {}
+export class UpdateRoleDto extends PartialType(CreateRoleDto) {
+  @ApiPropertyOptional({
+    enum: RoleName,
+    description: 'New role name (enum value) to replace the existing one.',
+    example: 'supplier',
+  })
+  @IsOptional()
+  @IsEnum(RoleName, {
+    message: 'Invalid role name. Must be a valid RoleName enum value.',
+  })
+  override name?: RoleName;
+}
diff --git a/apps/api/src/core/roles/dto/user-role-id-param.dto.ts b/apps/api/src/core/roles/dto/user-role-id-param.dto.ts
index 6f78817..8c00d55 100644
--- a/apps/api/src/core/roles/dto/user-role-id-param.dto.ts
+++ b/apps/api/src/core/roles/dto/user-role-id-param.dto.ts
@@ -1,14 +1,18 @@
-﻿/**
- * DTO enforcing UUID validation for user-role resource parameters.
- */
-import { ApiProperty } from '@nestjs/swagger';
-import { IsUUID } from 'class-validator';
-
-/**
- * Expects a UUID v4 string representing the user-role relation identifier.
- */
-export class UserRoleIdParamDto {
-  @ApiProperty({ format: 'uuid', description: 'User-role record identifier.' })
-  @IsUUID('4')
-  id: string;
-}
+﻿/**
+ * DTO enforcing UUID validation for user–role route parameters.
+ * Used when referencing a specific user-role assignment by its identifier.
+ */
+import { ApiProperty } from '@nestjs/swagger';
+import { IsUUID } from 'class-validator';
+
+export class UserRoleIdParamDto {
+  @ApiProperty({
+    format: 'uuid',
+    description: 'Unique identifier of the user–role assignment record.',
+    example: 'b4a9129d-6b24-4f98-99b4-9c9a8f8a14b0',
+  })
+  @IsUUID('4', {
+    message: 'Invalid id format. Must be a valid UUID v4 string.',
+  })
+  id!: string;
+}
diff --git a/apps/api/src/core/roles/roles.controller.ts b/apps/api/src/core/roles/roles.controller.ts
index 1c078b3..656bb64 100644
--- a/apps/api/src/core/roles/roles.controller.ts
+++ b/apps/api/src/core/roles/roles.controller.ts
@@ -9,6 +9,8 @@ import {
   Patch,
   Post,
   Query,
+  HttpCode,
+  HttpStatus,
 } from '@nestjs/common';
 import {
   ApiBearerAuth,
@@ -17,11 +19,11 @@ import {
   ApiTags,
 } from '@nestjs/swagger';
 import { Roles } from '@app/common/decorators/roles.decorator';
-import { CreateRoleDto } from './dto/create-role.dto';
-import { FindRolesQueryDto } from './dto/find-roles-query.dto';
-import { RoleNameParamDto } from './dto/role-name-param.dto';
-import { UpdateRoleDto } from './dto/update-role.dto';
-import { RolesService } from './roles.service';
+import { CreateRoleDto } from '@app/core/roles/dto/create-role.dto';
+import { FindRolesQueryDto } from '@app/core/roles/dto/find-roles-query.dto';
+import { RoleNameParamDto } from '@app/core/roles/dto/role-name-param.dto';
+import { UpdateRoleDto } from '@app/core/roles/dto/update-role.dto';
+import { RolesService } from '@app/core/roles/roles.service';
 import { RoleName } from '@prisma/client';
 
 @ApiTags('Roles')
@@ -35,42 +37,37 @@ export class RolesController {
 
   /**
    * Lists roles, optionally filtered, for administrators.
-   * @param query Query params including optional name filter.
    */
   @Get()
   @Roles(RoleName.admin)
   @ApiOperation({
     summary: 'List roles',
-    description: 'Lists roles with optional filtering by name.',
-  })
-  @ApiResponse({
-    status: 200,
-    description: 'Roles retrieved successfully.',
+    description: 'Lists roles with optional filtering by name and limit.',
   })
+  @ApiResponse({ status: 200, description: 'Roles retrieved successfully.' })
+  @ApiResponse({ status: 403, description: 'Forbidden.' })
   findAll(@Query() query: FindRolesQueryDto) {
     return this.rolesService.findAll(query);
   }
 
   /**
-   * Fetches a single role by name.
-   * @param params Route params enforcing enum validation.
+   * Fetches a single role by name (admin-only).
    */
   @Get(':name')
+  @Roles(RoleName.admin)
   @ApiOperation({
     summary: 'Get role by name',
     description: 'Returns role details for the provided enum value.',
   })
-  @ApiResponse({
-    status: 200,
-    description: 'Role retrieved successfully.',
-  })
+  @ApiResponse({ status: 200, description: 'Role retrieved successfully.' })
+  @ApiResponse({ status: 403, description: 'Forbidden.' })
+  @ApiResponse({ status: 404, description: 'Role not found.' })
   findByName(@Param() params: RoleNameParamDto) {
     return this.rolesService.findByName(params.name);
   }
 
   /**
    * Creates a new role record (admin-only).
-   * @param dto Role creation payload.
    */
   @Post()
   @Roles(RoleName.admin)
@@ -79,23 +76,32 @@ export class RolesController {
     description: 'Creates a new role using one of the predefined enum values.',
   })
   @ApiResponse({ status: 201, description: 'Role created successfully.' })
+  @ApiResponse({ status: 403, description: 'Forbidden.' })
+  @ApiResponse({
+    status: 409,
+    description: 'Role with this name already exists.',
+  })
   create(@Body() dto: CreateRoleDto) {
     return this.rolesService.create(dto);
   }
 
   /**
-   * Renames an existing role.
-   * @param params Route params referencing the current role name.
-   * @param dto Payload containing the new name.
+   * Renames an existing role (admin-only).
    */
   @Patch(':name')
   @Roles(RoleName.admin)
+  @HttpCode(HttpStatus.OK)
   @ApiOperation({
     summary: 'Update role',
-    description:
-      'Replaces the existing role name with a new enum value. Returns 404 when the role is not found.',
+    description: 'Renames an existing role to a new enum value.',
   })
   @ApiResponse({ status: 200, description: 'Role updated successfully.' })
+  @ApiResponse({ status: 403, description: 'Forbidden.' })
+  @ApiResponse({ status: 404, description: 'Role not found.' })
+  @ApiResponse({
+    status: 409,
+    description: 'Another role already uses the requested name.',
+  })
   update(@Param() params: RoleNameParamDto, @Body() dto: UpdateRoleDto) {
     return this.rolesService.update(params.name, dto);
   }
diff --git a/apps/api/src/core/roles/roles.module.ts b/apps/api/src/core/roles/roles.module.ts
index fd3da5f..0e3a568 100644
--- a/apps/api/src/core/roles/roles.module.ts
+++ b/apps/api/src/core/roles/roles.module.ts
@@ -2,10 +2,10 @@
  * RolesModule exposes the role controller/service for RBAC administration.
  */
 import { Module } from '@nestjs/common';
-import { RolesController } from './roles.controller';
-import { RolesService } from './roles.service';
-import { UserRolesController } from './user-roles.controller';
-import { UserRolesService } from './user-roles.service';
+import { RolesController } from '@app/core/roles/roles.controller';
+import { RolesService } from '@app/core/roles/roles.service';
+import { UserRolesController } from '@app/core/roles/user-roles.controller';
+import { UserRolesService } from '@app/core/roles/user-roles.service';
 
 @Module({
   controllers: [RolesController, UserRolesController],
diff --git a/apps/api/src/core/roles/roles.service.ts b/apps/api/src/core/roles/roles.service.ts
index 285e565..38bc195 100644
--- a/apps/api/src/core/roles/roles.service.ts
+++ b/apps/api/src/core/roles/roles.service.ts
@@ -1,12 +1,17 @@
 /**
- * RolesService encapsulates TypeORM access for the role catalogue.
+ * RolesService encapsulates Prisma access for the role catalogue.
  */
-import { Injectable, NotFoundException } from '@nestjs/common';
+import {
+  ConflictException,
+  Injectable,
+  NotFoundException,
+} from '@nestjs/common';
 import type { Prisma as PrismaNamespace, RoleName } from '@prisma/client';
 import { PrismaService } from '@app/prisma/prisma.service';
-import { FindRolesQueryDto } from './dto/find-roles-query.dto';
-import { CreateRoleDto } from './dto/create-role.dto';
-import { UpdateRoleDto } from './dto/update-role.dto';
+import { FindRolesQueryDto } from '@app/core/roles/dto/find-roles-query.dto';
+import { CreateRoleDto } from '@app/core/roles/dto/create-role.dto';
+import { UpdateRoleDto } from '@app/core/roles/dto/update-role.dto';
+import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
 
 type RoleRecord = PrismaNamespace.RoleGetPayload<{}>;
 
@@ -19,13 +24,11 @@ export class RolesService {
 
   /**
    * Retrieves roles with optional filtering and limit.
-   * @param query Filtering & pagination options.
+   * Aligns with FindRolesQueryDto (name?, limit?).
    */
   async findAll(query: FindRolesQueryDto): Promise<RoleRecord[]> {
     const where: PrismaNamespace.RoleWhereInput = {};
-    if (query.name) {
-      where.name = query.name;
-    }
+    if (query.name) where.name = query.name;
 
     return this.prisma.role.findMany({
       where,
@@ -36,7 +39,6 @@ export class RolesService {
 
   /**
    * Finds a single role by its enum-backed name.
-   * @param name Role name to locate.
    */
   findByName(name: RoleName): Promise<RoleRecord | null> {
     return this.prisma.role.findUnique({ where: { name } });
@@ -44,34 +46,57 @@ export class RolesService {
 
   /**
    * Persists a new role.
-   * @param dto Payload containing the role name.
+   * Maps unique-constraint violations to ConflictException.
    */
   async create(dto: CreateRoleDto): Promise<RoleRecord> {
-    return this.prisma.role.create({
-      data: {
-        name: dto.name,
-      },
-    });
+    try {
+      return await this.prisma.role.create({
+        data: { name: dto.name },
+      });
+    } catch (err) {
+      if (
+        err instanceof PrismaClientKnownRequestError &&
+        err.code === 'P2002'
+      ) {
+        // unique constraint on name
+        throw new ConflictException('Role with this name already exists.');
+      }
+      throw err;
+    }
   }
 
   /**
-   * Updates an existing role, currently supporting renaming.
-   * @param name Current role name.
-   * @param dto Update payload.
-   * @throws NotFoundException when the role does not exist.
+   * Updates an existing role (rename supported).
+   * - 404 if source role not found
+   * - 409 if new name collides with an existing role
    */
   async update(name: RoleName, dto: UpdateRoleDto): Promise<RoleRecord> {
     const existing = await this.prisma.role.findUnique({ where: { name } });
-
     if (!existing) {
       throw new NotFoundException(`نقش ${name} یافت نشد.`);
     }
 
-    return this.prisma.role.update({
-      where: { name },
-      data: {
-        name: dto.name ?? name,
-      },
-    });
+    // If no change requested, return current entity
+    if (!dto.name || dto.name === name) {
+      return existing;
+    }
+
+    try {
+      return await this.prisma.role.update({
+        where: { name },
+        data: { name: dto.name },
+      });
+    } catch (err) {
+      if (
+        err instanceof PrismaClientKnownRequestError &&
+        err.code === 'P2002'
+      ) {
+        // unique constraint on name
+        throw new ConflictException(
+          'Another role with the requested name already exists.',
+        );
+      }
+      throw err;
+    }
   }
 }
diff --git a/apps/api/src/core/roles/user-roles.controller.ts b/apps/api/src/core/roles/user-roles.controller.ts
index 2c942bc..1ddfd0f 100644
--- a/apps/api/src/core/roles/user-roles.controller.ts
+++ b/apps/api/src/core/roles/user-roles.controller.ts
@@ -1,5 +1,5 @@
 /**
- * UserRolesController exposes admin endpoints to browse and mutate user-role assignments.
+ * UserRolesController exposes admin endpoints to browse and mutate user–role assignments.
  */
 import {
   Body,
@@ -9,6 +9,8 @@ import {
   Param,
   Post,
   Query,
+  HttpCode,
+  HttpStatus,
 } from '@nestjs/common';
 import {
   ApiBearerAuth,
@@ -17,68 +19,67 @@ import {
   ApiTags,
 } from '@nestjs/swagger';
 import { Roles } from '@app/common/decorators/roles.decorator';
-import { AssignRoleDto } from './dto/assign-role.dto';
-import { FindUserRolesQueryDto } from './dto/find-user-roles-query.dto';
-import { UserRoleIdParamDto } from './dto/user-role-id-param.dto';
-import { UserRolesService } from './user-roles.service';
+import { AssignRoleDto } from '@app/core/roles/dto/assign-role.dto';
+import { FindUserRolesQueryDto } from '@app/core/roles/dto/find-user-roles-query.dto';
+import { UserRoleIdParamDto } from '@app/core/roles/dto/user-role-id-param.dto';
+import { UserRolesService } from '@app/core/roles/user-roles.service';
 import { RoleName } from '@prisma/client';
 
 @ApiTags('User Roles')
 @ApiBearerAuth('bearer')
 @Controller('core/user-roles')
 /**
- * Provides CRUD-ish operations for the user-role join table.
+ * Provides CRUD-ish operations for the user–role join table.
  */
 export class UserRolesController {
   constructor(private readonly userRolesService: UserRolesService) {}
 
   /**
-   * Lists user-role assignments with optional filters (admin-only).
-   * @param query Filter options such as userId or roleId.
+   * Lists user–role assignments with optional filters (admin-only).
    */
   @Get()
   @Roles(RoleName.admin)
   @ApiOperation({
-    summary: 'List user-role assignments',
-    description: 'Lists user-role assignments with optional filters.',
-  })
-  @ApiResponse({
-    status: 200,
-    description: 'Assignments retrieved successfully.',
+    summary: 'List user–role assignments',
+    description:
+      'Returns user–role assignments filtered by userId, roleId, or roleName.',
   })
+  @ApiResponse({ status: 200, description: 'Assignments retrieved.' })
+  @ApiResponse({ status: 403, description: 'Forbidden.' })
   findAll(@Query() query: FindUserRolesQueryDto) {
     return this.userRolesService.findAll(query);
   }
 
   /**
-   * Assigns a role to a user.
-   * @param dto Payload containing user and role identifiers.
+   * Assigns a role to a user (admin-only).
+   * Supports either roleId or roleName in the payload.
    */
   @Post()
   @Roles(RoleName.admin)
   @ApiOperation({
     summary: 'Assign role to user',
-    description: 'Attaches the specified role to the user.',
+    description:
+      'Attaches the specified role (by roleId or roleName) to the target user.',
   })
-  @ApiResponse({ status: 201, description: 'Role assigned successfully.' })
+  @ApiResponse({ status: 201, description: 'Role assigned.' })
+  @ApiResponse({ status: 404, description: 'User or role not found.' })
+  @ApiResponse({ status: 409, description: 'Role already assigned.' })
   assignRole(@Body() dto: AssignRoleDto) {
     return this.userRolesService.assignRole(dto);
   }
 
   /**
-   * Deletes a user-role assignment by id.
-   * @param params Route params representing the assignment id.
+   * Deletes a user–role assignment by its identifier (admin-only).
    */
   @Delete(':id')
   @Roles(RoleName.admin)
+  @HttpCode(HttpStatus.OK)
   @ApiOperation({
     summary: 'Remove role from user',
-    description: 'Deletes the user-role assignment by id.',
-  })
-  @ApiResponse({
-    status: 200,
-    description: 'User-role assignment removed successfully.',
+    description: 'Deletes a user–role assignment by its UUID identifier.',
   })
+  @ApiResponse({ status: 200, description: 'Assignment removed.' })
+  @ApiResponse({ status: 404, description: 'Assignment not found.' })
   remove(@Param() params: UserRoleIdParamDto) {
     return this.userRolesService.remove(params.id);
   }
diff --git a/apps/api/src/core/roles/user-roles.service.ts b/apps/api/src/core/roles/user-roles.service.ts
index 903febe..40ba9a5 100644
--- a/apps/api/src/core/roles/user-roles.service.ts
+++ b/apps/api/src/core/roles/user-roles.service.ts
@@ -5,8 +5,8 @@ import {
 } from '@nestjs/common';
 import type { Prisma as PrismaNamespace } from '@prisma/client';
 import { PrismaService } from '@app/prisma/prisma.service';
-import { AssignRoleDto } from './dto/assign-role.dto';
-import { FindUserRolesQueryDto } from './dto/find-user-roles-query.dto';
+import { AssignRoleDto } from '@app/core/roles/dto/assign-role.dto';
+import { FindUserRolesQueryDto } from '@app/core/roles/dto/find-user-roles-query.dto';
 import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
 
 type UserRoleWithRelations = PrismaNamespace.UserRoleGetPayload<{
@@ -20,6 +20,10 @@ type UserRoleWithRelations = PrismaNamespace.UserRoleGetPayload<{
 export class UserRolesService {
   constructor(private readonly prisma: PrismaService) {}
 
+  /**
+   * Lists user-role assignments with optional filters.
+   * Aligns with FindUserRolesQueryDto (userId | roleId | roleName).
+   */
   async findAll(
     query: FindUserRolesQueryDto,
   ): Promise<UserRoleWithRelations[]> {
@@ -39,43 +43,79 @@ export class UserRolesService {
 
     return this.prisma.userRole.findMany({
       where,
-      include: {
-        user: true,
-        role: true,
-      },
+      include: { user: true, role: true },
       orderBy: { createdAt: 'desc' },
     });
   }
 
+  /**
+   * Assigns a role to a user.
+   * Supports AssignRoleDto with either roleId or roleName.
+   * - Validates user & role existence
+   * - Uses upsert on (userId, roleId) to avoid race conditions
+   * - Throws Conflict when already assigned (via upsert "no-op" detection)
+   */
   async assignRole(dto: AssignRoleDto): Promise<UserRoleWithRelations> {
-    const existing = await this.prisma.userRole.findUnique({
-      where: {
-        userId_roleId: {
-          userId: dto.userId,
-          roleId: dto.roleId,
-        },
-      },
-    });
+    // 1) Resolve roleId (roleId direct OR roleName -> id)
+    const roleId =
+      dto.roleId ??
+      (
+        await this.prisma.role.findUnique({
+          where: { name: dto.roleName! },
+          select: { id: true },
+        })
+      )?.id;
 
-    if (existing) {
-      throw new ConflictException('Role already assigned to this user.');
+    if (!roleId) {
+      throw new NotFoundException('Role not found.');
     }
 
-    return this.prisma.userRole.create({
-      data: {
-        userId: dto.userId,
-        roleId: dto.roleId,
-      },
-      include: {
-        user: true,
-        role: true,
-      },
+    // 2) Validate user existence (clear 404 instead of FK error)
+    const userExists = await this.prisma.user.findUnique({
+      where: { id: dto.userId },
+      select: { id: true },
     });
+    if (!userExists) {
+      throw new NotFoundException('User not found.');
+    }
+
+    // 3) Upsert on composite unique to be atomic
+    // If the assignment already exists, we surface Conflict to the client.
+    try {
+      return await this.prisma.userRole.upsert({
+        where: {
+          userId_roleId: {
+            userId: dto.userId,
+            roleId,
+          },
+        },
+        update: {}, // existing -> treat as conflict for clearer API semantics
+        create: {
+          userId: dto.userId,
+          roleId,
+        },
+        include: { user: true, role: true },
+      });
+    } catch (err) {
+      // Defensive catch; upsert normally shouldn't throw P2002.
+      if (
+        err instanceof PrismaClientKnownRequestError &&
+        err.code === 'P2002'
+      ) {
+        throw new ConflictException('Role already assigned to this user.');
+      }
+      throw err;
+    }
   }
 
-  async remove(id: string): Promise<void> {
+  /**
+   * Removes a user-role assignment by its UUID id.
+   * Returns a simple success payload for client UX consistency.
+   */
+  async remove(id: string): Promise<{ success: true }> {
     try {
       await this.prisma.userRole.delete({ where: { id } });
+      return { success: true };
     } catch (error) {
       if (
         error instanceof PrismaClientKnownRequestError &&
diff --git a/apps/api/src/core/upload/dto/upload-finish.dto.ts b/apps/api/src/core/upload/dto/upload-finish.dto.ts
index 9009274..e024061 100644
--- a/apps/api/src/core/upload/dto/upload-finish.dto.ts
+++ b/apps/api/src/core/upload/dto/upload-finish.dto.ts
@@ -1,20 +1,20 @@
-import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import { IsOptional, IsString, IsUUID } from 'class-validator';
-
-export class UploadFinishDto {
-  @ApiProperty({
-    description: 'Upload session identifier returned from /upload/init',
-    example: 'b1f8e7a0-7e2d-4c3f-8f2b-0f1e9f8a1c2d',
-  })
-  @IsUUID()
-  uploadId!: string;
-
-  @ApiPropertyOptional({
-    description:
-      'Optional sub-directory within the storage root to place the file',
-    example: 'avatars',
-  })
-  @IsOptional()
-  @IsString()
-  subdir?: string;
-}
+import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
+import { IsOptional, IsString, IsUUID } from 'class-validator';
+
+export class UploadFinishDto {
+  @ApiProperty({
+    description: 'Upload session identifier returned from /upload/init',
+    example: 'b1f8e7a0-7e2d-4c3f-8f2b-0f1e9f8a1c2d',
+  })
+  @IsUUID()
+  uploadId!: string;
+
+  @ApiPropertyOptional({
+    description:
+      'Optional sub-directory within the storage root to place the file',
+    example: 'avatars',
+  })
+  @IsOptional()
+  @IsString()
+  subdir?: string;
+}
diff --git a/apps/api/src/core/upload/dto/upload-init.dto.ts b/apps/api/src/core/upload/dto/upload-init.dto.ts
index be80ea0..78f3758 100644
--- a/apps/api/src/core/upload/dto/upload-init.dto.ts
+++ b/apps/api/src/core/upload/dto/upload-init.dto.ts
@@ -1,29 +1,29 @@
-import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import { IsInt, IsNotEmpty, IsOptional, IsString, Min } from 'class-validator';
-
-export class UploadInitDto {
-  @ApiProperty({
-    description: 'Original filename (used to derive the final stored name)',
-    example: 'profile-picture.png',
-  })
-  @IsString()
-  @IsNotEmpty()
-  filename!: string;
-
-  @ApiProperty({
-    description: 'Total file size in bytes',
-    example: 7340032,
-  })
-  @IsInt()
-  @Min(1)
-  size!: number;
-
-  @ApiPropertyOptional({
-    description: 'Client-reported MIME type (validated server-side)',
-    example: 'image/png',
-    nullable: true,
-  })
-  @IsOptional()
-  @IsString()
-  mime?: string | null;
-}
+import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
+import { IsInt, IsNotEmpty, IsOptional, IsString, Min } from 'class-validator';
+
+export class UploadInitDto {
+  @ApiProperty({
+    description: 'Original filename (used to derive the final stored name)',
+    example: 'profile-picture.png',
+  })
+  @IsString()
+  @IsNotEmpty()
+  filename!: string;
+
+  @ApiProperty({
+    description: 'Total file size in bytes',
+    example: 7340032,
+  })
+  @IsInt()
+  @Min(1)
+  size!: number;
+
+  @ApiPropertyOptional({
+    description: 'Client-reported MIME type (validated server-side)',
+    example: 'image/png',
+    nullable: true,
+  })
+  @IsOptional()
+  @IsString()
+  mime?: string | null;
+}
diff --git a/apps/api/src/core/upload/storage.ftp.spec.ts b/apps/api/src/core/upload/storage.ftp.spec.ts
index f55ca89..706dc35 100644
--- a/apps/api/src/core/upload/storage.ftp.spec.ts
+++ b/apps/api/src/core/upload/storage.ftp.spec.ts
@@ -1,7 +1,7 @@
 import { promises as fs } from 'node:fs';
 import { tmpdir } from 'node:os';
 import { join } from 'node:path';
-import { FTPStorageDriver } from './storage.ftp';
+import { FTPStorageDriver } from '@app/core/upload/storage.ftp';
 
 const ensureDirMock = jest.fn(async () => undefined);
 const uploadFromMock = jest.fn(async () => undefined);
diff --git a/apps/api/src/core/upload/storage.ftp.ts b/apps/api/src/core/upload/storage.ftp.ts
index 032b531..bfb43f4 100644
--- a/apps/api/src/core/upload/storage.ftp.ts
+++ b/apps/api/src/core/upload/storage.ftp.ts
@@ -3,7 +3,7 @@ import * as ftp from 'basic-ftp';
 import { posix as pathPosix } from 'path';
 import * as fs from 'node:fs/promises';
 import { Logger, type LoggerService } from '@nestjs/common';
-import { type StorageDriver, type StorageUploadProgress } from './upload.types';
+import { type StorageDriver, type StorageUploadProgress } from '@app/core/upload/upload.types';
 
 /**
  * بعضی نسخه‌های basic-ftp فیلد useEPSV را ندارند؛
diff --git a/apps/api/src/core/upload/upload.cleanup.ts b/apps/api/src/core/upload/upload.cleanup.ts
index ccbb33f..5f40dfb 100644
--- a/apps/api/src/core/upload/upload.cleanup.ts
+++ b/apps/api/src/core/upload/upload.cleanup.ts
@@ -9,8 +9,8 @@ import {
 import * as fs from 'node:fs/promises';
 import * as fssync from 'node:fs';
 import { basename, join } from 'node:path';
-import { UPLOAD_CONFIG } from './upload.tokens';
-import type { UploadConfig } from './upload.tokens';
+import { UPLOAD_CONFIG } from '@app/core/upload/upload.tokens';
+import type { UploadConfig } from '@app/core/upload/upload.tokens';
 
 function toInt(val: string | number | undefined, fallback: number): number {
   const n = typeof val === 'string' ? Number(val) : val;
diff --git a/apps/api/src/core/upload/upload.controller.spec.ts b/apps/api/src/core/upload/upload.controller.spec.ts
index 57f5c99..c0118db 100644
--- a/apps/api/src/core/upload/upload.controller.spec.ts
+++ b/apps/api/src/core/upload/upload.controller.spec.ts
@@ -1,8 +1,8 @@
 import { Test } from '@nestjs/testing';
 import { INestApplication, ValidationPipe, ConflictException } from '@nestjs/common';
 import * as request from 'supertest';
-import { UploadController } from './upload.controller';
-import { UploadService } from './upload.service';
+import { UploadController } from '@app/core/upload/upload.controller';
+import { UploadService } from '@app/core/upload/upload.service';
 
 describe('UploadController', () => {
   let app: INestApplication;
diff --git a/apps/api/src/core/upload/upload.controller.ts b/apps/api/src/core/upload/upload.controller.ts
index a025db4..68618d4 100644
--- a/apps/api/src/core/upload/upload.controller.ts
+++ b/apps/api/src/core/upload/upload.controller.ts
@@ -14,7 +14,7 @@ import {
   ParseIntPipe,
 } from '@nestjs/common';
 import type { Request, Response } from 'express';
-import { UploadService } from './upload.service';
+import { UploadService } from '@app/core/upload/upload.service';
 
 import {
   ApiBearerAuth,
@@ -33,8 +33,8 @@ import {
   ApiUnprocessableEntityResponse,
 } from '@nestjs/swagger';
 
-import { UploadInitDto } from './dto/upload-init.dto';
-import { UploadFinishDto } from './dto/upload-finish.dto';
+import { UploadInitDto } from '@app/core/upload/dto/upload-init.dto';
+import { UploadFinishDto } from '@app/core/upload/dto/upload-finish.dto';
 
 type RequestWithUser = Request & { user?: { id?: string } };
 
diff --git a/apps/api/src/core/upload/upload.gateway.spec.ts b/apps/api/src/core/upload/upload.gateway.spec.ts
index 2d3d7a4..d64ab8e 100644
--- a/apps/api/src/core/upload/upload.gateway.spec.ts
+++ b/apps/api/src/core/upload/upload.gateway.spec.ts
@@ -1,4 +1,4 @@
-import { UploadGateway, EV_SERVER_PROGRESS, EV_UPLOADED, EV_ERROR, EV_JOINED, EV_LEFT } from './upload.gateway';
+import { UploadGateway, EV_SERVER_PROGRESS, EV_UPLOADED, EV_ERROR, EV_JOINED, EV_LEFT } from '@app/core/upload/upload.gateway';
 
 describe('UploadGateway', () => {
   let gateway: UploadGateway;
diff --git a/apps/api/src/core/upload/upload.gateway.ts b/apps/api/src/core/upload/upload.gateway.ts
index dbc2be4..e681810 100644
--- a/apps/api/src/core/upload/upload.gateway.ts
+++ b/apps/api/src/core/upload/upload.gateway.ts
@@ -1,223 +1,223 @@
-// apps/api/src/core/upload/upload.gateway.ts
-import {
-  WebSocketGateway,
-  WebSocketServer,
-  OnGatewayConnection,
-  OnGatewayDisconnect,
-  SubscribeMessage,
-  MessageBody,
-  ConnectedSocket,
-  WsException,
-} from '@nestjs/websockets';
-import { Server, Socket } from 'socket.io';
-import { Logger, UnauthorizedException } from '@nestjs/common';
-
-// =======================
-// Event names (constants)
-// =======================
-export const EV_JOIN = 'join';
-export const EV_JOINED = 'joined';
-export const EV_LEAVE = 'leave';
-export const EV_LEFT = 'left';
-export const EV_SERVER_PROGRESS = 'serverUploadProgress';
-export const EV_UPLOADED = 'uploaded';
-export const EV_ERROR = 'uploadError';
-export const EV_PING = 'ping';
-export const EV_PONG = 'pong';
-
-// =======================
-// DTOs / helpers
-// =======================
-type ServerProgressEvent = {
-  uploadId: string;
-  sent: number; // bytes sent so far
-  total: number; // total file size in bytes
-  percent: number; // 0..100
-};
-
-type UploadedEvent = {
-  uploadId: string;
-  url: string;
-  path: string;
-};
-
-type ErrorEvent = {
-  uploadId?: string;
-  code: string; // e.g. 'INVALID_ID' | 'UNAUTHORIZED' | 'INTERNAL'
-  message?: string; // human-friendly (avoid leaking internals in prod)
-};
-
-// Parse and normalize allowed CORS origins (comma-separated)
-function parseCorsOrigins(input?: string): string[] {
-  if (!input) return ['http://localhost:3000'];
-  return input
-    .split(',')
-    .map((s) => s.trim())
-    .filter(Boolean);
-}
-
-// Optional lightweight validation (UUID-ish or short id)
-function isValidUploadId(id: unknown): id is string {
-  if (typeof id !== 'string') return false;
-  if (id.length < 8 || id.length > 128) return false;
-  // Stricter sample (UUID v4):
-  // return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);
-  return true;
-}
-
-function safePercent(sent: number, total: number): number {
-  if (total <= 0) return 0;
-  const p = (sent / total) * 100;
-  // clamp + 1 decimal
-  return Math.max(0, Math.min(100, Math.round(p * 10) / 10));
-}
-
-// =======================
-// (Optional) auth hook
-// =======================
-// اگر WebSocket سشن باید به کاربر متصل باشد، این تابع را به سرویس JWT وصل کن
-async function authenticateSocket(
-  client: Socket,
-): Promise<{ userId?: string } | null> {
-  // نمونه: از هدر/کوکی توکن را بخوان
-  // const token = client.handshake.auth?.token || client.handshake.headers['authorization'];
-  // verify...
-  return { userId: undefined }; // فعلاً اختیاری
-}
-
-@WebSocketGateway({
-  namespace: '/upload',
-  cors: {
-    origin: parseCorsOrigins(process.env.CORS_ORIGIN),
-    credentials: true,
-  },
-})
-export class UploadGateway implements OnGatewayConnection, OnGatewayDisconnect {
-  @WebSocketServer() server!: Server;
-  private readonly logger = new Logger(UploadGateway.name);
-
-  // محدودیت سبک برای flood (در هر سوکت، حداقل فاصله بین joinها)
-  private readonly joinCooldownMs = 200;
-
-  async handleConnection(client: Socket) {
-    try {
-      const auth = await authenticateSocket(client);
-      client.data.userId = auth?.userId;
-      client.data.lastJoinAt = 0;
-      this.logger.debug(`client connected: ${client.id}`);
-      // پاسخ به پینگ‌های کلاینت
-      client.on(EV_PING, () => client.emit(EV_PONG, { t: Date.now() }));
-    } catch (e) {
-      this.logger.warn(`auth failed for ${client.id}: ${(e as Error).message}`);
-      client.emit(EV_ERROR, <ErrorEvent>{ code: 'UNAUTHORIZED' });
-      client.disconnect(true);
-    }
-  }
-
-  handleDisconnect(client: Socket) {
-    this.logger.debug(`client disconnected: ${client.id}`);
-    // socket.io rooms cleaned automatically
-  }
-
-  /**
-   * client -> server: join a room by uploadId
-   * payload: { uploadId: string }
-   */
-  @SubscribeMessage(EV_JOIN)
-  handleJoin(
-    @MessageBody() body: { uploadId?: string },
-    @ConnectedSocket() client: Socket,
-  ) {
-    const id = body?.uploadId;
-    if (!isValidUploadId(id)) {
-      throw new WsException('Invalid uploadId');
-    }
-
-    // flood control
-    const now = Date.now();
-    if (typeof client.data.lastJoinAt === 'number') {
-      if (now - client.data.lastJoinAt < this.joinCooldownMs) {
-        // ignore rapid joins
-        return;
-      }
-    }
-    client.data.lastJoinAt = now;
-
-    const room = this.room(id);
-    client.join(room);
-    client.data.uploadId = id;
-    client.emit(EV_JOINED, { uploadId: id });
-    this.logger.debug(`client ${client.id} joined ${room}`);
-  }
-
-  /**
-   * client -> server: leave a room by uploadId
-   * payload: { uploadId?: string }
-   */
-  @SubscribeMessage(EV_LEAVE)
-  handleLeave(
-    @MessageBody() body: { uploadId?: string },
-    @ConnectedSocket() client: Socket,
-  ) {
-    const id = body?.uploadId ?? client.data.uploadId;
-    if (!isValidUploadId(id)) {
-      throw new WsException('Invalid uploadId');
-    }
-    const room = this.room(id);
-    client.leave(room);
-    client.emit(EV_LEFT, { uploadId: id });
-    this.logger.debug(`client ${client.id} left ${room}`);
-  }
-
-  // =======================
-  // Server-side emit helpers
-  // =======================
-  /** Emit server->storage progress to all listeners of this uploadId. */
-  emitServerProgress(ev: ServerProgressEvent) {
-    try {
-      if (!this.server) return;
-      if (!isValidUploadId(ev.uploadId)) return;
-
-      const percent = safePercent(ev.sent, ev.total);
-      const payload: ServerProgressEvent = { ...ev, percent };
-
-      this.server.to(this.room(ev.uploadId)).emit(EV_SERVER_PROGRESS, payload);
-    } catch (e) {
-      this.logger.warn(`emitServerProgress failed: ${(e as Error).message}`);
-    }
-  }
-
-  /** Emit final uploaded event with the resolved URL/path. */
-  emitUploaded(ev: UploadedEvent) {
-    try {
-      if (!this.server) return;
-      if (!isValidUploadId(ev.uploadId)) return;
-
-      this.server.to(this.room(ev.uploadId)).emit(EV_UPLOADED, ev);
-    } catch (e) {
-      this.logger.warn(`emitUploaded failed: ${(e as Error).message}`);
-    }
-  }
-
-  /** Emit error event (standardized) */
-  emitError(ev: ErrorEvent) {
-    try {
-      if (!this.server) return;
-      if (ev.uploadId && !isValidUploadId(ev.uploadId)) return;
-
-      const target = ev.uploadId
-        ? this.server.to(this.room(ev.uploadId))
-        : this.server;
-      target.emit(EV_ERROR, ev);
-    } catch (e) {
-      this.logger.warn(`emitError failed: ${(e as Error).message}`);
-    }
-  }
-
-  // =======================
-  // Internals
-  // =======================
-  private room(uploadId: string) {
-    return `upload:${uploadId}`;
-  }
-}
+// apps/api/src/core/upload/upload.gateway.ts
+import {
+  WebSocketGateway,
+  WebSocketServer,
+  OnGatewayConnection,
+  OnGatewayDisconnect,
+  SubscribeMessage,
+  MessageBody,
+  ConnectedSocket,
+  WsException,
+} from '@nestjs/websockets';
+import { Server, Socket } from 'socket.io';
+import { Logger, UnauthorizedException } from '@nestjs/common';
+
+// =======================
+// Event names (constants)
+// =======================
+export const EV_JOIN = 'join';
+export const EV_JOINED = 'joined';
+export const EV_LEAVE = 'leave';
+export const EV_LEFT = 'left';
+export const EV_SERVER_PROGRESS = 'serverUploadProgress';
+export const EV_UPLOADED = 'uploaded';
+export const EV_ERROR = 'uploadError';
+export const EV_PING = 'ping';
+export const EV_PONG = 'pong';
+
+// =======================
+// DTOs / helpers
+// =======================
+type ServerProgressEvent = {
+  uploadId: string;
+  sent: number; // bytes sent so far
+  total: number; // total file size in bytes
+  percent: number; // 0..100
+};
+
+type UploadedEvent = {
+  uploadId: string;
+  url: string;
+  path: string;
+};
+
+type ErrorEvent = {
+  uploadId?: string;
+  code: string; // e.g. 'INVALID_ID' | 'UNAUTHORIZED' | 'INTERNAL'
+  message?: string; // human-friendly (avoid leaking internals in prod)
+};
+
+// Parse and normalize allowed CORS origins (comma-separated)
+function parseCorsOrigins(input?: string): string[] {
+  if (!input) return ['http://localhost:3000'];
+  return input
+    .split(',')
+    .map((s) => s.trim())
+    .filter(Boolean);
+}
+
+// Optional lightweight validation (UUID-ish or short id)
+function isValidUploadId(id: unknown): id is string {
+  if (typeof id !== 'string') return false;
+  if (id.length < 8 || id.length > 128) return false;
+  // Stricter sample (UUID v4):
+  // return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);
+  return true;
+}
+
+function safePercent(sent: number, total: number): number {
+  if (total <= 0) return 0;
+  const p = (sent / total) * 100;
+  // clamp + 1 decimal
+  return Math.max(0, Math.min(100, Math.round(p * 10) / 10));
+}
+
+// =======================
+// (Optional) auth hook
+// =======================
+// اگر WebSocket سشن باید به کاربر متصل باشد، این تابع را به سرویس JWT وصل کن
+async function authenticateSocket(
+  client: Socket,
+): Promise<{ userId?: string } | null> {
+  // نمونه: از هدر/کوکی توکن را بخوان
+  // const token = client.handshake.auth?.token || client.handshake.headers['authorization'];
+  // verify...
+  return { userId: undefined }; // فعلاً اختیاری
+}
+
+@WebSocketGateway({
+  namespace: '/upload',
+  cors: {
+    origin: parseCorsOrigins(process.env.CORS_ORIGIN),
+    credentials: true,
+  },
+})
+export class UploadGateway implements OnGatewayConnection, OnGatewayDisconnect {
+  @WebSocketServer() server!: Server;
+  private readonly logger = new Logger(UploadGateway.name);
+
+  // محدودیت سبک برای flood (در هر سوکت، حداقل فاصله بین joinها)
+  private readonly joinCooldownMs = 200;
+
+  async handleConnection(client: Socket) {
+    try {
+      const auth = await authenticateSocket(client);
+      client.data.userId = auth?.userId;
+      client.data.lastJoinAt = 0;
+      this.logger.debug(`client connected: ${client.id}`);
+      // پاسخ به پینگ‌های کلاینت
+      client.on(EV_PING, () => client.emit(EV_PONG, { t: Date.now() }));
+    } catch (e) {
+      this.logger.warn(`auth failed for ${client.id}: ${(e as Error).message}`);
+      client.emit(EV_ERROR, <ErrorEvent>{ code: 'UNAUTHORIZED' });
+      client.disconnect(true);
+    }
+  }
+
+  handleDisconnect(client: Socket) {
+    this.logger.debug(`client disconnected: ${client.id}`);
+    // socket.io rooms cleaned automatically
+  }
+
+  /**
+   * client -> server: join a room by uploadId
+   * payload: { uploadId: string }
+   */
+  @SubscribeMessage(EV_JOIN)
+  handleJoin(
+    @MessageBody() body: { uploadId?: string },
+    @ConnectedSocket() client: Socket,
+  ) {
+    const id = body?.uploadId;
+    if (!isValidUploadId(id)) {
+      throw new WsException('Invalid uploadId');
+    }
+
+    // flood control
+    const now = Date.now();
+    if (typeof client.data.lastJoinAt === 'number') {
+      if (now - client.data.lastJoinAt < this.joinCooldownMs) {
+        // ignore rapid joins
+        return;
+      }
+    }
+    client.data.lastJoinAt = now;
+
+    const room = this.room(id);
+    client.join(room);
+    client.data.uploadId = id;
+    client.emit(EV_JOINED, { uploadId: id });
+    this.logger.debug(`client ${client.id} joined ${room}`);
+  }
+
+  /**
+   * client -> server: leave a room by uploadId
+   * payload: { uploadId?: string }
+   */
+  @SubscribeMessage(EV_LEAVE)
+  handleLeave(
+    @MessageBody() body: { uploadId?: string },
+    @ConnectedSocket() client: Socket,
+  ) {
+    const id = body?.uploadId ?? client.data.uploadId;
+    if (!isValidUploadId(id)) {
+      throw new WsException('Invalid uploadId');
+    }
+    const room = this.room(id);
+    client.leave(room);
+    client.emit(EV_LEFT, { uploadId: id });
+    this.logger.debug(`client ${client.id} left ${room}`);
+  }
+
+  // =======================
+  // Server-side emit helpers
+  // =======================
+  /** Emit server->storage progress to all listeners of this uploadId. */
+  emitServerProgress(ev: ServerProgressEvent) {
+    try {
+      if (!this.server) return;
+      if (!isValidUploadId(ev.uploadId)) return;
+
+      const percent = safePercent(ev.sent, ev.total);
+      const payload: ServerProgressEvent = { ...ev, percent };
+
+      this.server.to(this.room(ev.uploadId)).emit(EV_SERVER_PROGRESS, payload);
+    } catch (e) {
+      this.logger.warn(`emitServerProgress failed: ${(e as Error).message}`);
+    }
+  }
+
+  /** Emit final uploaded event with the resolved URL/path. */
+  emitUploaded(ev: UploadedEvent) {
+    try {
+      if (!this.server) return;
+      if (!isValidUploadId(ev.uploadId)) return;
+
+      this.server.to(this.room(ev.uploadId)).emit(EV_UPLOADED, ev);
+    } catch (e) {
+      this.logger.warn(`emitUploaded failed: ${(e as Error).message}`);
+    }
+  }
+
+  /** Emit error event (standardized) */
+  emitError(ev: ErrorEvent) {
+    try {
+      if (!this.server) return;
+      if (ev.uploadId && !isValidUploadId(ev.uploadId)) return;
+
+      const target = ev.uploadId
+        ? this.server.to(this.room(ev.uploadId))
+        : this.server;
+      target.emit(EV_ERROR, ev);
+    } catch (e) {
+      this.logger.warn(`emitError failed: ${(e as Error).message}`);
+    }
+  }
+
+  // =======================
+  // Internals
+  // =======================
+  private room(uploadId: string) {
+    return `upload:${uploadId}`;
+  }
+}
diff --git a/apps/api/src/core/upload/upload.module.ts b/apps/api/src/core/upload/upload.module.ts
index fa1231b..0937648 100644
--- a/apps/api/src/core/upload/upload.module.ts
+++ b/apps/api/src/core/upload/upload.module.ts
@@ -5,21 +5,21 @@ import {
   OnApplicationShutdown,
   Injectable,
 } from '@nestjs/common';
-import { UploadService } from './upload.service';
+import { UploadService } from '@app/core/upload/upload.service';
 import {
   UPLOAD_CONFIG,
   UPLOAD_STATE_STORE,
   STORAGE_DRIVER,
   type UploadConfig,
-} from './upload.tokens';
-import { RedisUploadStateStore } from './upload.state.redis';
+} from '@app/core/upload/upload.tokens';
+import { RedisUploadStateStore } from '@app/core/upload/upload.state.redis';
 import type Redis from 'ioredis';
 import IORedis from 'ioredis';
-import { UploadController } from './upload.controller';
-import { FTPStorageDriver } from './storage.ftp';
-import { UploadGateway } from './upload.gateway';
-import { UploadCleanup } from './upload.cleanup';
-import { MediaModule } from '../media/media.module';
+import { UploadController } from '@app/core/upload/upload.controller';
+import { FTPStorageDriver } from '@app/core/upload/storage.ftp';
+import { UploadGateway } from '@app/core/upload/upload.gateway';
+import { UploadCleanup } from '@app/core/upload/upload.cleanup';
+import { MediaModule } from '@app/core/media/media.module';
 
 /* -------------------------------------------------------------------------- */
 /*                              Helper functions                              */
diff --git a/apps/api/src/core/upload/upload.service.spec.ts b/apps/api/src/core/upload/upload.service.spec.ts
index 44ce758..ccc18b8 100644
--- a/apps/api/src/core/upload/upload.service.spec.ts
+++ b/apps/api/src/core/upload/upload.service.spec.ts
@@ -11,10 +11,10 @@ import {
   UnprocessableEntityException,
 } from '@nestjs/common';
 import type { FileTypeResult } from 'file-type';
-import { UploadService } from './upload.service';
-import type { UploadConfig } from './upload.tokens';
+import { UploadService } from '@app/core/upload/upload.service';
+import type { UploadConfig } from '@app/core/upload/upload.tokens';
 import { InMemoryUploadStateStore, FakeStorageDriver, MockMediaService } from '@test/utils/upload-fakes';
-import type { UploadGateway } from './upload.gateway';
+import type { UploadGateway } from '@app/core/upload/upload.gateway';
 
 jest.mock('file-type', () => ({
   fileTypeFromBuffer: jest.fn(),
diff --git a/apps/api/src/core/upload/upload.service.ts b/apps/api/src/core/upload/upload.service.ts
index 221bf07..472b231 100644
--- a/apps/api/src/core/upload/upload.service.ts
+++ b/apps/api/src/core/upload/upload.service.ts
@@ -27,14 +27,14 @@ import {
   type MimeType,
   type UploadId,
   type UserId,
-} from './upload.types';
+} from '@app/core/upload/upload.types';
 import {
   UPLOAD_CONFIG,
   UPLOAD_STATE_STORE,
   STORAGE_DRIVER,
   type UploadConfig,
-} from './upload.tokens';
-import { UploadGateway } from './upload.gateway';
+} from '@app/core/upload/upload.tokens';
+import { UploadGateway } from '@app/core/upload/upload.gateway';
 import { MediaService } from '@app/core/media/media.service';
 
 /** ---------- Branded-cast helpers ---------- */
diff --git a/apps/api/src/core/upload/upload.state.redis.ts b/apps/api/src/core/upload/upload.state.redis.ts
index aa1ecc5..a04c064 100644
--- a/apps/api/src/core/upload/upload.state.redis.ts
+++ b/apps/api/src/core/upload/upload.state.redis.ts
@@ -1,6 +1,6 @@
 // apps/api/src/core/upload/redis-upload-state.store.ts
 import type Redis from 'ioredis';
-import { type UploadStatus, type UploadStateStore } from './upload.types';
+import { type UploadStatus, type UploadStateStore } from '@app/core/upload/upload.types';
 
 // Small helpers
 const PREFIX = 'upload:';
diff --git a/apps/api/src/core/upload/upload.tokens.ts b/apps/api/src/core/upload/upload.tokens.ts
index 81b87be..68c2865 100644
--- a/apps/api/src/core/upload/upload.tokens.ts
+++ b/apps/api/src/core/upload/upload.tokens.ts
@@ -1,117 +1,117 @@
-// ==============================
-// Injection tokens
-// ==============================
-export const UPLOAD_STATE_STORE = Symbol('UPLOAD_STATE_STORE');
-export const STORAGE_DRIVER = Symbol('STORAGE_DRIVER');
-export const UPLOAD_CONFIG = Symbol('UPLOAD_CONFIG');
-
-// ==============================
-// Config Types (hardened)
-// ==============================
-
-export type StorageBackendKind = 'ftp' | 's3' | 'local';
-
-export interface BaseUploadConfig {
-  /** Temporary directory for partial files (server-only) */
-  tmpDir: string; // e.g. /tmp/negare-uploads
-
-  /** Required chunk size in bytes; prefer multiples of 1 MiB (e.g. 5 * 1024 * 1024) */
-  chunkSize: number;
-
-  /** TTL for an upload session in seconds (e.g. 3600) */
-  ttlSeconds: number;
-
-  /** Max allowed file size in bytes (hard limit) */
-  maxSizeBytes: number;
-
-  /** Public base URL for final assets (no trailing slash) */
-  cdnBaseUrl: string; // e.g. https://cdn.negare.com
-
-  /**
-   * Root "public" prefix on the remote (normalized, no leading slash for object stores)
-   * e.g. "public_html" for FTP, or "assets" for S3
-   */
-  publicRoot: string;
-
-  /**
-   * Optional prefix directly under the public root (e.g. "cdn")
-   * Added to generated remote paths and URLs when provided.
-   */
-  publicSubdir?: string;
-
-  /**
-   * Logical base directory under the (sub)docroot where uploads live.
-   * Defaults to "uploads".
-   */
-  baseDir?: string;
-
-  /** Allowed file extensions (lowercase, WITHOUT dot) */
-  allowedExts?: string[];
-
-  /** Allowed MIME types (lowercase) */
-  allowedMime?: string[];
-
-  /** Optional: sanitize/normalize policy for filenames (server applies) */
-  filenamePolicy?: {
-    /** Max base name length (without extension), default 100 */
-    maxNameLength?: number;
-    /** Replace invalid chars with this (default "-") */
-    replaceWith?: string;
-    /** Regex of allowed chars (apply to base name), default: /^[a-zA-Z0-9._-]+$/ */
-    allowedNameRegex?: string;
-  };
-
-  /** Optional: retry/backoff settings for remote storage */
-  retry?: {
-    retries: number; // e.g. 3
-    minDelayMs: number; // e.g. 250
-    maxDelayMs: number; // e.g. 2000
-    jitter?: boolean; // default true
-  };
-
-  /** Optional: upload parallelism & throttling */
-  performance?: {
-    maxConcurrentUploads?: number; // per process
-    progressThrottleMs?: number; // min interval for progress callbacks
-  };
-
-  /** Keep temp file on remote upload failure for manual inspection */
-  keepTempOnError?: boolean;
-
-  /** Which backend driver to use */
-  backend: StorageBackendKind;
-}
-
-/** FTP-specific config */
-export interface FtpConfig {
-  host: string;
-  port?: number; // default 21
-  secure?: boolean; // FTPS
-  user: string;
-  password: string;
-  /** Passive mode toggle / timeouts, etc. */
-  passive?: boolean;
-  timeoutMs?: number; // e.g. 15000
-}
-
-/** S3-compatible config (AWS/MinIO) */
-export interface S3Config {
-  bucket: string;
-  region?: string;
-  endpoint?: string; // for MinIO
-  accessKeyId: string;
-  secretAccessKey: string;
-  forcePathStyle?: boolean; // MinIO: true
-}
-
-/** Local FS config (for dev) */
-export interface LocalConfig {
-  rootDir: string; // absolute dir to store public files
-}
-
-/** Unified UploadConfig */
-export interface UploadConfig extends BaseUploadConfig {
-  ftp?: FtpConfig; // required if backend === 'ftp'
-  s3?: S3Config; // required if backend === 's3'
-  local?: LocalConfig; // required if backend === 'local'
-}
+// ==============================
+// Injection tokens
+// ==============================
+export const UPLOAD_STATE_STORE = Symbol('UPLOAD_STATE_STORE');
+export const STORAGE_DRIVER = Symbol('STORAGE_DRIVER');
+export const UPLOAD_CONFIG = Symbol('UPLOAD_CONFIG');
+
+// ==============================
+// Config Types (hardened)
+// ==============================
+
+export type StorageBackendKind = 'ftp' | 's3' | 'local';
+
+export interface BaseUploadConfig {
+  /** Temporary directory for partial files (server-only) */
+  tmpDir: string; // e.g. /tmp/negare-uploads
+
+  /** Required chunk size in bytes; prefer multiples of 1 MiB (e.g. 5 * 1024 * 1024) */
+  chunkSize: number;
+
+  /** TTL for an upload session in seconds (e.g. 3600) */
+  ttlSeconds: number;
+
+  /** Max allowed file size in bytes (hard limit) */
+  maxSizeBytes: number;
+
+  /** Public base URL for final assets (no trailing slash) */
+  cdnBaseUrl: string; // e.g. https://cdn.negare.com
+
+  /**
+   * Root "public" prefix on the remote (normalized, no leading slash for object stores)
+   * e.g. "public_html" for FTP, or "assets" for S3
+   */
+  publicRoot: string;
+
+  /**
+   * Optional prefix directly under the public root (e.g. "cdn")
+   * Added to generated remote paths and URLs when provided.
+   */
+  publicSubdir?: string;
+
+  /**
+   * Logical base directory under the (sub)docroot where uploads live.
+   * Defaults to "uploads".
+   */
+  baseDir?: string;
+
+  /** Allowed file extensions (lowercase, WITHOUT dot) */
+  allowedExts?: string[];
+
+  /** Allowed MIME types (lowercase) */
+  allowedMime?: string[];
+
+  /** Optional: sanitize/normalize policy for filenames (server applies) */
+  filenamePolicy?: {
+    /** Max base name length (without extension), default 100 */
+    maxNameLength?: number;
+    /** Replace invalid chars with this (default "-") */
+    replaceWith?: string;
+    /** Regex of allowed chars (apply to base name), default: /^[a-zA-Z0-9._-]+$/ */
+    allowedNameRegex?: string;
+  };
+
+  /** Optional: retry/backoff settings for remote storage */
+  retry?: {
+    retries: number; // e.g. 3
+    minDelayMs: number; // e.g. 250
+    maxDelayMs: number; // e.g. 2000
+    jitter?: boolean; // default true
+  };
+
+  /** Optional: upload parallelism & throttling */
+  performance?: {
+    maxConcurrentUploads?: number; // per process
+    progressThrottleMs?: number; // min interval for progress callbacks
+  };
+
+  /** Keep temp file on remote upload failure for manual inspection */
+  keepTempOnError?: boolean;
+
+  /** Which backend driver to use */
+  backend: StorageBackendKind;
+}
+
+/** FTP-specific config */
+export interface FtpConfig {
+  host: string;
+  port?: number; // default 21
+  secure?: boolean; // FTPS
+  user: string;
+  password: string;
+  /** Passive mode toggle / timeouts, etc. */
+  passive?: boolean;
+  timeoutMs?: number; // e.g. 15000
+}
+
+/** S3-compatible config (AWS/MinIO) */
+export interface S3Config {
+  bucket: string;
+  region?: string;
+  endpoint?: string; // for MinIO
+  accessKeyId: string;
+  secretAccessKey: string;
+  forcePathStyle?: boolean; // MinIO: true
+}
+
+/** Local FS config (for dev) */
+export interface LocalConfig {
+  rootDir: string; // absolute dir to store public files
+}
+
+/** Unified UploadConfig */
+export interface UploadConfig extends BaseUploadConfig {
+  ftp?: FtpConfig; // required if backend === 'ftp'
+  s3?: S3Config; // required if backend === 's3'
+  local?: LocalConfig; // required if backend === 'local'
+}
diff --git a/apps/api/src/core/upload/upload.types.ts b/apps/api/src/core/upload/upload.types.ts
index 6cbc671..33f6ddd 100644
--- a/apps/api/src/core/upload/upload.types.ts
+++ b/apps/api/src/core/upload/upload.types.ts
@@ -1,190 +1,190 @@
-// ==============================
-// Upload Types (hardened edition)
-// ==============================
-
-/** Utility: brand primitive types to avoid accidental mixups */
-type Brand<T, B extends string> = T & { readonly __brand: B };
-
-export type UploadId = Brand<string, 'UploadId'>;
-export type UserId = Brand<string, 'UserId'>;
-export type MimeType = Brand<string, 'MimeType'>;
-
-/** Allowed states (keep original values for compatibility) */
-export type UploadState =
-  | 'init'
-  | 'receiving'
-  | 'ready-to-upload'
-  | 'uploading'
-  | 'uploaded'
-  | 'error';
-
-/** Client → Server: initialize an upload session */
-export interface UploadInitInput {
-  filename: string; // original filename from client
-  size: number; // total bytes expected
-  mime?: string | null; // optional client-declared MIME (hint only; server decides)
-}
-
-/** Server → Client: created session info (public-safe) */
-export interface UploadInitOutput {
-  readonly uploadId: UploadId; // unique session id
-  readonly chunkSize: number; // required chunk size in bytes
-  readonly totalChunks: number; // ceil(size / chunkSize)
-  readonly expiresAt: number; // epoch ms (session TTL)
-}
-
-/** Persisted status (e.g., Redis). INTERNAL object - never expose as-is to client */
-export interface UploadStatus {
-  // Identity / ownership
-  uploadId: UploadId;
-  userId: UserId;
-
-  // File meta
-  filename: string; // original filename
-  mime: MimeType; // MIME enforced/accepted by server
-  size: number; // total bytes expected
-  chunkSize: number; // per-session chunk size
-  totalChunks: number; // normalized at init
-
-  // Progress
-  /** Informational only; can be derived from receivedIndexes*chunkSize with care */
-  receivedBytes: number;
-  /** Sorted, unique chunk indexes received so far (0..totalChunks-1) */
-  receivedIndexes: number[];
-
-  // Lifecycle / auditing
-  state: UploadState;
-  createdAt: number; // epoch ms
-  expiresAt: number; // epoch ms
-  version: number; // CAS/version for optimistic concurrency
-  errorCode?: string; // set when state === 'error'
-
-  // Paths (SERVER-ONLY; do not expose)
-  /** Local temp file path - INTERNAL ONLY (never return to client/logs) */
-  tempPath: string;
-  /** Destination path relative to storage root (server derives & normalizes) */
-  remoteRelativePath?: string;
-
-  // Integrity (optional but recommended)
-  /** Expected SHA-256 of the final file (hex/base64). If present, verify at finish. */
-  sha256?: string;
-}
-
-/** Server → Client: response after accepting a chunk */
-export interface UploadChunkResult {
-  readonly receivedIndex: number; // index just accepted
-  readonly receivedBytes: number; // cumulative bytes (informational)
-  readonly percent: number; // 0..100 (based on bytes)
-}
-
-/** Server → Client: response after finalizing an upload */
-export interface UploadFinishResult {
-  readonly url: string; // public URL (CDN_BASE_URL + relative path)
-  readonly path: string; // storage relative path
-  readonly mime: MimeType;
-  readonly size: number;
-  readonly sha256?: string; // final checksum if computed
-}
-
-/** Progress callback payload from the storage driver */
-export interface StorageUploadProgress {
-  sentBytes: number; // bytes sent so far
-  totalBytes: number; // total bytes to send
-  percent: number; // 0..100
-}
-
-/**
- * Upload state store (e.g., Redis) abstraction.
- * MUST provide atomicity/locking to avoid races for parallel chunk writes.
- */
-export interface UploadStateStore {
-  /** Create new status with optional TTL (seconds). Must fail if key exists. */
-  create(status: UploadStatus, ttlSec?: number): Promise<void>;
-
-  /** Read current status; returns null if not found/expired. */
-  get(uploadId: UploadId): Promise<UploadStatus | null>;
-
-  /**
-   * Patch using optimistic concurrency control.
-   * Apply `patch` only if current `version` equals `expectedVersion`; then increment version.
-   */
-  patchCAS(
-    uploadId: UploadId,
-    expectedVersion: number,
-    patch: Partial<UploadStatus>,
-  ): Promise<boolean>;
-
-  /**
-   * Execute `work` within a distributed lock (e.g., Redlock).
-   * Should time out if lock not acquired within ttlMs.
-   */
-  withLock<T>(
-    uploadId: UploadId,
-    ttlMs: number,
-    work: () => Promise<T>,
-  ): Promise<T>;
-
-  /** Refresh TTL (seconds) without modifying the payload */
-  touch(uploadId: UploadId, ttlSec: number): Promise<void>;
-
-  /** Hard delete (e.g., after finish/abort/timeout cleanup) */
-  delete(uploadId: UploadId): Promise<void>;
-}
-
-/**
- * Destination storage driver abstraction (FTP now, S3/MinIO later).
- * Methods marked optional are implemented only when meaningful for the backend.
- */
-export interface StorageDriver {
-  /** No-op for object stores; relevant for hierarchical backends like FTP */
-  ensureDir?(relativeDir: string): Promise<void>;
-
-  /**
-   * Upload from a local file path to `remoteRelativePath`.
-   * For object stores that lack true rename, prefer "copy+delete" semantics in `rename`.
-   */
-  uploadFile(
-    localPath: string,
-    remoteRelativePath: string,
-    onProgress?: (p: StorageUploadProgress) => void,
-  ): Promise<void>;
-
-  /** Streamed upload for very large files (optional for FTP backends) */
-  uploadStream?(
-    readable: NodeJS.ReadableStream,
-    remoteRelativePath: string,
-    totalBytes?: number,
-    onProgress?: (p: StorageUploadProgress) => void,
-  ): Promise<void>;
-
-  /** Check object existence */
-  exists(remoteRelativePath: string): Promise<boolean>;
-
-  /**
-   * Rename/move object. If backend lacks native rename, implement as copy+delete.
-   * Should be atomic from the perspective of callers (or fail with rollback).
-   */
-  rename(oldRelativePath: string, newRelativePath: string): Promise<void>;
-
-  /** Delete remote object (for rollback/cleanup) */
-  delete(remoteRelativePath: string): Promise<void>;
-}
-
-/**
- * Public-safe projections (optional helpers)
- * Use these when returning status-like summaries to clients to avoid leaking INTERNAL fields.
- */
-export type PublicUploadStatus = Pick<
-  UploadStatus,
-  | 'uploadId'
-  | 'filename'
-  | 'mime'
-  | 'size'
-  | 'chunkSize'
-  | 'totalChunks'
-  | 'receivedBytes'
-  | 'receivedIndexes'
-  | 'state'
-  | 'createdAt'
-  | 'expiresAt'
-> & { readonly percent?: number }; // computed on-the-fly; not persisted
+// ==============================
+// Upload Types (hardened edition)
+// ==============================
+
+/** Utility: brand primitive types to avoid accidental mixups */
+type Brand<T, B extends string> = T & { readonly __brand: B };
+
+export type UploadId = Brand<string, 'UploadId'>;
+export type UserId = Brand<string, 'UserId'>;
+export type MimeType = Brand<string, 'MimeType'>;
+
+/** Allowed states (keep original values for compatibility) */
+export type UploadState =
+  | 'init'
+  | 'receiving'
+  | 'ready-to-upload'
+  | 'uploading'
+  | 'uploaded'
+  | 'error';
+
+/** Client → Server: initialize an upload session */
+export interface UploadInitInput {
+  filename: string; // original filename from client
+  size: number; // total bytes expected
+  mime?: string | null; // optional client-declared MIME (hint only; server decides)
+}
+
+/** Server → Client: created session info (public-safe) */
+export interface UploadInitOutput {
+  readonly uploadId: UploadId; // unique session id
+  readonly chunkSize: number; // required chunk size in bytes
+  readonly totalChunks: number; // ceil(size / chunkSize)
+  readonly expiresAt: number; // epoch ms (session TTL)
+}
+
+/** Persisted status (e.g., Redis). INTERNAL object - never expose as-is to client */
+export interface UploadStatus {
+  // Identity / ownership
+  uploadId: UploadId;
+  userId: UserId;
+
+  // File meta
+  filename: string; // original filename
+  mime: MimeType; // MIME enforced/accepted by server
+  size: number; // total bytes expected
+  chunkSize: number; // per-session chunk size
+  totalChunks: number; // normalized at init
+
+  // Progress
+  /** Informational only; can be derived from receivedIndexes*chunkSize with care */
+  receivedBytes: number;
+  /** Sorted, unique chunk indexes received so far (0..totalChunks-1) */
+  receivedIndexes: number[];
+
+  // Lifecycle / auditing
+  state: UploadState;
+  createdAt: number; // epoch ms
+  expiresAt: number; // epoch ms
+  version: number; // CAS/version for optimistic concurrency
+  errorCode?: string; // set when state === 'error'
+
+  // Paths (SERVER-ONLY; do not expose)
+  /** Local temp file path - INTERNAL ONLY (never return to client/logs) */
+  tempPath: string;
+  /** Destination path relative to storage root (server derives & normalizes) */
+  remoteRelativePath?: string;
+
+  // Integrity (optional but recommended)
+  /** Expected SHA-256 of the final file (hex/base64). If present, verify at finish. */
+  sha256?: string;
+}
+
+/** Server → Client: response after accepting a chunk */
+export interface UploadChunkResult {
+  readonly receivedIndex: number; // index just accepted
+  readonly receivedBytes: number; // cumulative bytes (informational)
+  readonly percent: number; // 0..100 (based on bytes)
+}
+
+/** Server → Client: response after finalizing an upload */
+export interface UploadFinishResult {
+  readonly url: string; // public URL (CDN_BASE_URL + relative path)
+  readonly path: string; // storage relative path
+  readonly mime: MimeType;
+  readonly size: number;
+  readonly sha256?: string; // final checksum if computed
+}
+
+/** Progress callback payload from the storage driver */
+export interface StorageUploadProgress {
+  sentBytes: number; // bytes sent so far
+  totalBytes: number; // total bytes to send
+  percent: number; // 0..100
+}
+
+/**
+ * Upload state store (e.g., Redis) abstraction.
+ * MUST provide atomicity/locking to avoid races for parallel chunk writes.
+ */
+export interface UploadStateStore {
+  /** Create new status with optional TTL (seconds). Must fail if key exists. */
+  create(status: UploadStatus, ttlSec?: number): Promise<void>;
+
+  /** Read current status; returns null if not found/expired. */
+  get(uploadId: UploadId): Promise<UploadStatus | null>;
+
+  /**
+   * Patch using optimistic concurrency control.
+   * Apply `patch` only if current `version` equals `expectedVersion`; then increment version.
+   */
+  patchCAS(
+    uploadId: UploadId,
+    expectedVersion: number,
+    patch: Partial<UploadStatus>,
+  ): Promise<boolean>;
+
+  /**
+   * Execute `work` within a distributed lock (e.g., Redlock).
+   * Should time out if lock not acquired within ttlMs.
+   */
+  withLock<T>(
+    uploadId: UploadId,
+    ttlMs: number,
+    work: () => Promise<T>,
+  ): Promise<T>;
+
+  /** Refresh TTL (seconds) without modifying the payload */
+  touch(uploadId: UploadId, ttlSec: number): Promise<void>;
+
+  /** Hard delete (e.g., after finish/abort/timeout cleanup) */
+  delete(uploadId: UploadId): Promise<void>;
+}
+
+/**
+ * Destination storage driver abstraction (FTP now, S3/MinIO later).
+ * Methods marked optional are implemented only when meaningful for the backend.
+ */
+export interface StorageDriver {
+  /** No-op for object stores; relevant for hierarchical backends like FTP */
+  ensureDir?(relativeDir: string): Promise<void>;
+
+  /**
+   * Upload from a local file path to `remoteRelativePath`.
+   * For object stores that lack true rename, prefer "copy+delete" semantics in `rename`.
+   */
+  uploadFile(
+    localPath: string,
+    remoteRelativePath: string,
+    onProgress?: (p: StorageUploadProgress) => void,
+  ): Promise<void>;
+
+  /** Streamed upload for very large files (optional for FTP backends) */
+  uploadStream?(
+    readable: NodeJS.ReadableStream,
+    remoteRelativePath: string,
+    totalBytes?: number,
+    onProgress?: (p: StorageUploadProgress) => void,
+  ): Promise<void>;
+
+  /** Check object existence */
+  exists(remoteRelativePath: string): Promise<boolean>;
+
+  /**
+   * Rename/move object. If backend lacks native rename, implement as copy+delete.
+   * Should be atomic from the perspective of callers (or fail with rollback).
+   */
+  rename(oldRelativePath: string, newRelativePath: string): Promise<void>;
+
+  /** Delete remote object (for rollback/cleanup) */
+  delete(remoteRelativePath: string): Promise<void>;
+}
+
+/**
+ * Public-safe projections (optional helpers)
+ * Use these when returning status-like summaries to clients to avoid leaking INTERNAL fields.
+ */
+export type PublicUploadStatus = Pick<
+  UploadStatus,
+  | 'uploadId'
+  | 'filename'
+  | 'mime'
+  | 'size'
+  | 'chunkSize'
+  | 'totalChunks'
+  | 'receivedBytes'
+  | 'receivedIndexes'
+  | 'state'
+  | 'createdAt'
+  | 'expiresAt'
+> & { readonly percent?: number }; // computed on-the-fly; not persisted
diff --git a/apps/api/src/core/users/dto/create-user.dto.ts b/apps/api/src/core/users/dto/create-user.dto.ts
index 1638805..f3c4a7f 100644
--- a/apps/api/src/core/users/dto/create-user.dto.ts
+++ b/apps/api/src/core/users/dto/create-user.dto.ts
@@ -1,65 +1,65 @@
-﻿import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
-import {
-  IsBoolean,
-  IsEmail,
-  IsOptional,
-  IsString,
-  Length,
-  MaxLength,
-} from 'class-validator';
-
-export class CreateUserDto {
-  @ApiProperty({ example: 'john_doe' })
-  @IsString()
-  @Length(3, 32)
-  username: string;
-
-  @ApiPropertyOptional({ example: 'john@example.com' })
-  @IsOptional()
-  @IsEmail()
-  email?: string | null;
-
-  @ApiPropertyOptional({ example: '+989121234567' })
-  @IsOptional()
-  @IsString()
-  @MaxLength(16)
-  phone?: string | null;
-
-  @ApiPropertyOptional({ example: 'John Doe' })
-  @IsOptional()
-  @IsString()
-  @MaxLength(64)
-  name?: string | null;
-
-  @ApiPropertyOptional({ example: 'Product designer' })
-  @IsOptional()
-  @IsString()
-  bio?: string | null;
-
-  @ApiPropertyOptional({ example: 'Tehran' })
-  @IsOptional()
-  @IsString()
-  @MaxLength(64)
-  city?: string | null;
-
-  @ApiPropertyOptional({
-    example: 'https://cdn.example.com/avatars/john.png',
-  })
-  @IsOptional()
-  @IsString()
-  avatarUrl?: string | null;
-
-  @ApiPropertyOptional({ example: true })
-  @IsOptional()
-  @IsBoolean()
-  isActive?: boolean;
-
-  @ApiPropertyOptional({
-    description: 'Plain text password that will be hashed internally',
-    minLength: 8,
-  })
-  @IsOptional()
-  @IsString()
-  @Length(8, 128)
-  password?: string;
-}
+﻿import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
+import {
+  IsBoolean,
+  IsEmail,
+  IsOptional,
+  IsString,
+  Length,
+  MaxLength,
+} from 'class-validator';
+
+export class CreateUserDto {
+  @ApiProperty({ example: 'john_doe' })
+  @IsString()
+  @Length(3, 32)
+  username: string;
+
+  @ApiPropertyOptional({ example: 'john@example.com' })
+  @IsOptional()
+  @IsEmail()
+  email?: string | null;
+
+  @ApiPropertyOptional({ example: '+989121234567' })
+  @IsOptional()
+  @IsString()
+  @MaxLength(16)
+  phone?: string | null;
+
+  @ApiPropertyOptional({ example: 'John Doe' })
+  @IsOptional()
+  @IsString()
+  @MaxLength(64)
+  name?: string | null;
+
+  @ApiPropertyOptional({ example: 'Product designer' })
+  @IsOptional()
+  @IsString()
+  bio?: string | null;
+
+  @ApiPropertyOptional({ example: 'Tehran' })
+  @IsOptional()
+  @IsString()
+  @MaxLength(64)
+  city?: string | null;
+
+  @ApiPropertyOptional({
+    example: 'https://cdn.example.com/avatars/john.png',
+  })
+  @IsOptional()
+  @IsString()
+  avatarUrl?: string | null;
+
+  @ApiPropertyOptional({ example: true })
+  @IsOptional()
+  @IsBoolean()
+  isActive?: boolean;
+
+  @ApiPropertyOptional({
+    description: 'Plain text password that will be hashed internally',
+    minLength: 8,
+  })
+  @IsOptional()
+  @IsString()
+  @Length(8, 128)
+  password?: string;
+}
diff --git a/apps/api/src/core/users/dto/find-users-query.dto.ts b/apps/api/src/core/users/dto/find-users-query.dto.ts
index 63871ca..10bf3dd 100644
--- a/apps/api/src/core/users/dto/find-users-query.dto.ts
+++ b/apps/api/src/core/users/dto/find-users-query.dto.ts
@@ -1,31 +1,31 @@
-﻿import { ApiPropertyOptional } from '@nestjs/swagger';
-import { IsBoolean, IsOptional, IsString, IsUUID, Max, MaxLength, Min } from 'class-validator';
-import { Type } from 'class-transformer';
-
-export class FindUsersQueryDto {
-  @ApiPropertyOptional({ description: 'Filter by username or email' })
-  @IsOptional()
-  @IsString()
-  @MaxLength(64)
-  search?: string;
-
-  @ApiPropertyOptional({ description: 'Filter by active status' })
-  @IsOptional()
-  @IsBoolean()
-  @Type(() => Boolean)
-  isActive?: boolean;
-
-  @ApiPropertyOptional({
-    description: 'Pagination cursor (last user id from previous page)',
-  })
-  @IsOptional()
-  @IsUUID('4')
-  cursor?: string;
-
-  @ApiPropertyOptional({ description: 'Max number of records to return', default: 25 })
-  @IsOptional()
-  @Type(() => Number)
-  @Min(1)
-  @Max(100)
-  limit?: number;
-}
+﻿import { ApiPropertyOptional } from '@nestjs/swagger';
+import { IsBoolean, IsOptional, IsString, IsUUID, Max, MaxLength, Min } from 'class-validator';
+import { Type } from 'class-transformer';
+
+export class FindUsersQueryDto {
+  @ApiPropertyOptional({ description: 'Filter by username or email' })
+  @IsOptional()
+  @IsString()
+  @MaxLength(64)
+  search?: string;
+
+  @ApiPropertyOptional({ description: 'Filter by active status' })
+  @IsOptional()
+  @IsBoolean()
+  @Type(() => Boolean)
+  isActive?: boolean;
+
+  @ApiPropertyOptional({
+    description: 'Pagination cursor (last user id from previous page)',
+  })
+  @IsOptional()
+  @IsUUID('4')
+  cursor?: string;
+
+  @ApiPropertyOptional({ description: 'Max number of records to return', default: 25 })
+  @IsOptional()
+  @Type(() => Number)
+  @Min(1)
+  @Max(100)
+  limit?: number;
+}
diff --git a/apps/api/src/core/users/dto/update-user.dto.ts b/apps/api/src/core/users/dto/update-user.dto.ts
index 3c2b034..830724a 100644
--- a/apps/api/src/core/users/dto/update-user.dto.ts
+++ b/apps/api/src/core/users/dto/update-user.dto.ts
@@ -2,7 +2,7 @@
  * DTO for partial user updates leveraging CreateUserDto definitions.
  */
 import { PartialType } from '@nestjs/swagger';
-import { CreateUserDto } from './create-user.dto';
+import { CreateUserDto } from '@app/core/users/dto/create-user.dto';
 
 /**
  * Mirrors CreateUserDto fields but marks them optional for updates.
diff --git a/apps/api/src/core/users/dto/user-id-param.dto.ts b/apps/api/src/core/users/dto/user-id-param.dto.ts
index 2f02bd2..dc24757 100644
--- a/apps/api/src/core/users/dto/user-id-param.dto.ts
+++ b/apps/api/src/core/users/dto/user-id-param.dto.ts
@@ -1,8 +1,8 @@
-﻿import { ApiProperty } from '@nestjs/swagger';
-import { IsUUID } from 'class-validator';
-
-export class UserIdParamDto {
-  @ApiProperty({ format: 'uuid' })
-  @IsUUID('4')
-  id: string;
-}
+﻿import { ApiProperty } from '@nestjs/swagger';
+import { IsUUID } from 'class-validator';
+
+export class UserIdParamDto {
+  @ApiProperty({ format: 'uuid' })
+  @IsUUID('4')
+  id: string;
+}
diff --git a/apps/api/src/core/users/profile/README_ProfileModule.md b/apps/api/src/core/users/profile/README_ProfileModule.md
index 827e743..d9f7f2a 100644
--- a/apps/api/src/core/users/profile/README_ProfileModule.md
+++ b/apps/api/src/core/users/profile/README_ProfileModule.md
@@ -1,151 +1,151 @@
-# 🧩 Profile Module
-
-ماژول **Profile** مسئول مدیریت داده‌های پروفایل کاربر در بخش Core سیستم نگاره است.  
-این ماژول صرفاً با **کاربر احراز هویت‌شده (Authenticated User)** کار می‌کند  
-و شامل دو مسیر اصلی برای خواندن و به‌روزرسانی اطلاعات پروفایل است.
-
----
-
-## 📁 ساختار فایل‌ها
-
-```
-core/profile/
-├── dto/
-│   └── update-profile.dto.ts      # DTO برای ویرایش فیلدهای مجاز پروفایل
-├── profile.controller.ts          # کنترلر برای مدیریت GET/PATCH پروفایل
-├── profile.service.ts             # منطق بیزینسی برای واکشی و ویرایش پروفایل
-├── profile.module.ts              # ماژول Nest برای باندل کردن کنترلر و سرویس
-└── README.md                      # مستندات این ماژول (همین فایل)
-```
-
----
-
-## ⚙️ وابستگی‌ها (Dependencies)
-
-- `PrismaService` از `@app/prisma`
-- `JwtAuthGuard` برای احراز هویت
-- `NoCacheInterceptor` برای جلوگیری از کش شدن پاسخ‌ها
-
----
-
-## 📡 Endpointها
-
-### 🔹 `GET /core/profile`
-**دریافت پروفایل کاربر فعلی**
-
-**نیاز به احراز هویت:** ✅ (Bearer Token)
-
-**مثال پاسخ:**
-```json
-{
-  "success": true,
-  "data": {
-    "id": "c1d5f0bc-6f46-4ae4-9b28-2d7574156d1b",
-    "username": "negare_user",
-    "name": "Negare User",
-    "email": "user@example.com",
-    "phone": "09121234567",
-    "bio": "Capital markets enthusiast",
-    "city": "Shiraz",
-    "avatarUrl": "https://cdn.negare.com/avatar.png",
-    "createdAt": "2024-01-01T10:00:00.000Z",
-    "updatedAt": "2024-02-01T10:00:00.000Z"
-  }
-}
-```
-
----
-
-### 🔹 `PATCH /core/profile`
-**ویرایش پروفایل کاربر فعلی**
-
-**نیاز به احراز هویت:** ✅ (Bearer Token)
-
-**ورودی (UpdateProfileDto):**
-```json
-{
-  "name": "Negare Pro",
-  "bio": "Updated profile bio",
-  "city": "Tehran",
-  "avatarUrl": "https://cdn.negare.com/avatar-new.png"
-}
-```
-
-**نکات مهم:**
-- تغییر `email` یا `phone` از این مسیر مجاز نیست.
-- برای تغییر آن‌ها باید از فلوهای OTP استفاده شود.
-- فیلدهای `null` یا `""` باعث پاک شدن مقدار آن فیلد در DB می‌شوند.
-
-**مثال پاسخ:**
-```json
-{
-  "success": true,
-  "data": {
-    "id": "c1d5f0bc-6f46-4ae4-9b28-2d7574156d1b",
-    "username": "negare_user",
-    "name": "Negare Pro",
-    "bio": "Updated profile bio",
-    "city": "Tehran",
-    "avatarUrl": "https://cdn.negare.com/avatar-new.png",
-    "email": "user@example.com",
-    "phone": "09121234567",
-    "updatedAt": "2024-03-01T10:00:00.000Z"
-  }
-}
-```
-
----
-
-## 🧠 منطق بیزینسی (Business Logic)
-
-- فقط کاربر لاگین‌شده می‌تواند به این مسیرها دسترسی داشته باشد.
-- هر دو endpoint توسط `JwtAuthGuard` محافظت می‌شوند.
-- پاسخ‌ها `NoCacheInterceptor` دارند تا در مرورگر یا CDN ذخیره نشوند.
-- سرویس `ProfileService` مسئول نرمال‌سازی مقادیر (trim / nullify) است.
-- هرگونه تلاش برای تغییر `email` یا `phone` خطای `400 Bad Request` برمی‌گرداند.
-
----
-
-## 🧪 تست در Postman
-
-**Collection Example:**  
-```
-Authorization: Bearer <accessToken>
-```
-
-1️⃣ `GET {{baseUrl}}/core/profile`  
-➡️ انتظار پاسخ `200 OK` با اطلاعات کاربر.
-
-2️⃣ `PATCH {{baseUrl}}/core/profile`  
-بدنه‌ی JSON مشابه نمونه بالا.  
-➡️ انتظار پاسخ `200 OK` با مقادیر به‌روزشده.
-
-3️⃣ ارسال فیلد `email` یا `phone`  
-➡️ انتظار پاسخ `400 Bad Request` با پیام  
-`برای تغییر ایمیل یا موبایل لطفاً از مسیر تایید OTP استفاده کنید.`
-
----
-
-## 🧱 Swagger Docs
-در مسیر `/docs`  
-زیر دستهٔ **User Profile** دو endpoint نمایش داده می‌شود:
-- ✅ `GET /core/profile`
-- ✅ `PATCH /core/profile`
-
----
-
-## 📘 خلاصه
-
-| قابلیت | وضعیت |
-|---------|--------|
-| خواندن پروفایل | ✅ |
-| ویرایش پروفایل | ✅ |
-| جلوگیری از تغییر شماره/ایمیل | ✅ |
-| سازگاری با Swagger | ✅ |
-| تست‌شده با Postman | ✅ |
-
----
-
-**نگاره - Core/Profile Module**  
-نسخه: `v1.0.0`  
-نویسنده: _امیرحسین و رابرت ❤️_
+# 🧩 Profile Module
+
+ماژول **Profile** مسئول مدیریت داده‌های پروفایل کاربر در بخش Core سیستم نگاره است.  
+این ماژول صرفاً با **کاربر احراز هویت‌شده (Authenticated User)** کار می‌کند  
+و شامل دو مسیر اصلی برای خواندن و به‌روزرسانی اطلاعات پروفایل است.
+
+---
+
+## 📁 ساختار فایل‌ها
+
+```
+core/profile/
+├── dto/
+│   └── update-profile.dto.ts      # DTO برای ویرایش فیلدهای مجاز پروفایل
+├── profile.controller.ts          # کنترلر برای مدیریت GET/PATCH پروفایل
+├── profile.service.ts             # منطق بیزینسی برای واکشی و ویرایش پروفایل
+├── profile.module.ts              # ماژول Nest برای باندل کردن کنترلر و سرویس
+└── README.md                      # مستندات این ماژول (همین فایل)
+```
+
+---
+
+## ⚙️ وابستگی‌ها (Dependencies)
+
+- `PrismaService` از `@app/prisma`
+- `JwtAuthGuard` برای احراز هویت
+- `NoCacheInterceptor` برای جلوگیری از کش شدن پاسخ‌ها
+
+---
+
+## 📡 Endpointها
+
+### 🔹 `GET /core/profile`
+**دریافت پروفایل کاربر فعلی**
+
+**نیاز به احراز هویت:** ✅ (Bearer Token)
+
+**مثال پاسخ:**
+```json
+{
+  "success": true,
+  "data": {
+    "id": "c1d5f0bc-6f46-4ae4-9b28-2d7574156d1b",
+    "username": "negare_user",
+    "name": "Negare User",
+    "email": "user@example.com",
+    "phone": "09121234567",
+    "bio": "Capital markets enthusiast",
+    "city": "Shiraz",
+    "avatarUrl": "https://cdn.negare.com/avatar.png",
+    "createdAt": "2024-01-01T10:00:00.000Z",
+    "updatedAt": "2024-02-01T10:00:00.000Z"
+  }
+}
+```
+
+---
+
+### 🔹 `PATCH /core/profile`
+**ویرایش پروفایل کاربر فعلی**
+
+**نیاز به احراز هویت:** ✅ (Bearer Token)
+
+**ورودی (UpdateProfileDto):**
+```json
+{
+  "name": "Negare Pro",
+  "bio": "Updated profile bio",
+  "city": "Tehran",
+  "avatarUrl": "https://cdn.negare.com/avatar-new.png"
+}
+```
+
+**نکات مهم:**
+- تغییر `email` یا `phone` از این مسیر مجاز نیست.
+- برای تغییر آن‌ها باید از فلوهای OTP استفاده شود.
+- فیلدهای `null` یا `""` باعث پاک شدن مقدار آن فیلد در DB می‌شوند.
+
+**مثال پاسخ:**
+```json
+{
+  "success": true,
+  "data": {
+    "id": "c1d5f0bc-6f46-4ae4-9b28-2d7574156d1b",
+    "username": "negare_user",
+    "name": "Negare Pro",
+    "bio": "Updated profile bio",
+    "city": "Tehran",
+    "avatarUrl": "https://cdn.negare.com/avatar-new.png",
+    "email": "user@example.com",
+    "phone": "09121234567",
+    "updatedAt": "2024-03-01T10:00:00.000Z"
+  }
+}
+```
+
+---
+
+## 🧠 منطق بیزینسی (Business Logic)
+
+- فقط کاربر لاگین‌شده می‌تواند به این مسیرها دسترسی داشته باشد.
+- هر دو endpoint توسط `JwtAuthGuard` محافظت می‌شوند.
+- پاسخ‌ها `NoCacheInterceptor` دارند تا در مرورگر یا CDN ذخیره نشوند.
+- سرویس `ProfileService` مسئول نرمال‌سازی مقادیر (trim / nullify) است.
+- هرگونه تلاش برای تغییر `email` یا `phone` خطای `400 Bad Request` برمی‌گرداند.
+
+---
+
+## 🧪 تست در Postman
+
+**Collection Example:**  
+```
+Authorization: Bearer <accessToken>
+```
+
+1️⃣ `GET {{baseUrl}}/core/profile`  
+➡️ انتظار پاسخ `200 OK` با اطلاعات کاربر.
+
+2️⃣ `PATCH {{baseUrl}}/core/profile`  
+بدنه‌ی JSON مشابه نمونه بالا.  
+➡️ انتظار پاسخ `200 OK` با مقادیر به‌روزشده.
+
+3️⃣ ارسال فیلد `email` یا `phone`  
+➡️ انتظار پاسخ `400 Bad Request` با پیام  
+`برای تغییر ایمیل یا موبایل لطفاً از مسیر تایید OTP استفاده کنید.`
+
+---
+
+## 🧱 Swagger Docs
+در مسیر `/docs`  
+زیر دستهٔ **User Profile** دو endpoint نمایش داده می‌شود:
+- ✅ `GET /core/profile`
+- ✅ `PATCH /core/profile`
+
+---
+
+## 📘 خلاصه
+
+| قابلیت | وضعیت |
+|---------|--------|
+| خواندن پروفایل | ✅ |
+| ویرایش پروفایل | ✅ |
+| جلوگیری از تغییر شماره/ایمیل | ✅ |
+| سازگاری با Swagger | ✅ |
+| تست‌شده با Postman | ✅ |
+
+---
+
+**نگاره - Core/Profile Module**  
+نسخه: `v1.0.0`  
+نویسنده: _امیرحسین و رابرت ❤️_
diff --git a/apps/api/src/core/users/profile/dto/update-profile.dto.ts b/apps/api/src/core/users/profile/dto/update-profile.dto.ts
index 14068f8..769a1b7 100644
--- a/apps/api/src/core/users/profile/dto/update-profile.dto.ts
+++ b/apps/api/src/core/users/profile/dto/update-profile.dto.ts
@@ -1,99 +1,99 @@
-﻿/**
- * DTO representing supported profile mutations initiated by authenticated users.
- * Updated: fully nullable-safe, compatible with Prisma & class-validator.
- */
-
-import { ApiPropertyOptional } from '@nestjs/swagger';
-import {
-  IsEmpty,
-  IsOptional,
-  IsString,
-  IsUrl,
-  MaxLength,
-  ValidateIf,
-} from 'class-validator';
-
-/**
- * Allows mutating safe profile fields (name, bio, city, avatarUrl)
- * while deferring contact changes (email/phone) to OTP flows.
- */
-export class UpdateProfileDto {
-  // ───────────────────────────────
-  // Display name
-  // ───────────────────────────────
-  @ApiPropertyOptional({
-    example: 'Negare User',
-    description:
-      'Display name for the user. Use null or empty string to clear.',
-  })
-  @IsOptional()
-  @IsString()
-  @MaxLength(80)
-  name?: string | null;
-
-  // ───────────────────────────────
-  // Bio
-  // ───────────────────────────────
-  @ApiPropertyOptional({
-    example: 'Capital markets enthusiast',
-    description:
-      'Short bio shown in the user profile. Use null or empty string to clear.',
-  })
-  @IsOptional()
-  @IsString()
-  @MaxLength(200)
-  bio?: string | null;
-
-  // ───────────────────────────────
-  // City
-  // ───────────────────────────────
-  @ApiPropertyOptional({
-    example: 'Tehran',
-    description: 'City where the user is active.',
-  })
-  @IsOptional()
-  @IsString()
-  @MaxLength(60)
-  city?: string | null;
-
-  // ───────────────────────────────
-  // Avatar URL
-  // ───────────────────────────────
-  @ApiPropertyOptional({
-    example: 'https://cdn.negare.com/avatar.png',
-    description:
-      'Full URL of the avatar image. Must include protocol (https://). Null allowed to clear.',
-  })
-  @ValidateIf((o) => o.avatarUrl !== null && o.avatarUrl !== undefined)
-  @IsOptional()
-  @IsUrl({ require_protocol: true }, { message: 'Invalid avatar URL format.' })
-  avatarUrl?: string | null;
-
-  // ───────────────────────────────
-  // Email (blocked for direct change)
-  // ───────────────────────────────
-  @ApiPropertyOptional({
-    example: 'new-email@example.com',
-    description:
-      'Email changes are not permitted on this endpoint. Send via OTP flow instead.',
-  })
-  @IsOptional()
-  @IsEmpty({
-    message: 'Email changes are not permitted on this endpoint.',
-  })
-  email?: string | null;
-
-  // ───────────────────────────────
-  // Phone (blocked for direct change)
-  // ───────────────────────────────
-  @ApiPropertyOptional({
-    example: '09123456789',
-    description:
-      'Phone number changes are not permitted on this endpoint. Use OTP verification flow.',
-  })
-  @IsOptional()
-  @IsEmpty({
-    message: 'Phone changes are not permitted on this endpoint.',
-  })
-  phone?: string | null;
-}
+﻿/**
+ * DTO representing supported profile mutations initiated by authenticated users.
+ * Updated: fully nullable-safe, compatible with Prisma & class-validator.
+ */
+
+import { ApiPropertyOptional } from '@nestjs/swagger';
+import {
+  IsEmpty,
+  IsOptional,
+  IsString,
+  IsUrl,
+  MaxLength,
+  ValidateIf,
+} from 'class-validator';
+
+/**
+ * Allows mutating safe profile fields (name, bio, city, avatarUrl)
+ * while deferring contact changes (email/phone) to OTP flows.
+ */
+export class UpdateProfileDto {
+  // ───────────────────────────────
+  // Display name
+  // ───────────────────────────────
+  @ApiPropertyOptional({
+    example: 'Negare User',
+    description:
+      'Display name for the user. Use null or empty string to clear.',
+  })
+  @IsOptional()
+  @IsString()
+  @MaxLength(80)
+  name?: string | null;
+
+  // ───────────────────────────────
+  // Bio
+  // ───────────────────────────────
+  @ApiPropertyOptional({
+    example: 'Capital markets enthusiast',
+    description:
+      'Short bio shown in the user profile. Use null or empty string to clear.',
+  })
+  @IsOptional()
+  @IsString()
+  @MaxLength(200)
+  bio?: string | null;
+
+  // ───────────────────────────────
+  // City
+  // ───────────────────────────────
+  @ApiPropertyOptional({
+    example: 'Tehran',
+    description: 'City where the user is active.',
+  })
+  @IsOptional()
+  @IsString()
+  @MaxLength(60)
+  city?: string | null;
+
+  // ───────────────────────────────
+  // Avatar URL
+  // ───────────────────────────────
+  @ApiPropertyOptional({
+    example: 'https://cdn.negare.com/avatar.png',
+    description:
+      'Full URL of the avatar image. Must include protocol (https://). Null allowed to clear.',
+  })
+  @ValidateIf((o) => o.avatarUrl !== null && o.avatarUrl !== undefined)
+  @IsOptional()
+  @IsUrl({ require_protocol: true }, { message: 'Invalid avatar URL format.' })
+  avatarUrl?: string | null;
+
+  // ───────────────────────────────
+  // Email (blocked for direct change)
+  // ───────────────────────────────
+  @ApiPropertyOptional({
+    example: 'new-email@example.com',
+    description:
+      'Email changes are not permitted on this endpoint. Send via OTP flow instead.',
+  })
+  @IsOptional()
+  @IsEmpty({
+    message: 'Email changes are not permitted on this endpoint.',
+  })
+  email?: string | null;
+
+  // ───────────────────────────────
+  // Phone (blocked for direct change)
+  // ───────────────────────────────
+  @ApiPropertyOptional({
+    example: '09123456789',
+    description:
+      'Phone number changes are not permitted on this endpoint. Use OTP verification flow.',
+  })
+  @IsOptional()
+  @IsEmpty({
+    message: 'Phone changes are not permitted on this endpoint.',
+  })
+  phone?: string | null;
+}
diff --git a/apps/api/src/core/users/profile/dto/update-username.dto.ts b/apps/api/src/core/users/profile/dto/update-username.dto.ts
index a92664a..aa2484b 100644
--- a/apps/api/src/core/users/profile/dto/update-username.dto.ts
+++ b/apps/api/src/core/users/profile/dto/update-username.dto.ts
@@ -1,7 +1,7 @@
 import { ApiProperty } from '@nestjs/swagger';
 import { IsDefined, IsString, Length, Matches } from 'class-validator';
 import { Transform } from 'class-transformer';
-import { USERNAME_MIN, USERNAME_MAX, USERNAME_REGEX } from '../username.rules';
+import { USERNAME_MIN, USERNAME_MAX, USERNAME_REGEX } from '@app/core/users/profile/username.rules';
 
 export class UpdateUsernameDto {
   @ApiProperty({
diff --git a/apps/api/src/core/users/profile/profile.controller.ts b/apps/api/src/core/users/profile/profile.controller.ts
index 0b0d117..a9fbb26 100644
--- a/apps/api/src/core/users/profile/profile.controller.ts
+++ b/apps/api/src/core/users/profile/profile.controller.ts
@@ -1,150 +1,150 @@
-﻿import {
-  Body,
-  Controller,
-  Get,
-  Patch,
-  Query,
-  UnauthorizedException,
-  UseGuards,
-  UseInterceptors,
-  HttpCode,
-  HttpStatus,
-} from '@nestjs/common';
-import {
-  ApiBearerAuth,
-  ApiOperation,
-  ApiResponse,
-  ApiTags,
-  ApiQuery,
-} from '@nestjs/swagger';
-import {
-  CurrentUser,
-  CurrentUserPayload,
-} from '@app/common/decorators/current-user.decorator';
-import { JwtAuthGuard } from '@app/core/auth/guards/jwt-auth.guard';
-import { ProfileService } from './profile.service';
-import { UpdateProfileDto } from './dto/update-profile.dto';
-import { UpdateUsernameDto } from './dto/update-username.dto';
-import { NoCacheInterceptor } from '@app/common/interceptors/no-cache.interceptor';
-
-@ApiTags('User Profile')
-@ApiBearerAuth('bearer')
-@UseGuards(JwtAuthGuard)
-@UseInterceptors(NoCacheInterceptor)
-@Controller('core/profile')
-export class ProfileController {
-  constructor(private readonly profileService: ProfileService) {}
-
-  // ───────────────────────────────
-  // GET /core/profile
-  // ───────────────────────────────
-  @Get()
-  @ApiOperation({
-    summary: 'Get current user profile',
-    description:
-      'Returns the latest profile information for the authenticated user.',
-  })
-  async getProfile(@CurrentUser() currentUser: CurrentUserPayload | undefined) {
-    const userId = this.ensureUser(currentUser);
-    const profile = await this.profileService.getProfile(userId);
-    return { success: true as const, data: profile };
-  }
-
-  // ───────────────────────────────
-  // PATCH /core/profile
-  // ───────────────────────────────
-  @Patch()
-  @ApiOperation({
-    summary: 'Update current user profile',
-    description:
-      'Updates name, bio, city, and avatarUrl. Email/phone must use OTP flow.',
-  })
-  async updateProfile(
-    @CurrentUser() currentUser: CurrentUserPayload | undefined,
-    @Body() dto: UpdateProfileDto,
-  ) {
-    const userId = this.ensureUser(currentUser);
-    const profile = await this.profileService.updateProfile(userId, dto);
-    return { success: true as const, data: profile };
-  }
-
-  // ───────────────────────────────
-  // GET /core/profile/username/check?username=x
-  // ───────────────────────────────
-  @Get('username/check')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({
-    summary: 'Check username availability',
-    description:
-      'Validates username format and returns whether it is available for registration.',
-  })
-  @ApiQuery({ name: 'username', required: true, example: 'negare_user' })
-  @ApiResponse({
-    status: 200,
-    schema: {
-      example: {
-        ok: true,
-        available: true,
-        username: 'negare_user',
-      },
-    },
-  })
-  async checkUsername(@Query('username') username: string) {
-    const result =
-      await this.profileService.checkUsernameAvailability(username);
-    return result;
-  }
-
-  // ───────────────────────────────
-  // PATCH /core/profile/username
-  // ───────────────────────────────
-  @Patch('username')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({
-    summary: 'Change username',
-    description:
-      'Allows the authenticated user to change their username if valid and available.',
-  })
-  @ApiResponse({
-    status: 200,
-    description: 'Username changed successfully.',
-    schema: {
-      example: {
-        success: true,
-        data: {
-          id: 'c1d5f0bc-6f46-4ae4-9b28-2d7574156d1b',
-          username: 'amir_varmanli',
-          name: 'Amir Hossein',
-          email: 'user@example.com',
-          phone: '09121234567',
-          bio: 'Capital markets enthusiast',
-          city: 'Shiraz',
-          avatarUrl: 'https://cdn.negare.com/avatar.png',
-          createdAt: '2024-01-01T10:00:00.000Z',
-          updatedAt: '2024-02-01T10:00:00.000Z',
-        },
-      },
-    },
-  })
-  async updateUsername(
-    @CurrentUser() currentUser: CurrentUserPayload | undefined,
-    @Body() dto: UpdateUsernameDto,
-  ) {
-    const userId = this.ensureUser(currentUser);
-    const profile = await this.profileService.updateUsername(
-      userId,
-      dto.username,
-    );
-    return { success: true as const, data: profile };
-  }
-
-  // ───────────────────────────────
-  // Guard for user existence
-  // ───────────────────────────────
-  private ensureUser(currentUser: CurrentUserPayload | undefined): string {
-    if (!currentUser?.id) {
-      throw new UnauthorizedException('User context is missing.');
-    }
-    return currentUser.id;
-  }
-}
+﻿import {
+  Body,
+  Controller,
+  Get,
+  Patch,
+  Query,
+  UnauthorizedException,
+  UseGuards,
+  UseInterceptors,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiBearerAuth,
+  ApiOperation,
+  ApiResponse,
+  ApiTags,
+  ApiQuery,
+} from '@nestjs/swagger';
+import {
+  CurrentUser,
+  CurrentUserPayload,
+} from '@app/common/decorators/current-user.decorator';
+import { JwtAuthGuard } from '@app/core/auth/guards/jwt-auth.guard';
+import { ProfileService } from '@app/core/users/profile/profile.service';
+import { UpdateProfileDto } from '@app/core/users/profile/dto/update-profile.dto';
+import { UpdateUsernameDto } from '@app/core/users/profile/dto/update-username.dto';
+import { NoCacheInterceptor } from '@app/common/interceptors/no-cache.interceptor';
+
+@ApiTags('User Profile')
+@ApiBearerAuth('bearer')
+@UseGuards(JwtAuthGuard)
+@UseInterceptors(NoCacheInterceptor)
+@Controller('core/profile')
+export class ProfileController {
+  constructor(private readonly profileService: ProfileService) {}
+
+  // ───────────────────────────────
+  // GET /core/profile
+  // ───────────────────────────────
+  @Get()
+  @ApiOperation({
+    summary: 'Get current user profile',
+    description:
+      'Returns the latest profile information for the authenticated user.',
+  })
+  async getProfile(@CurrentUser() currentUser: CurrentUserPayload | undefined) {
+    const userId = this.ensureUser(currentUser);
+    const profile = await this.profileService.getProfile(userId);
+    return { success: true as const, data: profile };
+  }
+
+  // ───────────────────────────────
+  // PATCH /core/profile
+  // ───────────────────────────────
+  @Patch()
+  @ApiOperation({
+    summary: 'Update current user profile',
+    description:
+      'Updates name, bio, city, and avatarUrl. Email/phone must use OTP flow.',
+  })
+  async updateProfile(
+    @CurrentUser() currentUser: CurrentUserPayload | undefined,
+    @Body() dto: UpdateProfileDto,
+  ) {
+    const userId = this.ensureUser(currentUser);
+    const profile = await this.profileService.updateProfile(userId, dto);
+    return { success: true as const, data: profile };
+  }
+
+  // ───────────────────────────────
+  // GET /core/profile/username/check?username=x
+  // ───────────────────────────────
+  @Get('username/check')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({
+    summary: 'Check username availability',
+    description:
+      'Validates username format and returns whether it is available for registration.',
+  })
+  @ApiQuery({ name: 'username', required: true, example: 'negare_user' })
+  @ApiResponse({
+    status: 200,
+    schema: {
+      example: {
+        ok: true,
+        available: true,
+        username: 'negare_user',
+      },
+    },
+  })
+  async checkUsername(@Query('username') username: string) {
+    const result =
+      await this.profileService.checkUsernameAvailability(username);
+    return result;
+  }
+
+  // ───────────────────────────────
+  // PATCH /core/profile/username
+  // ───────────────────────────────
+  @Patch('username')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({
+    summary: 'Change username',
+    description:
+      'Allows the authenticated user to change their username if valid and available.',
+  })
+  @ApiResponse({
+    status: 200,
+    description: 'Username changed successfully.',
+    schema: {
+      example: {
+        success: true,
+        data: {
+          id: 'c1d5f0bc-6f46-4ae4-9b28-2d7574156d1b',
+          username: 'amir_varmanli',
+          name: 'Amir Hossein',
+          email: 'user@example.com',
+          phone: '09121234567',
+          bio: 'Capital markets enthusiast',
+          city: 'Shiraz',
+          avatarUrl: 'https://cdn.negare.com/avatar.png',
+          createdAt: '2024-01-01T10:00:00.000Z',
+          updatedAt: '2024-02-01T10:00:00.000Z',
+        },
+      },
+    },
+  })
+  async updateUsername(
+    @CurrentUser() currentUser: CurrentUserPayload | undefined,
+    @Body() dto: UpdateUsernameDto,
+  ) {
+    const userId = this.ensureUser(currentUser);
+    const profile = await this.profileService.updateUsername(
+      userId,
+      dto.username,
+    );
+    return { success: true as const, data: profile };
+  }
+
+  // ───────────────────────────────
+  // Guard for user existence
+  // ───────────────────────────────
+  private ensureUser(currentUser: CurrentUserPayload | undefined): string {
+    if (!currentUser?.id) {
+      throw new UnauthorizedException('User context is missing.');
+    }
+    return currentUser.id;
+  }
+}
diff --git a/apps/api/src/core/users/profile/profile.module.ts b/apps/api/src/core/users/profile/profile.module.ts
index daccacd..c486d31 100644
--- a/apps/api/src/core/users/profile/profile.module.ts
+++ b/apps/api/src/core/users/profile/profile.module.ts
@@ -2,8 +2,8 @@
  * ProfileModule bundles the profile controller/service and required dependencies.
  */
 import { Module } from '@nestjs/common';
-import { ProfileController } from './profile.controller';
-import { ProfileService } from './profile.service';
+import { ProfileController } from '@app/core/users/profile/profile.controller';
+import { ProfileService } from '@app/core/users/profile/profile.service';
 import { JwtAuthGuard } from '@app/core/auth/guards/jwt-auth.guard';
 import { NoCacheInterceptor } from '@app/common/interceptors/no-cache.interceptor';
 
diff --git a/apps/api/src/core/users/profile/profile.service.ts b/apps/api/src/core/users/profile/profile.service.ts
index 5ba148b..fef0449 100644
--- a/apps/api/src/core/users/profile/profile.service.ts
+++ b/apps/api/src/core/users/profile/profile.service.ts
@@ -7,7 +7,7 @@ import {
 } from '@nestjs/common';
 import type { Prisma as PrismaNS } from '@prisma/client';
 import { PrismaService } from '@app/prisma/prisma.service';
-import { UpdateProfileDto } from './dto/update-profile.dto';
+import { UpdateProfileDto } from '@app/core/users/profile/dto/update-profile.dto';
 
 // قوانین نام‌کاربری (قبلاً ساختیم)
 import {
@@ -15,7 +15,7 @@ import {
   USERNAME_MAX,
   USERNAME_REGEX,
   RESERVED_USERNAMES,
-} from './username.rules';
+} from '@app/core/users/profile/username.rules';
 import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
 
 type RoleSlim = { id: string; name: string };
diff --git a/apps/api/src/core/users/profile/username.rules.ts b/apps/api/src/core/users/profile/username.rules.ts
index 501bf19..6860878 100644
--- a/apps/api/src/core/users/profile/username.rules.ts
+++ b/apps/api/src/core/users/profile/username.rules.ts
@@ -1,21 +1,21 @@
-export const USERNAME_MIN = 3;
-export const USERNAME_MAX = 20;
-// بدون _ اول/آخر، بدون __ متوالی (سخت‌گیرانه‌تر و تمیزتر)
-export const USERNAME_REGEX = /^[a-z0-9](?:[a-z0-9_]*[a-z0-9])?$/;
-
-export const RESERVED_USERNAMES: ReadonlySet<string> = new Set([
-  'admin',
-  'root',
-  'system',
-  'support',
-  'help',
-  'contact',
-  'negare',
-  'api',
-  'docs',
-  'blog',
-  'news',
-  'about',
-  'login',
-  'signup',
-]);
+export const USERNAME_MIN = 3;
+export const USERNAME_MAX = 20;
+// بدون _ اول/آخر، بدون __ متوالی (سخت‌گیرانه‌تر و تمیزتر)
+export const USERNAME_REGEX = /^[a-z0-9](?:[a-z0-9_]*[a-z0-9])?$/;
+
+export const RESERVED_USERNAMES: ReadonlySet<string> = new Set([
+  'admin',
+  'root',
+  'system',
+  'support',
+  'help',
+  'contact',
+  'negare',
+  'api',
+  'docs',
+  'blog',
+  'news',
+  'about',
+  'login',
+  'signup',
+]);
diff --git a/apps/api/src/core/users/users.controller.ts b/apps/api/src/core/users/users.controller.ts
index 7fa6089..915bf57 100644
--- a/apps/api/src/core/users/users.controller.ts
+++ b/apps/api/src/core/users/users.controller.ts
@@ -22,11 +22,11 @@ import {
   CurrentUserPayload,
 } from '@app/common/decorators/current-user.decorator';
 import { Roles } from '@app/common/decorators/roles.decorator';
-import { CreateUserDto } from './dto/create-user.dto';
-import { FindUsersQueryDto } from './dto/find-users-query.dto';
-import { UpdateUserDto } from './dto/update-user.dto';
-import { UserIdParamDto } from './dto/user-id-param.dto';
-import { UsersService } from './users.service';
+import { CreateUserDto } from '@app/core/users/dto/create-user.dto';
+import { FindUsersQueryDto } from '@app/core/users/dto/find-users-query.dto';
+import { UpdateUserDto } from '@app/core/users/dto/update-user.dto';
+import { UserIdParamDto } from '@app/core/users/dto/user-id-param.dto';
+import { UsersService } from '@app/core/users/users.service';
 import { RoleName } from '@prisma/client';
 
 @ApiTags('Users')
diff --git a/apps/api/src/core/users/users.module.ts b/apps/api/src/core/users/users.module.ts
index d894f55..4ac4b97 100644
--- a/apps/api/src/core/users/users.module.ts
+++ b/apps/api/src/core/users/users.module.ts
@@ -2,8 +2,8 @@
  * UsersModule exposes user CRUD services/controllers for the core domain.
  */
 import { Module } from '@nestjs/common';
-import { UsersController } from './users.controller';
-import { UsersService } from './users.service';
+import { UsersController } from '@app/core/users/users.controller';
+import { UsersService } from '@app/core/users/users.service';
 
 @Module({
   controllers: [UsersController],
diff --git a/apps/api/src/core/users/users.service.ts b/apps/api/src/core/users/users.service.ts
index 6afb239..fa64a04 100644
--- a/apps/api/src/core/users/users.service.ts
+++ b/apps/api/src/core/users/users.service.ts
@@ -6,9 +6,9 @@ import {
 import type { Prisma } from '@prisma/client';
 import { createHash } from 'node:crypto';
 import { PrismaService } from '@app/prisma/prisma.service';
-import { FindUsersQueryDto } from './dto/find-users-query.dto';
-import { CreateUserDto } from './dto/create-user.dto';
-import { UpdateUserDto } from './dto/update-user.dto';
+import { FindUsersQueryDto } from '@app/core/users/dto/find-users-query.dto';
+import { CreateUserDto } from '@app/core/users/dto/create-user.dto';
+import { UpdateUserDto } from '@app/core/users/dto/update-user.dto';
 
 /** include واحد و تایپ همگام با Prisma */
 const userWithRelations = {
diff --git a/apps/api/src/health/health.controller.ts b/apps/api/src/health/health.controller.ts
index 0daf860..4a11074 100644
--- a/apps/api/src/health/health.controller.ts
+++ b/apps/api/src/health/health.controller.ts
@@ -1,5 +1,5 @@
 import { Controller, Get } from '@nestjs/common';
-import { HealthService } from './health.service';
+import { HealthService } from '@app/health/health.service';
 import { Public } from '@app/common/decorators/public.decorator';
 
 @Controller()
diff --git a/apps/api/src/health/health.module.ts b/apps/api/src/health/health.module.ts
index 79af239..0808acf 100644
--- a/apps/api/src/health/health.module.ts
+++ b/apps/api/src/health/health.module.ts
@@ -1,6 +1,6 @@
 import { Module } from '@nestjs/common';
-import { HealthController } from './health.controller';
-import { HealthService } from './health.service';
+import { HealthController } from '@app/health/health.controller';
+import { HealthService } from '@app/health/health.service';
 
 @Module({
   controllers: [HealthController],
diff --git a/apps/api/src/health/health.service.ts b/apps/api/src/health/health.service.ts
index a82cf84..93ffa94 100644
--- a/apps/api/src/health/health.service.ts
+++ b/apps/api/src/health/health.service.ts
@@ -1,11 +1,11 @@
-import { Injectable } from '@nestjs/common';
-
-@Injectable()
-export class HealthService {
-  getHealthStatus() {
-    return {
-      status: 'ok',
-      time: new Date().toISOString(),
-    };
-  }
-}
+import { Injectable } from '@nestjs/common';
+
+@Injectable()
+export class HealthService {
+  getHealthStatus() {
+    return {
+      status: 'ok',
+      time: new Date().toISOString(),
+    };
+  }
+}
diff --git a/apps/api/src/mail/mail.module.ts b/apps/api/src/mail/mail.module.ts
index 8986a47..a5c48c4 100644
--- a/apps/api/src/mail/mail.module.ts
+++ b/apps/api/src/mail/mail.module.ts
@@ -1,6 +1,6 @@
 import { Module } from '@nestjs/common';
 import { ConfigModule, ConfigService } from '@nestjs/config';
-import { MailService } from './mail.service';
+import { MailService } from '@app/mail/mail.service';
 
 @Module({
   imports: [ConfigModule],
diff --git a/apps/api/src/mail/mail.service.ts b/apps/api/src/mail/mail.service.ts
index 848885f..d629ac7 100644
--- a/apps/api/src/mail/mail.service.ts
+++ b/apps/api/src/mail/mail.service.ts
@@ -1,6 +1,6 @@
 import { Inject, Injectable } from '@nestjs/common';
 import { ConfigService } from '@nestjs/config';
-import { welcomeHtml } from './templates/welcome';
+import { welcomeHtml } from '@app/mail/templates/welcome';
 
 /** Minimal Nodemailer typings */
 type MailAddress = string | { name?: string; address: string };
diff --git a/apps/api/src/mail/templates/welcome.ts b/apps/api/src/mail/templates/welcome.ts
index acafbe0..93381fd 100644
--- a/apps/api/src/mail/templates/welcome.ts
+++ b/apps/api/src/mail/templates/welcome.ts
@@ -1,13 +1,13 @@
-export const welcomeHtml = (displayName?: string) => `
-<div dir="rtl" style="font-family:Tahoma,Arial,sans-serif;background:#f7f7f8;padding:24px;">
-  <div style="max-width:600px;margin:auto;background:#fff;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,.06);padding:28px;">
-    <h2 style="margin:0 0 16px;text-align:center;color:#222;">به نگاره خوش آمدید ✨</h2>
-    <p style="margin:0 0 12px;color:#333;line-height:2;">
-      ${displayName ? `سلام <b>${displayName}</b> عزیز،` : `سلام کاربر عزیز نگاره،`}
-      از اینکه به نگاره پیوستید خوشحالیم. حساب شما با موفقیت فعال شد.
-    </p>
-    <p style="margin:0 0 12px;color:#555;line-height:2;">می‌توانید از بخش ورود با ایمیل/موبایل و رمز تازه وارد شوید.</p>
-    <hr style="border:none;border-top:1px solid #eee;margin:24px 0;">
-    <p style="margin:0;text-align:center;color:#888;">با احترام 🌿 تیم نگاره</p>
-  </div>
-</div>`;
+export const welcomeHtml = (displayName?: string) => `
+<div dir="rtl" style="font-family:Tahoma,Arial,sans-serif;background:#f7f7f8;padding:24px;">
+  <div style="max-width:600px;margin:auto;background:#fff;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,.06);padding:28px;">
+    <h2 style="margin:0 0 16px;text-align:center;color:#222;">به نگاره خوش آمدید ✨</h2>
+    <p style="margin:0 0 12px;color:#333;line-height:2;">
+      ${displayName ? `سلام <b>${displayName}</b> عزیز،` : `سلام کاربر عزیز نگاره،`}
+      از اینکه به نگاره پیوستید خوشحالیم. حساب شما با موفقیت فعال شد.
+    </p>
+    <p style="margin:0 0 12px;color:#555;line-height:2;">می‌توانید از بخش ورود با ایمیل/موبایل و رمز تازه وارد شوید.</p>
+    <hr style="border:none;border-top:1px solid #eee;margin:24px 0;">
+    <p style="margin:0;text-align:center;color:#888;">با احترام 🌿 تیم نگاره</p>
+  </div>
+</div>`;
diff --git a/apps/api/src/main.ts b/apps/api/src/main.ts
index 8a5af0c..e678ba6 100644
--- a/apps/api/src/main.ts
+++ b/apps/api/src/main.ts
@@ -4,11 +4,11 @@ import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
 import cookieParser from 'cookie-parser';
 import helmet from 'helmet';
 import { ConfigService } from '@nestjs/config';
-import { AppModule } from './app.module';
-import { HttpExceptionFilter } from './common/filters/http-exception.filter';
-import { TransformResponseInterceptor } from './common/interceptors/transform-response.interceptor';
-import { TracingInterceptor } from './common/interceptors/tracing.interceptor';
-import { AllConfig } from './config/config.module';
+import { AppModule } from '@app/app.module';
+import { HttpExceptionFilter } from '@app/common/filters/http-exception.filter';
+import { TransformResponseInterceptor } from '@app/common/interceptors/transform-response.interceptor';
+import { TracingInterceptor } from '@app/common/interceptors/tracing.interceptor';
+import { AllConfig } from '@app/config/config.module';
 import type { Request, Response, NextFunction } from 'express';
 
 async function bootstrap() {
diff --git a/apps/api/src/notifications/adapters/fake-email.adapter.ts b/apps/api/src/notifications/adapters/fake-email.adapter.ts
index 785a5bf..37fbbc3 100644
--- a/apps/api/src/notifications/adapters/fake-email.adapter.ts
+++ b/apps/api/src/notifications/adapters/fake-email.adapter.ts
@@ -1,5 +1,5 @@
 import { Injectable, Logger } from '@nestjs/common';
-import { EmailPort } from '../ports/email.port';
+import { EmailPort } from '@app/notifications/ports/email.port';
 
 @Injectable()
 export class FakeEmailAdapter implements EmailPort {
diff --git a/apps/api/src/notifications/adapters/fake-sms.adapter.ts b/apps/api/src/notifications/adapters/fake-sms.adapter.ts
index 5e84028..b3122bf 100644
--- a/apps/api/src/notifications/adapters/fake-sms.adapter.ts
+++ b/apps/api/src/notifications/adapters/fake-sms.adapter.ts
@@ -1,5 +1,5 @@
 import { Injectable, Logger } from '@nestjs/common';
-import { SmsPort } from '../ports/sms.port';
+import { SmsPort } from '@app/notifications/ports/sms.port';
 
 @Injectable()
 export class FakeSmsAdapter implements SmsPort {
diff --git a/apps/api/src/notifications/notifications.constants.ts b/apps/api/src/notifications/notifications.constants.ts
index f992ebd..970fdac 100644
--- a/apps/api/src/notifications/notifications.constants.ts
+++ b/apps/api/src/notifications/notifications.constants.ts
@@ -1,2 +1,2 @@
-export const SMS_PORT = Symbol('SMS_PORT');
-export const EMAIL_PORT = Symbol('EMAIL_PORT');
+export const SMS_PORT = Symbol('SMS_PORT');
+export const EMAIL_PORT = Symbol('EMAIL_PORT');
diff --git a/apps/api/src/notifications/notifications.module.ts b/apps/api/src/notifications/notifications.module.ts
index dfe4768..0eb7f6f 100644
--- a/apps/api/src/notifications/notifications.module.ts
+++ b/apps/api/src/notifications/notifications.module.ts
@@ -1,7 +1,7 @@
 import { Module } from '@nestjs/common';
-import { EMAIL_PORT, SMS_PORT } from './notifications.constants';
-import { FakeEmailAdapter } from './adapters/fake-email.adapter';
-import { FakeSmsAdapter } from './adapters/fake-sms.adapter';
+import { EMAIL_PORT, SMS_PORT } from '@app/notifications/notifications.constants';
+import { FakeEmailAdapter } from '@app/notifications/adapters/fake-email.adapter';
+import { FakeSmsAdapter } from '@app/notifications/adapters/fake-sms.adapter';
 
 @Module({
   providers: [
diff --git a/apps/api/src/notifications/ports/email.port.ts b/apps/api/src/notifications/ports/email.port.ts
index a457854..879af43 100644
--- a/apps/api/src/notifications/ports/email.port.ts
+++ b/apps/api/src/notifications/ports/email.port.ts
@@ -1,3 +1,3 @@
-export interface EmailPort {
-  send(to: string, subject: string, html: string): Promise<void>;
-}
+export interface EmailPort {
+  send(to: string, subject: string, html: string): Promise<void>;
+}
diff --git a/apps/api/src/notifications/ports/sms.port.ts b/apps/api/src/notifications/ports/sms.port.ts
index 97ef5f5..fee3254 100644
--- a/apps/api/src/notifications/ports/sms.port.ts
+++ b/apps/api/src/notifications/ports/sms.port.ts
@@ -1,7 +1,7 @@
-export interface SmsPort {
-  send(
-    to: string,
-    template: string,
-    params: Record<string, string>,
-  ): Promise<void>;
-}
+export interface SmsPort {
+  send(
+    to: string,
+    template: string,
+    params: Record<string, string>,
+  ): Promise<void>;
+}
diff --git a/apps/api/src/prisma/prisma.module.ts b/apps/api/src/prisma/prisma.module.ts
index 7207426..1cde161 100644
--- a/apps/api/src/prisma/prisma.module.ts
+++ b/apps/api/src/prisma/prisma.module.ts
@@ -1,5 +1,5 @@
 import { Global, Module } from '@nestjs/common';
-import { PrismaService } from './prisma.service';
+import { PrismaService } from '@app/prisma/prisma.service';
 
 @Global()
 @Module({
diff --git a/apps/api/src/prisma/prisma.service.ts b/apps/api/src/prisma/prisma.service.ts
index 6968c36..29df1a6 100644
--- a/apps/api/src/prisma/prisma.service.ts
+++ b/apps/api/src/prisma/prisma.service.ts
@@ -1,19 +1,19 @@
-import { INestApplication, Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common';
-import { PrismaClient } from '@prisma/client';
-
-@Injectable()
-export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
-  async onModuleInit(): Promise<void> {
-    await this.$connect();
-  }
-
-  async onModuleDestroy(): Promise<void> {
-    await this.$disconnect();
-  }
-
-  async enableShutdownHooks(app: INestApplication): Promise<void> {
-    process.on('beforeExit', async () => {
-      await app.close();
-    });
-  }
-}
+import { INestApplication, Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common';
+import { PrismaClient } from '@prisma/client';
+
+@Injectable()
+export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
+  async onModuleInit(): Promise<void> {
+    await this.$connect();
+  }
+
+  async onModuleDestroy(): Promise<void> {
+    await this.$disconnect();
+  }
+
+  async enableShutdownHooks(app: INestApplication): Promise<void> {
+    process.on('beforeExit', async () => {
+      await app.close();
+    });
+  }
+}
diff --git a/apps/api/src/redis/redis.module.ts b/apps/api/src/redis/redis.module.ts
index e78b4c9..f9ef662 100644
--- a/apps/api/src/redis/redis.module.ts
+++ b/apps/api/src/redis/redis.module.ts
@@ -1,22 +1,22 @@
-import { Module } from '@nestjs/common';
-import { ConfigModule, ConfigService } from '@nestjs/config';
-import Redis from 'ioredis';
-import { AllConfig } from '@app/config/config.module';
-
-@Module({
-  imports: [ConfigModule],
-  providers: [
-    {
-      provide: 'REDIS',
-      inject: [ConfigService],
-      useFactory: (cfg: ConfigService<AllConfig>) => {
-        const url =
-          cfg.get<string>('REDIS_URL', { infer: true }) ??
-          'redis://localhost:6379';
-        return new Redis(url, { lazyConnect: true });
-      },
-    },
-  ],
-  exports: ['REDIS'],
-})
-export class RedisModule {}
+import { Module } from '@nestjs/common';
+import { ConfigModule, ConfigService } from '@nestjs/config';
+import Redis from 'ioredis';
+import { AllConfig } from '@app/config/config.module';
+
+@Module({
+  imports: [ConfigModule],
+  providers: [
+    {
+      provide: 'REDIS',
+      inject: [ConfigService],
+      useFactory: (cfg: ConfigService<AllConfig>) => {
+        const url =
+          cfg.get<string>('REDIS_URL', { infer: true }) ??
+          'redis://localhost:6379';
+        return new Redis(url, { lazyConnect: true });
+      },
+    },
+  ],
+  exports: ['REDIS'],
+})
+export class RedisModule {}
diff --git a/apps/api/src/shared/base.entity.ts b/apps/api/src/shared/base.entity.ts
index 2f7e79f..071f453 100644
--- a/apps/api/src/shared/base.entity.ts
+++ b/apps/api/src/shared/base.entity.ts
@@ -1,25 +1,25 @@
-import { randomUUID } from 'node:crypto';
-import {
-  BeforeInsert,
-  CreateDateColumn,
-  PrimaryGeneratedColumn,
-  UpdateDateColumn,
-} from 'typeorm';
-
-export abstract class BaseEntity {
-  @PrimaryGeneratedColumn('uuid')
-  id: string;
-
-  @CreateDateColumn({ type: 'timestamptz' })
-  createdAt: Date;
-
-  @UpdateDateColumn({ type: 'timestamptz' })
-  updatedAt: Date;
-
-  @BeforeInsert()
-  protected ensureId() {
-    if (!this.id) {
-      this.id = randomUUID();
-    }
-  }
-}
+import { randomUUID } from 'node:crypto';
+import {
+  BeforeInsert,
+  CreateDateColumn,
+  PrimaryGeneratedColumn,
+  UpdateDateColumn,
+} from 'typeorm';
+
+export abstract class BaseEntity {
+  @PrimaryGeneratedColumn('uuid')
+  id: string;
+
+  @CreateDateColumn({ type: 'timestamptz' })
+  createdAt: Date;
+
+  @UpdateDateColumn({ type: 'timestamptz' })
+  updatedAt: Date;
+
+  @BeforeInsert()
+  protected ensureId() {
+    if (!this.id) {
+      this.id = randomUUID();
+    }
+  }
+}
diff --git a/apps/api/src/shared/utils/parse-duration.util.ts b/apps/api/src/shared/utils/parse-duration.util.ts
index 663b757..3f344bd 100644
--- a/apps/api/src/shared/utils/parse-duration.util.ts
+++ b/apps/api/src/shared/utils/parse-duration.util.ts
@@ -1,34 +1,34 @@
-const DEFAULT_UNIT = 's';
-
-const UNIT_IN_SECONDS: Record<string, number> = {
-  s: 1,
-  m: 60,
-  h: 3600,
-  d: 86400,
-};
-
-/**
- * Parses duration strings like "10m", "1h", "30d" or numeric seconds into seconds.
- * Falls back to the provided default when the input is empty or invalid.
- */
-export function parseDurationToSeconds(
-  input: string | null | undefined,
-  defaultSeconds = 600,
-): number {
-  if (!input) {
-    return defaultSeconds;
-  }
-
-  const trimmed = input.trim().toLowerCase();
-  const match = trimmed.match(/^(\d+)([smhd])?$/);
-  if (!match) {
-    const numeric = Number(trimmed);
-    return Number.isFinite(numeric) ? numeric : defaultSeconds;
-  }
-
-  const value = Number(match[1]);
-  const unit = match[2] ?? DEFAULT_UNIT;
-  const multiplier = UNIT_IN_SECONDS[unit] ?? UNIT_IN_SECONDS[DEFAULT_UNIT];
-
-  return value * multiplier;
-}
+const DEFAULT_UNIT = 's';
+
+const UNIT_IN_SECONDS: Record<string, number> = {
+  s: 1,
+  m: 60,
+  h: 3600,
+  d: 86400,
+};
+
+/**
+ * Parses duration strings like "10m", "1h", "30d" or numeric seconds into seconds.
+ * Falls back to the provided default when the input is empty or invalid.
+ */
+export function parseDurationToSeconds(
+  input: string | null | undefined,
+  defaultSeconds = 600,
+): number {
+  if (!input) {
+    return defaultSeconds;
+  }
+
+  const trimmed = input.trim().toLowerCase();
+  const match = trimmed.match(/^(\d+)([smhd])?$/);
+  if (!match) {
+    const numeric = Number(trimmed);
+    return Number.isFinite(numeric) ? numeric : defaultSeconds;
+  }
+
+  const value = Number(match[1]);
+  const unit = match[2] ?? DEFAULT_UNIT;
+  const multiplier = UNIT_IN_SECONDS[unit] ?? UNIT_IN_SECONDS[DEFAULT_UNIT];
+
+  return value * multiplier;
+}
diff --git a/apps/api/src/sms/sms.module.ts b/apps/api/src/sms/sms.module.ts
index 5a44a24..dff8a3a 100644
--- a/apps/api/src/sms/sms.module.ts
+++ b/apps/api/src/sms/sms.module.ts
@@ -1,6 +1,7 @@
 import { Module } from '@nestjs/common';
 import { ConfigModule, ConfigService } from '@nestjs/config';
-import { SmsService } from './sms.service';
+import Kavenegar = require('kavenegar');
+import { SmsService } from '@app/sms/sms.service';
 
 @Module({
   imports: [ConfigModule],
@@ -9,13 +10,13 @@ import { SmsService } from './sms.service';
     {
       provide: 'KAVENEGAR_CLIENT',
       inject: [ConfigService],
-      useFactory: (config: ConfigService) => {
-        // eslint-disable-next-line @typescript-eslint/no-var-requires
-        const { KavenegarApi } = require('../vendors/kavenegar');
-        return KavenegarApi({ apikey: config.get<string>('KAVENEGAR_API_KEY') });
-      },
+      useFactory: (config: ConfigService) =>
+        Kavenegar.KavenegarApi({
+          apikey: config.get<string>('KAVENEGAR_API_KEY'),
+        }),
     },
   ],
+
   exports: [SmsService],
 })
 export class SmsModule {}
diff --git a/apps/api/src/sms/sms.service.ts b/apps/api/src/sms/sms.service.ts
index 2d99683..da2443a 100644
--- a/apps/api/src/sms/sms.service.ts
+++ b/apps/api/src/sms/sms.service.ts
@@ -1,101 +1,101 @@
-import { Inject, Injectable } from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-
-/** Minimal typings for Kavenegar VerifyLookup callback payload */
-type KavenegarVerifyLookupEntry = {
-  messageid?: number | string;
-  status?: number;
-  statustext?: string;
-  receptor?: string;
-  date?: number;
-  cost?: number;
-};
-
-type KavenegarVerifyLookupResponse = {
-  entries?: KavenegarVerifyLookupEntry[];
-};
-
-type KavenegarVerifyLookupParams = {
-  receptor: string;
-  token: string;
-  template: string;
-  type?: 'sms' | 'call';
-};
-
-interface KavenegarClient {
-  VerifyLookup(
-    params: KavenegarVerifyLookupParams,
-    cb: (
-      resp: KavenegarVerifyLookupResponse,
-      status: number,
-      message?: string,
-    ) => void,
-  ): void;
-}
-
-@Injectable()
-export class SmsService {
-  private readonly template: string;
-  private readonly timeoutMs: number;
-
-  constructor(
-    @Inject('KAVENEGAR_CLIENT') private readonly kaveClient: KavenegarClient,
-    private readonly config: ConfigService,
-  ) {
-    this.template = this.config.get<string>('KAVENEGAR_TEMPLATE') ?? 'sendSMS';
-    this.timeoutMs = Number(this.config.get('KAVENEGAR_TIMEOUT_MS') ?? 10000);
-  }
-
-  /**
-   * Sends an OTP via Kavenegar VerifyLookup.
-   * Returns provider messageId (if present) so callers can persist it; otherwise resolves to void.
-   * Throws with a descriptive error when the provider returns non-200 status or the call times out.
-   */
-  async sendOtp(phone: string, code: string): Promise<string | void> {
-    const receptor = this.normalizePhone(phone);
-
-    return new Promise<string | void>((resolve, reject) => {
-      let settled = false;
-
-      const timer = setTimeout(() => {
-        if (!settled) {
-          settled = true;
-          reject(new Error('Kavenegar timeout'));
-        }
-      }, this.timeoutMs);
-
-      this.kaveClient.VerifyLookup(
-        { receptor, token: code, template: this.template, type: 'sms' },
-        (resp, status, message) => {
-          if (settled) return;
-          settled = true;
-          clearTimeout(timer);
-
-          if (status !== 200) {
-            reject(new Error(message || `Kavenegar error (status ${status})`));
-            return;
-          }
-
-          const msgId =
-            resp?.entries && resp.entries.length > 0
-              ? resp.entries[0]?.messageid
-              : undefined;
-
-          if (typeof msgId === 'number' || typeof msgId === 'string') {
-            resolve(String(msgId));
-          } else {
-            resolve(); // delivered but no messageId available
-          }
-        },
-      );
-    });
-  }
-
-  /** Basic normalizer; adapt to E.164 if needed */
-  private normalizePhone(input: string): string {
-    const v = input.trim();
-    // Example normalization: convert +98xxxxxxxxxx to 09xxxxxxxxx if you prefer local format.
-    // For now, return as-is; you can enforce your preferred format here.
-    return v;
-  }
-}
+import { Inject, Injectable } from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+
+/** Minimal typings for Kavenegar VerifyLookup callback payload */
+type KavenegarVerifyLookupEntry = {
+  messageid?: number | string;
+  status?: number;
+  statustext?: string;
+  receptor?: string;
+  date?: number;
+  cost?: number;
+};
+
+type KavenegarVerifyLookupResponse = {
+  entries?: KavenegarVerifyLookupEntry[];
+};
+
+type KavenegarVerifyLookupParams = {
+  receptor: string;
+  token: string;
+  template: string;
+  type?: 'sms' | 'call';
+};
+
+interface KavenegarClient {
+  VerifyLookup(
+    params: KavenegarVerifyLookupParams,
+    cb: (
+      resp: KavenegarVerifyLookupResponse,
+      status: number,
+      message?: string,
+    ) => void,
+  ): void;
+}
+
+@Injectable()
+export class SmsService {
+  private readonly template: string;
+  private readonly timeoutMs: number;
+
+  constructor(
+    @Inject('KAVENEGAR_CLIENT') private readonly kaveClient: KavenegarClient,
+    private readonly config: ConfigService,
+  ) {
+    this.template = this.config.get<string>('KAVENEGAR_TEMPLATE') ?? 'sendSMS';
+    this.timeoutMs = Number(this.config.get('KAVENEGAR_TIMEOUT_MS') ?? 10000);
+  }
+
+  /**
+   * Sends an OTP via Kavenegar VerifyLookup.
+   * Returns provider messageId (if present) so callers can persist it; otherwise resolves to void.
+   * Throws with a descriptive error when the provider returns non-200 status or the call times out.
+   */
+  async sendOtp(phone: string, code: string): Promise<string | void> {
+    const receptor = this.normalizePhone(phone);
+
+    return new Promise<string | void>((resolve, reject) => {
+      let settled = false;
+
+      const timer = setTimeout(() => {
+        if (!settled) {
+          settled = true;
+          reject(new Error('Kavenegar timeout'));
+        }
+      }, this.timeoutMs);
+
+      this.kaveClient.VerifyLookup(
+        { receptor, token: code, template: this.template, type: 'sms' },
+        (resp, status, message) => {
+          if (settled) return;
+          settled = true;
+          clearTimeout(timer);
+
+          if (status !== 200) {
+            reject(new Error(message || `Kavenegar error (status ${status})`));
+            return;
+          }
+
+          const msgId =
+            resp?.entries && resp.entries.length > 0
+              ? resp.entries[0]?.messageid
+              : undefined;
+
+          if (typeof msgId === 'number' || typeof msgId === 'string') {
+            resolve(String(msgId));
+          } else {
+            resolve(); // delivered but no messageId available
+          }
+        },
+      );
+    });
+  }
+
+  /** Basic normalizer; adapt to E.164 if needed */
+  private normalizePhone(input: string): string {
+    const v = input.trim();
+    // Example normalization: convert +98xxxxxxxxxx to 09xxxxxxxxx if you prefer local format.
+    // For now, return as-is; you can enforce your preferred format here.
+    return v;
+  }
+}
diff --git a/apps/api/src/tests/e2e/core.e2e-spec.ts b/apps/api/src/tests/e2e/core.e2e-spec.ts
index 45442b0..b3a715c 100644
--- a/apps/api/src/tests/e2e/core.e2e-spec.ts
+++ b/apps/api/src/tests/e2e/core.e2e-spec.ts
@@ -10,13 +10,13 @@ import pg from 'pg';
 import bcrypt from 'bcrypt';
 import cookieParser from 'cookie-parser';
 import { AuthModule } from '@app/core/auth/auth.module';
-import { CoreModule } from '../../core/core.module';
+import { CoreModule } from '@app/core/core.module';
 import { User } from '@app/core/users/user.entity';
 import { Role } from '@app/core/roles/entities/role.entity';
 import { UserRole } from '@app/core/roles/entities/user-role.entity';
 import { Wallet } from '@app/core/wallet/wallet.entity';
 import { WalletTransaction } from '@app/core/wallet/wallet-transaction.entity';
-import { NotificationsModule } from '../../notifications/notifications.module';
+import { NotificationsModule } from '@app/notifications/notifications.module';
 import { HttpExceptionFilter } from '@app/common/filters/http-exception.filter';
 import { TracingInterceptor } from '@app/common/interceptors/tracing.interceptor';
 import { TransformResponseInterceptor } from '@app/common/interceptors/transform-response.interceptor';
diff --git a/apps/api/src/tests/e2e/types/pg.d.ts b/apps/api/src/tests/e2e/types/pg.d.ts
index ea2c34a..500bd53 100644
--- a/apps/api/src/tests/e2e/types/pg.d.ts
+++ b/apps/api/src/tests/e2e/types/pg.d.ts
@@ -1 +1 @@
-declare module 'pg';
+declare module 'pg';
diff --git a/apps/api/src/tests/unit/catalog/bookmarks.service.spec.ts b/apps/api/src/tests/unit/catalog/bookmarks.service.spec.ts
index 871294e..bdd76f5 100644
--- a/apps/api/src/tests/unit/catalog/bookmarks.service.spec.ts
+++ b/apps/api/src/tests/unit/catalog/bookmarks.service.spec.ts
@@ -1,6 +1,6 @@
 import { BookmarksService } from '@app/catalog/bookmarks/bookmarks.service';
 import { PricingType } from '@app/prisma/prisma.constants';
-import { createCatalogPrismaStub, CatalogPrismaStub } from '../../utils/prisma-catalog.stub';
+import { createCatalogPrismaStub, CatalogPrismaStub } from '@app/tests/utils/prisma-catalog.stub';
 
 describe('BookmarksService', () => {
   let prisma: CatalogPrismaStub;
diff --git a/apps/api/src/tests/unit/catalog/downloads.service.spec.ts b/apps/api/src/tests/unit/catalog/downloads.service.spec.ts
index 6f1be16..eaaafb5 100644
--- a/apps/api/src/tests/unit/catalog/downloads.service.spec.ts
+++ b/apps/api/src/tests/unit/catalog/downloads.service.spec.ts
@@ -2,7 +2,7 @@ import { HttpStatus, UnauthorizedException } from '@nestjs/common';
 import { Readable } from 'node:stream';
 import { DownloadsService } from '@app/catalog/downloads/downloads.service';
 import { PricingType } from '@app/prisma/prisma.constants';
-import { createCatalogPrismaStub, CatalogPrismaStub } from '../../utils/prisma-catalog.stub';
+import { createCatalogPrismaStub, CatalogPrismaStub } from '@app/tests/utils/prisma-catalog.stub';
 
 const userId = 'download-user';
 
diff --git a/apps/api/src/tests/unit/catalog/likes.service.spec.ts b/apps/api/src/tests/unit/catalog/likes.service.spec.ts
index 5ce3721..31f486b 100644
--- a/apps/api/src/tests/unit/catalog/likes.service.spec.ts
+++ b/apps/api/src/tests/unit/catalog/likes.service.spec.ts
@@ -1,6 +1,6 @@
 import { LikesService } from '@app/catalog/likes/likes.service';
 import { PricingType } from '@app/prisma/prisma.constants';
-import { createCatalogPrismaStub, CatalogPrismaStub } from '../../utils/prisma-catalog.stub';
+import { createCatalogPrismaStub, CatalogPrismaStub } from '@app/tests/utils/prisma-catalog.stub';
 
 describe('LikesService', () => {
   let prisma: CatalogPrismaStub;
diff --git a/apps/api/src/tests/unit/catalog/local-storage.service.spec.ts b/apps/api/src/tests/unit/catalog/local-storage.service.spec.ts
index 5bbc2ba..09a6acb 100644
--- a/apps/api/src/tests/unit/catalog/local-storage.service.spec.ts
+++ b/apps/api/src/tests/unit/catalog/local-storage.service.spec.ts
@@ -2,8 +2,8 @@ import { Readable } from 'node:stream';
 import { access } from 'node:fs/promises';
 import { constants } from 'node:fs';
 import { join } from 'node:path';
-import { UploadedFile } from '../../../catalog/storage/storage.service';
-import { LocalStorageService } from '../../../catalog/storage/local-storage.service';
+import { UploadedFile } from '@app/catalog/storage/storage.service';
+import { LocalStorageService } from '@app/catalog/storage/local-storage.service';
 
 describe('LocalStorageService', () => {
   const storage = new LocalStorageService();
diff --git a/apps/api/src/tests/unit/catalog/products.service.spec.ts b/apps/api/src/tests/unit/catalog/products.service.spec.ts
index 89bce54..7638722 100644
--- a/apps/api/src/tests/unit/catalog/products.service.spec.ts
+++ b/apps/api/src/tests/unit/catalog/products.service.spec.ts
@@ -1,105 +1,105 @@
-import { ProductsService } from '@app/catalog/product/product.service';
-import { CountersService } from '@app/catalog/counters/counters.service';
-import { PricingType } from '@app/prisma/prisma.constants';
-import type { ProductWithRelations } from '@app/catalog/product/product.mapper';
-
-const createProduct = (id: bigint): ProductWithRelations =>
-  ({
-    id,
-    slug: `product-${id}`,
-    title: 'Demo',
-    description: null,
-    coverUrl: null,
-    pricingType: PricingType.FREE,
-    price: null,
-    active: true,
-    publishedAt: null,
-    viewsCount: 0,
-    downloadsCount: 0,
-    likesCount: 0,
-    createdAt: new Date(),
-    updatedAt: new Date(),
-    file: null,
-    assets: [],
-    categoryLinks: [],
-    tagLinks: [],
-    supplierLinks: [],
-  }) as unknown as ProductWithRelations;
-
-describe('ProductsService.decorateProductWithUserState', () => {
-  const prisma = {
-    product: { findMany: jest.fn() },
-    productView: { create: jest.fn() },
-    $transaction: jest.fn().mockResolvedValue([0, []]),
-  } as any;
-  const countersService = {
-    incrementViews: jest.fn(),
-  } as unknown as CountersService;
-  const likesService = {
-    isProductLiked: jest.fn().mockResolvedValue(false),
-  };
-  const bookmarksService = {
-    isBookmarked: jest.fn().mockResolvedValue(false),
-  };
-  const storageService = {
-    saveUploadedFile: jest.fn(),
-    getDownloadStream: jest.fn(),
-    getDownloadUrl: jest.fn(),
-    deleteFile: jest.fn(),
-  };
-
-  const service = new ProductsService(
-    prisma,
-    countersService,
-    likesService as any,
-    bookmarksService as any,
-    storageService as any,
-  );
-
-  afterEach(() => {
-    jest.resetAllMocks();
-  });
-
-  it('returns false flags for anonymous users', async () => {
-    const product = createProduct(10n);
-
-    const result = await service.decorateProductWithUserState(
-      product,
-      undefined,
-    );
-
-    expect(result.liked).toBe(false);
-    expect(result.bookmarked).toBe(false);
-    expect(likesService.isProductLiked).not.toHaveBeenCalled();
-    expect(bookmarksService.isBookmarked).not.toHaveBeenCalled();
-  });
-
-  it('resolves liked and bookmarked flags for authenticated users', async () => {
-    const product = createProduct(42n);
-
-    likesService.isProductLiked.mockResolvedValueOnce(true);
-    bookmarksService.isBookmarked.mockResolvedValueOnce(false);
-
-    const result = await service.decorateProductWithUserState(product, {
-      id: 'user-1',
-      roles: ['USER'],
-    });
-
-    expect(result.liked).toBe(true);
-    expect(result.bookmarked).toBe(false);
-    expect(likesService.isProductLiked).toHaveBeenCalledWith('user-1', '42');
-    expect(bookmarksService.isBookmarked).toHaveBeenCalledWith('user-1', '42');
-  });
-
-  it('requires price for paid products', () => {
-    expect(() =>
-      (service as any).validatePricing(PricingType.PAID, undefined),
-    ).toThrow('Price is required for paid pricing types');
-  });
-
-  it('forbids price for free products', () => {
-    expect(() =>
-      (service as any).validatePricing(PricingType.FREE, '12.00'),
-    ).toThrow('Price must be omitted for free products');
-  });
-});
+import { ProductsService } from '@app/catalog/product/product.service';
+import { CountersService } from '@app/catalog/counters/counters.service';
+import { PricingType } from '@app/prisma/prisma.constants';
+import type { ProductWithRelations } from '@app/catalog/product/product.mapper';
+
+const createProduct = (id: bigint): ProductWithRelations =>
+  ({
+    id,
+    slug: `product-${id}`,
+    title: 'Demo',
+    description: null,
+    coverUrl: null,
+    pricingType: PricingType.FREE,
+    price: null,
+    active: true,
+    publishedAt: null,
+    viewsCount: 0,
+    downloadsCount: 0,
+    likesCount: 0,
+    createdAt: new Date(),
+    updatedAt: new Date(),
+    file: null,
+    assets: [],
+    categoryLinks: [],
+    tagLinks: [],
+    supplierLinks: [],
+  }) as unknown as ProductWithRelations;
+
+describe('ProductsService.decorateProductWithUserState', () => {
+  const prisma = {
+    product: { findMany: jest.fn() },
+    productView: { create: jest.fn() },
+    $transaction: jest.fn().mockResolvedValue([0, []]),
+  } as any;
+  const countersService = {
+    incrementViews: jest.fn(),
+  } as unknown as CountersService;
+  const likesService = {
+    isProductLiked: jest.fn().mockResolvedValue(false),
+  };
+  const bookmarksService = {
+    isBookmarked: jest.fn().mockResolvedValue(false),
+  };
+  const storageService = {
+    saveUploadedFile: jest.fn(),
+    getDownloadStream: jest.fn(),
+    getDownloadUrl: jest.fn(),
+    deleteFile: jest.fn(),
+  };
+
+  const service = new ProductsService(
+    prisma,
+    countersService,
+    likesService as any,
+    bookmarksService as any,
+    storageService as any,
+  );
+
+  afterEach(() => {
+    jest.resetAllMocks();
+  });
+
+  it('returns false flags for anonymous users', async () => {
+    const product = createProduct(10n);
+
+    const result = await service.decorateProductWithUserState(
+      product,
+      undefined,
+    );
+
+    expect(result.liked).toBe(false);
+    expect(result.bookmarked).toBe(false);
+    expect(likesService.isProductLiked).not.toHaveBeenCalled();
+    expect(bookmarksService.isBookmarked).not.toHaveBeenCalled();
+  });
+
+  it('resolves liked and bookmarked flags for authenticated users', async () => {
+    const product = createProduct(42n);
+
+    likesService.isProductLiked.mockResolvedValueOnce(true);
+    bookmarksService.isBookmarked.mockResolvedValueOnce(false);
+
+    const result = await service.decorateProductWithUserState(product, {
+      id: 'user-1',
+      roles: ['USER'],
+    });
+
+    expect(result.liked).toBe(true);
+    expect(result.bookmarked).toBe(false);
+    expect(likesService.isProductLiked).toHaveBeenCalledWith('user-1', '42');
+    expect(bookmarksService.isBookmarked).toHaveBeenCalledWith('user-1', '42');
+  });
+
+  it('requires price for paid products', () => {
+    expect(() =>
+      (service as any).validatePricing(PricingType.PAID, undefined),
+    ).toThrow('Price is required for paid pricing types');
+  });
+
+  it('forbids price for free products', () => {
+    expect(() =>
+      (service as any).validatePricing(PricingType.FREE, '12.00'),
+    ).toThrow('Price must be omitted for free products');
+  });
+});
diff --git a/apps/api/src/tests/unit/users.service.spec.ts b/apps/api/src/tests/unit/users.service.spec.ts
index a4035a1..ffb7867 100644
--- a/apps/api/src/tests/unit/users.service.spec.ts
+++ b/apps/api/src/tests/unit/users.service.spec.ts
@@ -1,89 +1,89 @@
-import { UsersService } from '@app/core/users/users.service';
-import { PrismaService } from '@app/prisma/prisma.service';
-
-const createPrismaMock = () =>
-  ({
-    user: {
-      findMany: jest.fn(),
-      findUnique: jest.fn(),
-      create: jest.fn(),
-      update: jest.fn(),
-    },
-  } as unknown as PrismaService);
-
-describe('UsersService', () => {
-  let prisma: PrismaService;
-  let service: UsersService;
-
-  beforeEach(() => {
-    prisma = createPrismaMock();
-    service = new UsersService(prisma);
-  });
-
-  afterEach(() => {
-    jest.resetAllMocks();
-  });
-
-  it('creates a user with hashed password', async () => {
-    (prisma.user.create as jest.Mock).mockImplementationOnce(async ({ data }) => ({
-      id: 'user-1',
-      ...data,
-      userRoles: [],
-      wallet: null,
-    }));
-
-    const result = await service.create({
-      username: 'john_doe',
-      email: 'john@example.com',
-      password: 'StrongPass123',
-    });
-
-    const call = (prisma.user.create as jest.Mock).mock.calls[0]?.[0];
-    expect(call.data.passwordHash).toHaveLength(64); // sha256 hex
-    expect(call.data.passwordHash).not.toEqual('StrongPass123');
-    expect(result.username).toBe('john_doe');
-  });
-
-  it('filters users via findAll', async () => {
-    (prisma.user.findMany as jest.Mock).mockResolvedValueOnce([
-      { id: 'user-1', username: 'active_user', userRoles: [], wallet: null },
-    ]);
-
-    const users = await service.findAll({
-      search: 'active',
-      limit: 10,
-    });
-
-    expect(prisma.user.findMany).toHaveBeenCalledWith(
-      expect.objectContaining({
-        where: expect.objectContaining({
-          OR: expect.arrayContaining([
-            expect.objectContaining({ username: expect.any(Object) }),
-          ]),
-        }),
-      }),
-    );
-    expect(users).toHaveLength(1);
-  });
-
-  it('updates user and re-hashes password when provided', async () => {
-    (prisma.user.findUnique as jest.Mock).mockResolvedValueOnce({
-      id: 'user-1',
-    });
-    (prisma.user.update as jest.Mock).mockImplementationOnce(async ({ data }) => ({
-      id: 'user-1',
-      ...data,
-      userRoles: [],
-      wallet: null,
-    }));
-
-    const updated = await service.update('user-1', {
-      email: 'new@example.com',
-      password: 'NewPass456',
-    });
-
-    const call = (prisma.user.update as jest.Mock).mock.calls[0]?.[0];
-    expect(call.data.passwordHash).toHaveLength(64);
-    expect(updated.email).toBe('new@example.com');
-  });
-});
+import { UsersService } from '@app/core/users/users.service';
+import { PrismaService } from '@app/prisma/prisma.service';
+
+const createPrismaMock = () =>
+  ({
+    user: {
+      findMany: jest.fn(),
+      findUnique: jest.fn(),
+      create: jest.fn(),
+      update: jest.fn(),
+    },
+  } as unknown as PrismaService);
+
+describe('UsersService', () => {
+  let prisma: PrismaService;
+  let service: UsersService;
+
+  beforeEach(() => {
+    prisma = createPrismaMock();
+    service = new UsersService(prisma);
+  });
+
+  afterEach(() => {
+    jest.resetAllMocks();
+  });
+
+  it('creates a user with hashed password', async () => {
+    (prisma.user.create as jest.Mock).mockImplementationOnce(async ({ data }) => ({
+      id: 'user-1',
+      ...data,
+      userRoles: [],
+      wallet: null,
+    }));
+
+    const result = await service.create({
+      username: 'john_doe',
+      email: 'john@example.com',
+      password: 'StrongPass123',
+    });
+
+    const call = (prisma.user.create as jest.Mock).mock.calls[0]?.[0];
+    expect(call.data.passwordHash).toHaveLength(64); // sha256 hex
+    expect(call.data.passwordHash).not.toEqual('StrongPass123');
+    expect(result.username).toBe('john_doe');
+  });
+
+  it('filters users via findAll', async () => {
+    (prisma.user.findMany as jest.Mock).mockResolvedValueOnce([
+      { id: 'user-1', username: 'active_user', userRoles: [], wallet: null },
+    ]);
+
+    const users = await service.findAll({
+      search: 'active',
+      limit: 10,
+    });
+
+    expect(prisma.user.findMany).toHaveBeenCalledWith(
+      expect.objectContaining({
+        where: expect.objectContaining({
+          OR: expect.arrayContaining([
+            expect.objectContaining({ username: expect.any(Object) }),
+          ]),
+        }),
+      }),
+    );
+    expect(users).toHaveLength(1);
+  });
+
+  it('updates user and re-hashes password when provided', async () => {
+    (prisma.user.findUnique as jest.Mock).mockResolvedValueOnce({
+      id: 'user-1',
+    });
+    (prisma.user.update as jest.Mock).mockImplementationOnce(async ({ data }) => ({
+      id: 'user-1',
+      ...data,
+      userRoles: [],
+      wallet: null,
+    }));
+
+    const updated = await service.update('user-1', {
+      email: 'new@example.com',
+      password: 'NewPass456',
+    });
+
+    const call = (prisma.user.update as jest.Mock).mock.calls[0]?.[0];
+    expect(call.data.passwordHash).toHaveLength(64);
+    expect(updated.email).toBe('new@example.com');
+  });
+});
diff --git a/apps/api/src/tests/unit/wallet-transactions.service.spec.ts b/apps/api/src/tests/unit/wallet-transactions.service.spec.ts
index c62c236..e55979d 100644
--- a/apps/api/src/tests/unit/wallet-transactions.service.spec.ts
+++ b/apps/api/src/tests/unit/wallet-transactions.service.spec.ts
@@ -7,7 +7,7 @@ import { WalletRateLimitService } from '@app/core/wallet/wallet-rate-limit.servi
 import {
   createWalletPrismaStub,
   WalletPrismaStub,
-} from '../utils/prisma-wallet.stub';
+} from '@app/tests/utils/prisma-wallet.stub';
 
 const userId = 'user-1';
 
diff --git a/apps/api/src/tests/unit/wallets.service.spec.ts b/apps/api/src/tests/unit/wallets.service.spec.ts
index 51519c9..37fd1b4 100644
--- a/apps/api/src/tests/unit/wallets.service.spec.ts
+++ b/apps/api/src/tests/unit/wallets.service.spec.ts
@@ -7,7 +7,7 @@ import { WalletRateLimitService } from '@app/core/wallet/wallet-rate-limit.servi
 import {
   createWalletPrismaStub,
   WalletPrismaStub,
-} from '../utils/prisma-wallet.stub';
+} from '@app/tests/utils/prisma-wallet.stub';
 
 const userId = 'user-1';
 
diff --git a/apps/api/src/vendors/kavenegar.d.ts b/apps/api/src/vendors/kavenegar.d.ts
deleted file mode 100644
index b01e550..0000000
--- a/apps/api/src/vendors/kavenegar.d.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-declare module '*/vendors/kavenegar' {
-  export function KavenegarApi(options: { apikey: string }): {
-    VerifyLookup(
-      params: {
-        receptor: string;
-        token?: string;
-        token2?: string;
-        token3?: string;
-        template: string;
-        type?: string;
-      },
-      cb: (entries: any, status: number, message?: any) => void
-    ): void;
-
-    Send(
-      params: { receptor: string; message: string; sender?: string },
-      cb: (entries: any, status: number, message?: any) => void
-    ): void;
-  };
-}
diff --git a/apps/api/src/vendors/kavenegar.js b/apps/api/src/vendors/kavenegar.js
deleted file mode 100644
index e691d3d..0000000
--- a/apps/api/src/vendors/kavenegar.js
+++ /dev/null
@@ -1,100 +0,0 @@
-var https = require('https');
-var querystring = require('querystring');
-var KavenegarApi = function(options) {
-  this.options = {};
-  this.options.host = 'api.kavenegar.com';
-  this.options.version = 'v1';
-  this.options.apikey = options.apikey;
-};
-KavenegarApi.prototype.request = function(action, method, params, callback) {
-  var path = '/' + this.options.version + '/' + this.options.apikey + '/' + action + '/' + method + '.json';
-  var postdata = querystring.stringify(params);
-  var post_options = {
-    host: this.options.host,
-    port: '443',
-    path: path,
-    method: 'POST',
-    headers: {
-      'Content-Length': postdata.length,
-      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
-    }
-  };
-  var req = https.request(post_options, function(e) {
-    e.setEncoding('utf8');
-    var result = '';
-    e.on('data', function(data) { result += data; });
-    e.on('end',function () {
-      try {
-        var jsonObject = JSON.parse(result);
-        if (callback) callback(
-          jsonObject.entries,
-          jsonObject.return.status,
-          jsonObject.return.message
-        );
-      } catch (e){
-        console.log('Exception!',e);
-        if(callback){ callback(e.message,500) }
-      }
-    })
-  });
-  req.write(postdata, "utf8");
-  req.on("error", function(e) {
-    if (callback) callback(JSON.stringify({ error: e.message }));
-  });
-  req.end();
-};
-KavenegarApi.prototype.Send = function(data, callback) {
-  this.request("sms", "send", data, callback);
-};
-KavenegarApi.prototype.SendArray = function(data, callback) {
-  this.request("sms", "sendarray", data, callback);
-};
-KavenegarApi.prototype.Status = function(data, callback) {
-  this.request("sms", "status", data, callback);
-};
-KavenegarApi.prototype.StatusLocalMessageid = function(data, callback) {
-  this.request("sms", "statuslocalmessageid", data, callback);
-};
-KavenegarApi.prototype.Select = function(data, callback) {
-  this.request("sms", "select", data, callback);
-};
-KavenegarApi.prototype.SelectOutbox = function(data, callback) {
-  this.request("sms", "selectoutbox", data, callback);
-};
-KavenegarApi.prototype.LatestOutbox = function(data, callback) {
-  this.request("sms", "latestoutbox", data, callback);
-};
-KavenegarApi.prototype.CountOutbox = function(data, callback) {
-  this.request("sms", "countoutbox", data, callback);
-};
-KavenegarApi.prototype.Cancel = function(data, callback) {
-  this.request("sms", "cancel", data, callback);
-};
-KavenegarApi.prototype.Receive = function(data, callback) {
-  this.request("sms", "receive", data, callback);
-};
-KavenegarApi.prototype.CountInbox = function(data, callback) {
-  this.request("sms", "countinbox", data, callback);
-};
-KavenegarApi.prototype.CountPostalCode = function(data, callback) {
-  this.request("sms", "countpostalcode", data, callback);
-};
-KavenegarApi.prototype.SendByPostalCode = function(data, callback) {
-  this.request("sms", "sendbypostalcode", data, callback);
-};
-KavenegarApi.prototype.VerifyLookup = function(data, callback) {
-  this.request("verify", "lookup", data, callback);
-};
-KavenegarApi.prototype.AccountInfo = function(data, callback) {
-  this.request("account", "info", data, callback);
-};
-KavenegarApi.prototype.AccountConfig = function(data, callback) {
-  this.request("account", "config", data, callback);
-};
-KavenegarApi.prototype.CallMakeTTS = function(data, callback) {
-  this.request("call", "maketts", data, callback);
-};
-module.exports.KavenegarApi = function (options) {
-  var obj = new KavenegarApi(options);
-  return obj;
-}
diff --git a/jest.config.ts b/jest.config.ts
index 7331801..6c6b645 100644
--- a/jest.config.ts
+++ b/jest.config.ts
@@ -1,52 +1,56 @@
-import type { Config } from 'jest';
-
-const config: Config = {
-  rootDir: '.',
+import type { Config } from 'jest';
+
+const config: Config = {
+  rootDir: '.',
   roots: [
     '<rootDir>/apps/api/src',
     '<rootDir>/apps/api/test',
     '<rootDir>/apps/api/src/tests',
+    '<rootDir>/libs/shared/src',
   ],
   testMatch: [
     '<rootDir>/apps/api/src/**/*.spec.ts',
     '<rootDir>/apps/api/test/**/*.spec.ts',
+    '<rootDir>/libs/shared/src/**/*.spec.ts',
   ],
-  moduleFileExtensions: ['ts', 'tsx', 'js', 'json'],
+  moduleFileExtensions: ['ts', 'tsx', 'js', 'json'],
   transform: {
     '^.+\\.(t|j)s$': [
       'ts-jest',
       {
-        tsconfig: '<rootDir>/tsconfig.spec.json',
+        tsconfig: '<rootDir>/apps/api/tsconfig.spec.json',
         diagnostics: false,
       },
     ],
   },
-  moduleNameMapper: {
-    '^@app/(.*)$': '<rootDir>/apps/api/src/$1',
-    '^@test/(.*)$': '<rootDir>/apps/api/test/$1',
-    '^@/(.*)$': '<rootDir>/$1',
-  },
+  moduleNameMapper: {
+    '^@app/(.*)$': '<rootDir>/apps/api/src/$1',
+    '^@test/(.*)$': '<rootDir>/apps/api/test/$1',
+    '^@/(.*)$': '<rootDir>/$1',
+  },
   collectCoverageFrom: [
     '<rootDir>/apps/api/src/**/*.(t|j)s',
     '!<rootDir>/apps/api/src/**/*.spec.ts',
+    '<rootDir>/libs/shared/src/**/*.(t|j)s',
+    '!<rootDir>/libs/shared/src/**/*.spec.ts',
   ],
-  coverageDirectory: '<rootDir>/coverage',
-  coverageThreshold: {
-    global: {
-      statements: 70,
-      branches: 60,
-      functions: 70,
-      lines: 70,
-    },
-    './apps/api/src/core/upload/**/*.ts': {
-      statements: 90,
-      branches: 85,
-      functions: 90,
-      lines: 90,
-    },
-  },
-  testEnvironment: 'node',
-  verbose: false,
-};
-
-export default config;
+  coverageDirectory: '<rootDir>/coverage',
+  coverageThreshold: {
+    global: {
+      statements: 70,
+      branches: 60,
+      functions: 70,
+      lines: 70,
+    },
+    './apps/api/src/core/upload/**/*.ts': {
+      statements: 90,
+      branches: 85,
+      functions: 90,
+      lines: 90,
+    },
+  },
+  testEnvironment: 'node',
+  verbose: false,
+};
+
+export default config;
diff --git a/nest-cli.json b/nest-cli.json
index fa18c0c..7f7bfda 100644
--- a/nest-cli.json
+++ b/nest-cli.json
@@ -1,15 +1,9 @@
 {
-  "$schema": "https://json.schemastore.org/nest-cli",
   "collection": "@nestjs/schematics",
+  "monorepo": true,
+  "root": "apps",
   "sourceRoot": "apps/api/src",
   "compilerOptions": {
-    "deleteOutDir": true,
-    "assets": [
-      {
-        "include": "vendors/**/*",
-        "outDir": "dist/apps/api"
-      }
-    ],
-    "watchAssets": true
+    "deleteOutDir": false
   }
 }
diff --git a/package.json b/package.json
index 9f16533..7fe304c 100644
--- a/package.json
+++ b/package.json
@@ -1,100 +1,102 @@
-{
-  "name": "negare-api",
-  "version": "0.0.1",
-  "private": true,
-  "license": "UNLICENSED",
-  "engines": {
-    "node": ">=22 <23"
-  },
-  "prisma": {
-    "schema": "prisma/schema.prisma"
-  },
-  "scripts": {
-    "dev": "nest start --watch",
-    "build": "prisma generate --schema prisma/schema.prisma && nest build api",
-    "format": "prettier --write \"apps/api/src/**/*.ts\" \"apps/api/test/**/*.ts\" \"scripts/**/*.ts\"",
-    "start": "node dist/apps/api/main.js",
-    "start:dev": "nest start --watch",
-    "start:debug": "nest start api --debug --watch",
-    "start:prod": "node dist/apps/api/main.js",
-    "lint": "cross-env ESLINT_USE_FLAT_CONFIG=false eslint \"{apps/api/src,apps/api/test,test}/**/*.ts\" --fix",
-    "docs:openapi": "node ./scripts/export-openapi.js",
-    "test": "jest",
-    "test:watch": "jest --watch",
-    "test:cov": "jest --coverage",
-    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
-    "test:e2e": "jest --config ./test/jest-e2e.json",
-    "prisma:generate": "prisma generate --schema prisma/schema.prisma",
-    "prisma:migrate:dev": "prisma migrate dev --schema prisma/schema.prisma --name init-dev",
-    "prisma:migrate:deploy": "prisma migrate deploy --schema prisma/schema.prisma",
-    "db:reset:prisma": "prisma migrate reset --force --schema prisma/schema.prisma",
-    "compose:up": "docker compose up --build",
-    "compose:down": "docker compose down -v",
-    "compose:logs": "docker compose logs -f api",
-    "migrate:deploy": "prisma migrate deploy --schema apps/api/prisma/schema.prisma",
-    "start:prod": "node dist/apps/api/main.js",
-    "start:prod:with-migrate": "npm run migrate:deploy && npm run start:prod"
-  },
-  "dependencies": {
-    "@nestjs/common": "^11.0.1",
-    "@nestjs/config": "^4.0.2",
-    "@nestjs/core": "^11.0.1",
-    "@nestjs/platform-express": "^11.0.1",
-    "@nestjs/platform-socket.io": "^11.1.8",
-    "@nestjs/swagger": "^11.2.0",
-    "@nestjs/websockets": "^11.1.8",
-    "@prisma/client": "6.18.0",
-    "basic-ftp": "^5.0.5",
-    "bcrypt": "^6.0.0",
-    "class-transformer": "^0.5.1",
-    "class-validator": "^0.14.2",
-    "cookie-parser": "^1.4.7",
-    "file-type": "^21.0.0",
-    "helmet": "^8.1.0",
-    "ioredis": "^5.8.2",
-    "jsonwebtoken": "^9.0.2",
-    "kavenegar": "^1.1.4",
-    "multer": "^2.0.2",
-    "nodemailer": "^7.0.9",
-    "pg": "^8.16.3",
-    "reflect-metadata": "^0.2.2",
-    "rxjs": "^7.8.1",
-    "socket.io": "^4.8.1",
-    "socket.io-client": "^4.8.1",
-    "swagger-ui-express": "^5.0.1",
-    "zod": "^3.25.76"
-  },
-  "devDependencies": {
-    "@nestjs/cli": "^11.0.0",
-    "@nestjs/schematics": "^11.0.0",
-    "@nestjs/testing": "^11.0.1",
-    "@swc/cli": "^0.6.0",
-    "@swc/core": "^1.10.7",
-    "@types/bcrypt": "^6.0.0",
-    "@types/cookie-parser": "^1.4.9",
-    "@types/express": "^5.0.0",
-    "@types/helmet": "^4.0.0",
-    "@types/jest": "^29.5.14",
-    "@types/jsonwebtoken": "^9.0.10",
-    "@types/multer": "^2.0.0",
-    "@types/node": "^22.18.10",
-    "@types/supertest": "^6.0.2",
-    "@typescript-eslint/eslint-plugin": "^8.20.0",
-    "@typescript-eslint/parser": "^8.20.0",
-    "cross-env": "^7.0.3",
-    "eslint": "^9.18.0",
-    "eslint-config-prettier": "^10.0.1",
-    "eslint-plugin-prettier": "^5.2.2",
-    "jest": "^29.7.0",
-    "pg-mem": "^3.0.5",
-    "prettier": "^3.4.2",
-    "prisma": "6.18.0",
-    "source-map-support": "^0.5.21",
-    "supertest": "^7.0.0",
-    "ts-jest": "^29.2.5",
-    "ts-loader": "^9.5.2",
-    "ts-node": "^10.9.2",
-    "tsconfig-paths": "^4.2.0",
-    "typescript": "^5.9.3"
-  }
-}
+{
+  "name": "negare-api",
+  "version": "0.0.1",
+  "private": true,
+  "license": "UNLICENSED",
+  "engines": {
+    "node": ">=22 <23"
+  },
+  "prisma": {
+    "schema": "prisma/schema.prisma"
+  },
+  "scripts": {
+    "dev": "nest start api --watch",
+    "build": "tsc -p apps/api/tsconfig.build.json",
+    "typecheck": "tsc -p apps/api/tsconfig.build.json --noEmit",
+    "format": "prettier --write \"apps/api/src/**/*.ts\" \"apps/api/test/**/*.ts\" \"scripts/**/*.ts\"",
+    "start": "node dist/apps/api/main.js",
+    "start:dev": "nest start api --watch",
+    "start:debug": "nest start api --debug --watch",
+    "start:prod": "node dist/apps/api/main.js",
+    "lint": "cross-env ESLINT_USE_FLAT_CONFIG=false eslint \"{apps/api/src,apps/api/test,test}/**/*.ts\" --fix",
+    "docs:openapi": "node ./scripts/export-openapi.js",
+    "test": "jest --passWithNoTests",
+    "test:watch": "jest --watch",
+    "test:cov": "jest --coverage",
+    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
+    "test:e2e": "jest --config ./test/jest-e2e.json",
+    "prisma:generate": "prisma generate --schema prisma/schema.prisma",
+    "prisma:migrate:dev": "prisma migrate dev --schema prisma/schema.prisma --name init-dev",
+    "prisma:migrate:deploy": "prisma migrate deploy --schema prisma/schema.prisma",
+    "db:reset:prisma": "prisma migrate reset --force --schema prisma/schema.prisma",
+    "backfill:fa-slugs": "ts-node -r tsconfig-paths/register scripts/backfill-fa-slugs.ts",
+    "compose:up": "docker compose up --build",
+    "compose:down": "docker compose down -v",
+    "compose:logs": "docker compose logs -f api",
+    "migrate:deploy": "prisma migrate deploy --schema apps/api/prisma/schema.prisma",
+    "start:prod:with-migrate": "npm run migrate:deploy && npm run start:prod"
+  },
+  "dependencies": {
+    "@nestjs/common": "^11.0.1",
+    "@nestjs/config": "^4.0.2",
+    "@nestjs/core": "^11.0.1",
+    "@nestjs/platform-express": "^11.0.1",
+    "@nestjs/platform-socket.io": "^11.1.8",
+    "@nestjs/swagger": "^11.2.0",
+    "@nestjs/websockets": "^11.1.8",
+    "@prisma/client": "6.18.0",
+    "basic-ftp": "^5.0.5",
+    "bcrypt": "^6.0.0",
+    "class-transformer": "^0.5.1",
+    "class-validator": "^0.14.2",
+    "cookie-parser": "^1.4.7",
+    "file-type": "^21.0.0",
+    "helmet": "^8.1.0",
+    "ioredis": "^5.8.2",
+    "jsonwebtoken": "^9.0.2",
+    "kavenegar": "^1.1.4",
+    "multer": "^2.0.2",
+    "nodemailer": "^7.0.9",
+    "pg": "^8.16.3",
+    "reflect-metadata": "^0.2.2",
+    "rxjs": "^7.8.1",
+    "socket.io": "^4.8.1",
+    "socket.io-client": "^4.8.1",
+    "swagger-ui-express": "^5.0.1",
+    "zod": "^3.25.76"
+  },
+  "devDependencies": {
+    "@nestjs/cli": "^11.0.0",
+    "@nestjs/schematics": "^11.0.0",
+    "@nestjs/testing": "^11.0.1",
+    "@swc/cli": "^0.6.0",
+    "@swc/core": "^1.10.7",
+    "@types/bcrypt": "^6.0.0",
+    "@types/cookie-parser": "^1.4.9",
+    "@types/express": "^5.0.0",
+    "@types/helmet": "^4.0.0",
+    "@types/jest": "^29.5.14",
+    "@types/jsonwebtoken": "^9.0.10",
+    "@types/kavenegar": "^1.1.3",
+    "@types/multer": "^2.0.0",
+    "@types/node": "^22.18.10",
+    "@types/supertest": "^6.0.2",
+    "@typescript-eslint/eslint-plugin": "^8.20.0",
+    "@typescript-eslint/parser": "^8.20.0",
+    "cross-env": "^7.0.3",
+    "eslint": "^9.18.0",
+    "eslint-config-prettier": "^10.0.1",
+    "eslint-plugin-prettier": "^5.2.2",
+    "jest": "^29.7.0",
+    "pg-mem": "^3.0.5",
+    "prettier": "^3.4.2",
+    "prisma": "6.18.0",
+    "source-map-support": "^0.5.21",
+    "supertest": "^7.0.0",
+    "ts-jest": "^29.2.5",
+    "ts-loader": "^9.5.2",
+    "ts-node": "^10.9.2",
+    "tsconfig-paths": "^4.2.0",
+    "typescript": "^5.9.3"
+  }
+}
diff --git a/test/jest-e2e.json b/test/jest-e2e.json
index dcea58c..7b11460 100644
--- a/test/jest-e2e.json
+++ b/test/jest-e2e.json
@@ -1,20 +1,20 @@
-{
-  "moduleFileExtensions": ["ts", "tsx", "js", "json"],
-  "roots": [
-    "<rootDir>/apps/api/src",
-    "<rootDir>/apps/api/test",
-    "<rootDir>/apps/api/src/tests"
-  ],
-  "rootDir": "..",
-  "testEnvironment": "node",
-  "testRegex": "apps/api/test/.*\\.e2e-spec\\.ts$",
+{
+  "moduleFileExtensions": ["ts", "tsx", "js", "json"],
+  "roots": [
+    "<rootDir>/apps/api/src",
+    "<rootDir>/apps/api/test",
+    "<rootDir>/apps/api/src/tests"
+  ],
+  "rootDir": "..",
+  "testEnvironment": "node",
+  "testRegex": "apps/api/test/.*\\.e2e-spec\\.ts$",
   "transform": {
-    "^.+\\.(t|j)s$": ["ts-jest", { "tsconfig": "tsconfig.spec.json" }]
+    "^.+\\.(t|j)s$": ["ts-jest", { "tsconfig": "apps/api/tsconfig.spec.json" }]
   },
-  "moduleNameMapper": {
-    "^@app/(.*)$": "<rootDir>/apps/api/src/$1",
-    "^@test/(.*)$": "<rootDir>/apps/api/test/$1",
-    "^@/(.*)$": "<rootDir>/$1"
-  },
-  "setupFiles": ["<rootDir>/test/setup-env.ts"]
-}
+  "moduleNameMapper": {
+    "^@app/(.*)$": "<rootDir>/apps/api/src/$1",
+    "^@test/(.*)$": "<rootDir>/apps/api/test/$1",
+    "^@/(.*)$": "<rootDir>/$1"
+  },
+  "setupFiles": ["<rootDir>/test/setup-env.ts"]
+}
diff --git a/tsconfig.build.json b/tsconfig.build.json
index 69e99c1..ae81397 100644
--- a/tsconfig.build.json
+++ b/tsconfig.build.json
@@ -1,15 +1,3 @@
 {
-  "extends": "./tsconfig.json",
-  "compilerOptions": {
-    "outDir": "./dist/apps/api",
-    "rootDir": "./apps/api/src",
-    "tsBuildInfoFile": "./dist/apps/api/tsconfig.build.tsbuildinfo"
-  },
-  "exclude": [
-    "node_modules",
-    "apps/api/test",
-    "dist",
-    "**/*.spec.ts",
-    "**/*.e2e-spec.ts"
-  ]
+  "extends": "./apps/api/tsconfig.build.json"
 }
diff --git a/tsconfig.json b/tsconfig.json
index dd38dcb..ffcbb94 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,36 +1,3 @@
 {
-  "compilerOptions": {
-    "module": "commonjs",
-    "moduleResolution": "node",
-    "declaration": true,
-    "removeComments": true,
-    "emitDecoratorMetadata": true,
-    "experimentalDecorators": true,
-    "esModuleInterop": true,
-    "allowSyntheticDefaultImports": true,
-    "target": "ES2023",
-    "sourceMap": true,
-    "outDir": "./dist/apps/api",
-    "rootDir": "./apps/api/src",
-    "baseUrl": "./",
-    "incremental": true,
-    "skipLibCheck": true,
-    "forceConsistentCasingInFileNames": true,
-    "strict": true,
-    "strictNullChecks": true,
-    "strictBindCallApply": true,
-    "noFallthroughCasesInSwitch": true,
-    "noImplicitAny": true,
-    "strictPropertyInitialization": false,
-    "paths": {
-      "@app/*": ["apps/api/src/*"],
-      "@app/common/*": ["apps/api/src/common/*"],
-      "@app/core/*": ["apps/api/src/core/*"],
-      "@app/catalog/*": ["apps/api/src/catalog/*"],
-      "@app/shared/*": ["apps/api/src/shared/*"],
-      "@app/config/*": ["apps/api/src/config/*"],
-      "@test/*": ["apps/api/test/*"]
-    }
-  },
-  "include": ["apps/api/src/**/*", "apps/api/test/**/*", "scripts/**/*"]
+  "extends": "./tsconfig.base.json"
 }
diff --git a/tsconfig.spec.json b/tsconfig.spec.json
index b1b4b09..569b6ff 100644
--- a/tsconfig.spec.json
+++ b/tsconfig.spec.json
@@ -1,15 +1,3 @@
 {
-  "extends": "./tsconfig.json",
-  "compilerOptions": {
-    "allowJs": true,
-    "outDir": "./dist/spec"
-  },
-  "include": [
-    "apps/api/src/**/*.ts",
-    "apps/api/src/**/*.js",
-    "apps/api/src/tests/**/*.ts",
-    "apps/api/src/tests/**/*.js",
-    "apps/api/test/**/*.ts",
-    "test/**/*.ts"
-  ]
+  "extends": "./apps/api/tsconfig.spec.json"
 }
